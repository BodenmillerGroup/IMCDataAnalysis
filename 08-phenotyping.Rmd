# Cell phenotyping 

A common step during single-cell data analysis is the labeling of cells based
on their phenotype. Defining cell phenotypes is often subjective and relies
on previous biological knowledge. The [Orchestrating Single Cell Analysis with Bioconductor](https://bioconductor.org/books/3.14/OSCA.basic/cell-type-annotation.html) book
presents a number of approaches to phenotype cells detected by single-cell RNA
sequencing based on reference datasets or prior knowledge of gene sets.

In highly-multiplexed imaging, target proteins or moelcules are manually
selected based on the biological question at hand. It narrows down the feature
space and facilitates the manual annotation of clusters to derive cell
phenotypes. We will therefore discuss and compare a number of clustering
approaches to group cells based on their similarity in marker expression in
Section \@ref(clustering).

Unlike single-cell RNA sequencing and CyTOF data, single-cell data derived from
highly-multiplexed imaging data often suffers from "lateral spillover" between
neighboring cells. This spillover caused by imperfect segmentation often hinders
accurate clustering to define specific cell phenotypes in multiplexed imaging
data. Tools have been developed to correct lateral spillover between cells
[@Bai2021] but the approach requires careful selection of which markers to
correct. In Section \@ref(classification) we will train and apply a random
forest classifier to classify cell phenotypes in the dataset as alternative
approach for cell phenotyping. This approach has been previously used to
identify major cell phenotypes in metastatic melanoma and avoids clustering of
cells [@Hoch2022].

## Load data

We will first read in the previously generated `SpatialExperiment` object and
sample 2000 cells of the dataset to visualize cluster annotations.

```{r read-data-pheno, message=FALSE}
spe <- readRDS("data/spe.rds")

# Sample cells
set.seed(220410)
cur_cells <- sample(seq_len(ncol(spe)), 2000)
```

## Clustering approaches {#clustering}

In the first section to identify cellular phenotypes in the dataset, we will
present clustering approaches that group cells based on their similarity in
marker expression. A number approaches have been developed to cluster data
derived from single-cell RNA sequencing technologies [TODO ref] or CyTOF
[@Weber2016]. For demonstration purposes, we will highlight common clustering
approaches that are available in R and have been used for clustering cells
obtained from IMC. Two approaches rely on graph-based clustering and one
approach uses self organizing maps (SOM).

### Rphenograph

The PhenoGraph clustering approach was first described to group cells of a CyTOF
dataset in [@Levine2015]. The algorithm first constructs a graph by detecting
the `k` nearest neighbours based on euclidean distance in expression space. In
the next step, edges between nodes (cells) are weighted by their overlap in
nearest neighbor sets. To quantify the overlap in shared nearest neighbors, the
jaccard index is used. The Louvain modularity optimization approach is used
to detect connected communities and partition the graph into cluster of cells.
This clustering strategy was used by [@Jackson2020] to cluster IMC data.

There are several different PhenoGraph implementations available in R. Here, we
use the one available at
[https://github.com/i-cyto/Rphenograph](https://github.com/i-cyto/Rphenograph).
For large datasets,
[https://github.com/stuchly/Rphenoannoy](https://github.com/stuchly/Rphenoannoy)
offers a more performant implementation of the algorithm.

In the following code chunk, we select the asinh-transformed mean pixel
intensities per cell and channel and subset the channels to the ones containing
biological variation. This matrix is transposed to store cells in rows. Within
the `Rphenograph` function, we select the 45 nearest neighbors for graph
building and louvain community detection (default). The function returns a list
of length 2, the first entry being the graph and the second entry containing the
community object. Calling `membership` on the community object will return
cluster IDs for each cell. These cluster IDs are then stored within the
`colData` of the `SpatialExperiment` object. Cluster IDs are mapped on top of
the UMAP embedding and single-cell marker expression within each cluster are
visualized in form of a heatmap.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r rphenograph-1, message=FALSE}
library(Rphenograph)
library(igraph)
library(dittoSeq)
library(viridis)
mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

out <- Rphenograph(mat, k = 45)

clusters <- factor(membership(out[[2]]))

spe$pg_clusters <- clusters

dittoDimPlot(spe, var = "pg_clusters", 
             reduction.use = "UMAP", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("pg_clusters", "patient_id"))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The `Rphenograph` function call took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

We can observe that some of the clusters only contain cells of a single patient.
This  can often be observed in the tumor compartment. In the next step, we
use the integrated cells (see Section \@ref(batch-effects)) in low dimensional
embedding for clustering. Here, the low dimensional embedding can
be directly accessed from the `reducedDim` slot.

```{r rphenograph-2, message=FALSE}
mat <- reducedDim(spe, "fastMNN")

out <- Rphenograph(mat, k = 45)

clusters <- factor(membership(out[[2]]))

spe$pg_clusters_corrected <- clusters

dittoDimPlot(spe, var = "pg_clusters_corrected", 
             reduction.use = "UMAP_mnnCorrected", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("pg_clusters_corrected", "patient_id"))
```

Clustering using the integrated embedding leads to clusters that contain cells
of different patients. Cluster annotation can now be performed by manually labeling
cells based on their marker expression. 

### Shared nearest neighbour graph

Sunnys paper?

Test more k's

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r parameter-sweep}
library(bluster)
library(BiocParallel)
library(ggplot2)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

combinations <- clusterSweep(mat, BLUSPARAM=SNNGraphParam(),
    k=c(10L, 20L), cluster.fun=c("walktrap", "louvain"),
    BPPARAM = bpparam())

sil <- vapply(as.list(combinations$clusters), 
              function(x) mean(approxSilhouette(mat, x)$width), 
              0)

ggplot(data.frame(method = names(sil),
                  sil = sil)) +
    geom_point(aes(method, sil)) +
    theme_classic()
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The cluster parameter sweep took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

rank-based weights + walktrap clustering

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r snn-1, message=FALSE}
library(scran)
library(bluster)
library(BiocParallel)

clusters <- clusterCells(spe[rowData(spe)$use_channel,], 
                         assay.type = "exprs", 
                         BLUSPARAM = NNGraphParam(k=20, 
                                                  cluster.fun = "louvain",
                                                  BPPARAM = bpparam()))

spe$nn_clusters <- clusters

dittoDimPlot(spe, var = "nn_clusters", 
             reduction.use = "UMAP", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "nn_clusters")
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The shared nearest beighbor graph clustering approach took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

Integrated cells

```{r snn-2, message=FALSE}
clusters <- clusterCells(spe[rowData(spe)$use_channel,], 
                         use.dimred = "fastMNN", 
                         BLUSPARAM = NNGraphParam(k=20, 
                                                  cluster.fun = "louvain",
                                                  BPPARAM = bpparam()))

spe$nn_clusters_corrected <- clusters

dittoDimPlot(spe, var = "nn_clusters_corrected", 
             reduction.use = "UMAP", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "nn_clusters_corrected")
```

### FlowSOM

Tobis paper?

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r flowSOM-1, message=FALSE}
library(CATALYST)

spe <- cluster(spe, 
               features = rownames(spe)[rowData(spe)$use_channel],
               maxK = 30,
               seed = 220410)

delta_area(spe)

spe$som_clusters <- cluster_ids(spe, "meta13")

dittoDimPlot(spe, var = "som_clusters", 
             reduction.use = "UMAP", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters")
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

Running FlowSOM clustering took  
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

```{r flowSOM-2, message=FALSE}
library(kohonen)
mat <- reducedDim(spe, "fastMNN")

set.seed(1000)
som.out <- clusterRows(mat, SomParam(13))

spe$som_clusters_corrected <- som.out

dittoDimPlot(spe, var = "som_clusters_corrected", 
             reduction.use = "UMAP_mnnCorrected", size = 0.2) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters_corrected")
```



### Compare between clustering approaches

```{r raw-counts}
library(patchwork)
tab1 <- table(paste("Rphenograph", spe$pg_clusters), 
              paste("SNN", spe$nn_clusters))
tab2 <- table(paste("Rphenograph", spe$pg_clusters), 
              paste("SOM", spe$som_clusters))
tab3 <- table(paste("SNN", spe$nn_clusters), 
              paste("SOM", spe$som_clusters))

pheatmap(log10(tab1 + 10), color = viridis(100)) 
pheatmap(log10(tab2 + 10), color = viridis(100)) 
pheatmap(log10(tab3 + 10), color = viridis(100)) 
```

```{r corrected}
tab1 <- table(paste("Rphenograph", spe$pg_clusters_corrected), 
              paste("SNN", spe$nn_clusters_corrected))
tab2 <- table(paste("Rphenograph", spe$pg_clusters_corrected), 
              paste("SOM", spe$som_clusters_corrected))
tab3 <- table(paste("SNN", spe$nn_clusters_corrected), 
              paste("SOM", spe$som_clusters_corrected))

pheatmap(log10(tab1 + 10), color = viridis(100)) 
pheatmap(log10(tab2 + 10), color = viridis(100)) 
pheatmap(log10(tab3 + 10), color = viridis(100)) 
```

Mention cluster stability metrics https://www.bioconductor.org/packages/release/bioc/vignettes/bluster/inst/doc/diagnostics.html

## Classification approaches {#classification}

### Manual labelling of cells

### Training a classifier

### Classifier performance

### Classification of new data

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>
