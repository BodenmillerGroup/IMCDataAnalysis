# Cell phenotyping 

A common step during single-cell data analysis is the labeling of cells based
on their phenotype. Defining cell phenotypes is often subjective and relies
on previous biological knowledge. The [Orchestrating Single Cell Analysis with Bioconductor](https://bioconductor.org/books/3.14/OSCA.basic/cell-type-annotation.html) book
presents a number of approaches to phenotype cells detected by single-cell RNA
sequencing based on reference datasets or prior knowledge of gene sets.

In highly-multiplexed imaging, target proteins or moelcules are manually
selected based on the biological question at hand. It narrows down the feature
space and facilitates the manual annotation of clusters to derive cell
phenotypes. We will therefore discuss and compare a number of clustering
approaches to group cells based on their similarity in marker expression in
Section \@ref(clustering).

Unlike single-cell RNA sequencing and CyTOF data, single-cell data derived from
highly-multiplexed imaging data often suffers from "lateral spillover" between
neighboring cells. This spillover caused by imperfect segmentation often hinders
accurate clustering to define specific cell phenotypes in multiplexed imaging
data. Tools have been developed to correct lateral spillover between cells
[@Bai2021] but the approach requires careful selection of which markers to
correct. In Section \@ref(classification) we will train and apply a random
forest classifier to classify cell phenotypes in the dataset as alternative
approach for cell phenotyping. This approach has been previously used to
identify major cell phenotypes in metastatic melanoma and avoids clustering of
cells [@Hoch2022].

## Load data

We will first read in the previously generated `SpatialExperiment` object and
sample 2000 cells of the dataset to visualize cluster annotations.

```{r read-data-pheno, message=FALSE}
spe <- readRDS("data/spe.rds")

# Sample cells
set.seed(220410)
cur_cells <- sample(seq_len(ncol(spe)), 2000)
```

## Clustering approaches {#clustering}

In the first section to identify cellular phenotypes in the dataset, we will
present clustering approaches that group cells based on their similarity in
marker expression. A number approaches have been developed to cluster data
derived from single-cell RNA sequencing technologies [TODO ref] or CyTOF
[@Weber2016]. For demonstration purposes, we will highlight common clustering
approaches that are available in R and have been used for clustering cells
obtained from IMC. Two approaches rely on graph-based clustering and one
approach uses self organizing maps (SOM).

### Rphenograph

The PhenoGraph clustering approach was first described to group cells of a CyTOF
dataset in [@Levine2015]. The algorithm first constructs a graph by detecting
the `k` nearest neighbours based on euclidean distance in expression space. In
the next step, edges between nodes (cells) are weighted by their overlap in
nearest neighbor sets. To quantify the overlap in shared nearest neighbors, the
jaccard index is used. The Louvain modularity optimization approach is used
to detect connected communities and partition the graph into cluster of cells.
This clustering strategy was used by [@Jackson2020] to cluster IMC data.

There are several different PhenoGraph implementations available in R. Here, we
use the one available at
[https://github.com/i-cyto/Rphenograph](https://github.com/i-cyto/Rphenograph).
For large datasets,
[https://github.com/stuchly/Rphenoannoy](https://github.com/stuchly/Rphenoannoy)
offers a more performant implementation of the algorithm.

In the following code chunk, we select the asinh-transformed mean pixel
intensities per cell and channel and subset the channels to the ones containing
biological variation. This matrix is transposed to store cells in rows. Within
the `Rphenograph` function, we select the 45 nearest neighbors for graph
building and louvain community detection (default). The function returns a list
of length 2, the first entry being the graph and the second entry containing the
community object. Calling `membership` on the community object will return
cluster IDs for each cell. These cluster IDs are then stored within the
`colData` of the `SpatialExperiment` object. Cluster IDs are mapped on top of
the UMAP embedding and single-cell marker expression within each cluster are
visualized in form of a heatmap.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r rphenograph-1, message=FALSE}
library(Rphenograph)
library(igraph)
library(dittoSeq)
library(viridis)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

out <- Rphenograph(mat, k = 45)

clusters <- factor(membership(out[[2]]))

spe$pg_clusters <- clusters

dittoDimPlot(spe, var = "pg_clusters", 
             reduction.use = "UMAP", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("pg_clusters", "patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters))],
                              metadata(spe)$color_vectors$patient_id))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The `Rphenograph` function call took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

We can observe that some of the clusters only contain cells of a single patient.
This  can often be observed in the tumor compartment. In the next step, we
use the integrated cells (see Section \@ref(batch-effects)) in low dimensional
embedding for clustering. Here, the low dimensional embedding can
be directly accessed from the `reducedDim` slot.

```{r rphenograph-2, message=FALSE}
mat <- reducedDim(spe, "fastMNN")

out <- Rphenograph(mat, k = 45)

clusters <- factor(membership(out[[2]]))

spe$pg_clusters_corrected <- clusters

dittoDimPlot(spe, var = "pg_clusters_corrected", 
             reduction.use = "UMAP_mnnCorrected", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("pg_clusters_corrected", "patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))],
                              metadata(spe)$color_vectors$patient_id))
```

Clustering using the integrated embedding leads to clusters that contain cells
of different patients. Cluster annotation can now be performed by manually labeling
cells based on their marker expression. 

### Shared nearest neighbour graph

The [bluster](https://www.bioconductor.org/packages/release/bioc/html/bluster.html) 
package provides a simple interface to cluster cells using a number of different
[clustering approaches](https://www.bioconductor.org/packages/release/bioc/vignettes/bluster/inst/doc/clusterRows.html) and different metrics to [access cluster stability](https://www.bioconductor.org/packages/release/bioc/vignettes/bluster/inst/doc/diagnostics.html).  

For simplicity, we will focus on graph based clustering as this is the most
popular and a fast method for single-cell clustering. The `bluster` package
provides functionalities to build k-nearest neighbour (KNN) and it's weighted
version (shared nearest neighbor; SNN) graphs where nodes represent cells.
The user can chose the number of neighbors to consider (parameter `k`), the 
the edge weighting method (parameter `type`) and the community detection
function to use (parameter `cluster.fun`). As all parameters affect the clustering
results, the `bluster` package provides the `clusterSweep` function to test
a number of parameter settings in parallel. In the following code chunk,
we select the asinh-transformed mean pixel intensities and subset the markers
of interest. The resulting matrix is transposed to fit to the requirements of 
the bluster package (cells in rows).

We test two different settings for `k`, two for `type` and two for `cluster.fun`.
This function call is parallelized by setting the `BPPARAM` parameter. We use
the `approxSilhouette` function to compute the silhouette width for each cell
and compute the average across all cells per parameter setting. 
Please see `?silhouette` for more information on how the silhouette 
width id computed for each cell. A large average silhouette width indicates 
cells that are well clustered.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r parameter-sweep, message=FALSE}
library(bluster)
library(BiocParallel)
library(ggplot2)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

combinations <- clusterSweep(mat, BLUSPARAM=SNNGraphParam(),
                             k=c(10L, 20L), 
                             type = c("rank", "jaccard"), 
                             cluster.fun=c("walktrap", "louvain"),
                             BPPARAM = bpparam())

sil <- vapply(as.list(combinations$clusters), 
              function(x) mean(approxSilhouette(mat, x)$width), 
              0)

ggplot(data.frame(method = names(sil),
                  sil = sil)) +
    geom_point(aes(method, sil)) +
    theme_classic(base_size = 15) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab("Cluster parameter combination") +
    ylab("Average silhouette width")
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The cluster parameter sweep took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

Performing a cluster sweep takes some time as multiple clustering are run in parallel.
We do however recommend testing a number of different parameter settings to
access clustering performance.

Once parameter settings are know, we can either use the `clusterRows` function
of the `bluster` package to cluster cells or its convenient wrapper function
exported by the
[scran](https://bioconductor.org/packages/release/bioc/html/scran.html) package.
The `scran::clusterCells` function accepts a `SpatialExperiment` (or
`SingleCellExperiment`) object which stores cells in columns. By default, the
function detects the 10 nearest neighbours for each cell, performs rank-based
weighting of edges (see `?makeSNNGraph` for more information) and uses the
`cluster_walktrap` function to detect communities in the graph.

As we can see above, the `louvain` community detection approach outperforms the 
default `walktrap` approach in this dataset. We also increase the number of nearest
neighbors to decrease granularity of the resulting clusters.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r snn-1, message=FALSE}
library(scran)

clusters <- clusterCells(spe[rowData(spe)$use_channel,], 
                         assay.type = "exprs", 
                         BLUSPARAM = NNGraphParam(k=20, 
                                                  cluster.fun = "louvain",
                                                  type = "rank",
                                                  BPPARAM = bpparam()))

spe$nn_clusters <- clusters

dittoDimPlot(spe, var = "nn_clusters", 
             reduction.use = "UMAP", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("nn_clusters", "patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters))],
                              metadata(spe)$color_vectors$patient_id))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

The shared nearest neighbor graph clustering approach took 
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

This function was used by [@Tietscher2022] to cluster cells obtained by IMC. Setting
`type = "jaccard"` performs clustering similar to `Rphenograph` above and [Seurat](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#cluster-the-cells-1).

Similar to the results obtained by `Rphenograph`, some of the clusters are 
patient-specific. We can now perform clustering of the integrated cells
by directly specifying which low-dimensional embedding to use:

```{r snn-2, message=FALSE}
clusters <- clusterCells(spe[rowData(spe)$use_channel,], 
                         use.dimred = "fastMNN", 
                         BLUSPARAM = NNGraphParam(k=20, 
                                                  cluster.fun = "louvain",
                                                  type = "rank",
                                                  BPPARAM = bpparam()))

spe$nn_clusters_corrected <- clusters

dittoDimPlot(spe, var = "nn_clusters_corrected", 
             reduction.use = "UMAP_mnnCorrected", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = c("nn_clusters_corrected", "patient_id"),
             annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters_corrected))],
                              metadata(spe)$color_vectors$patient_id))
```

### FlowSOM

An alternative to graph-based clustering is offered by the
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
package. The `cluster` function internally uses the
[FlowSOM](https://bioconductor.org/packages/release/bioc/html/FlowSOM.html)
package to group cells into 100 (default) clusters based on self organizing maps
(SOM). In the next step, the
[ConsensusClusterPlus](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html)
package is used to perform hierarchical consensus clustering of the previously
detected 100 SOM nodes into 1 to `maxK` clusters. Cluster stability for each `k`
can be assessed by plotting the `delta_area(spe)`. The optimal number
of clusters can be found by selecting the `k` at which a plateau is reached.
In the example below, the optimal `k` lies somewhere around 13.

```{r, echo=FALSE}
start_time <- Sys.time()
```

```{r flowSOM-1, message=FALSE}
library(CATALYST)

# Run FlowSOM and ConsensusClusterPlus clustering
spe <- cluster(spe, 
               features = rownames(spe)[rowData(spe)$use_channel],
               maxK = 30,
               seed = 220410)

# Assess cluster stability
delta_area(spe)

spe$som_clusters <- cluster_ids(spe, "meta13")

dittoDimPlot(spe, var = "som_clusters", 
             reduction.use = "UMAP", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters",
             annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters))],
                              metadata(spe)$color_vectors$patient_id))
```

```{r, echo=FALSE}
end_time <- Sys.time()
```

Running FlowSOM clustering took  
`r round(as.numeric(difftime(end_time, start_time, units = "mins")), digits = 2)` minutes.

The `CATALYST` package does not provide functionality to perform `FlowSOM` and
`ConsensusClusterPlus` clustering directly on the integrated cells. As an
alternative to the `CATALYST` package, `bluster` provides SOM clustering when
specifying the `SomParam()` parameter. Similar to the `CATALYST` approach,
we will first cluster the dataset into 100 clusters (also called "codes").
These codes are then further clustered into a maximum of 30 clusters using 
`ConsensusClusterPlus` (using hierarchical clustering and euclidean distance).
The delta area plot can be accessed using the (not exported) `.plot_delta_area`
function from `CATALYST`. Here, it seems that the plateau is reached at a
`k` of 16 and we will store the final cluster IDs within the `SpatialExperiment`
object.

```{r flowSOM-2, message=FALSE}
library(kohonen)
library(ConsensusClusterPlus)

# Select integrated cells
mat <- reducedDim(spe, "fastMNN")

# Perform SOM clustering
set.seed(1000)
som.out <- clusterRows(mat, SomParam(100), full = TRUE)

# Cluster the 100 SOM codes into larger clusters
ccp <- ConsensusClusterPlus(t(som.out$objects$som$codes[[1]]),
                            maxK = 30,
                            reps = 100, 
                            distance = "euclidean", 
                            seed = 220410, 
                            plot = NULL)

# Visualize delta area plot
CATALYST:::.plot_delta_area(ccp)

# Link ConsensusClusterPlus clusters with SOM codes and save in object
som.cluster <- ccp[[16]][["consensusClass"]][som.out$clusters]
spe$som_clusters_corrected <- as.factor(som.cluster)

dittoDimPlot(spe, var = "som_clusters_corrected", 
             reduction.use = "UMAP_mnnCorrected", size = 0.2,
             do.label = TRUE) +
    ggtitle("Phenograph clusters expression on UMAP")

dittoHeatmap(spe[,cur_cells], 
             genes = rownames(spe)[rowData(spe)$use_channel],
             assay = "exprs", scale = "none",
             heatmap.colors = viridis(100), 
             annot.by = "som_clusters_corrected",
             annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters_corrected))],
                              metadata(spe)$color_vectors$patient_id))
```

The `FlowSOM` clustering approach has been used by [@Hoch2022] to sub-cluster tumor
cells as measured by IMC.

### Compare between clustering approaches

```{r raw-counts}
library(patchwork)
tab1 <- table(paste("Rphenograph", spe$pg_clusters), 
              paste("SNN", spe$nn_clusters))
tab2 <- table(paste("Rphenograph", spe$pg_clusters), 
              paste("SOM", spe$som_clusters))
tab3 <- table(paste("SNN", spe$nn_clusters), 
              paste("SOM", spe$som_clusters))

pheatmap(log10(tab1 + 10), color = viridis(100)) 
pheatmap(log10(tab2 + 10), color = viridis(100)) 
pheatmap(log10(tab3 + 10), color = viridis(100)) 
```

```{r corrected}
tab1 <- table(paste("Rphenograph", spe$pg_clusters_corrected), 
              paste("SNN", spe$nn_clusters_corrected))
tab2 <- table(paste("Rphenograph", spe$pg_clusters_corrected), 
              paste("SOM", spe$som_clusters_corrected))
tab3 <- table(paste("SNN", spe$nn_clusters_corrected), 
              paste("SOM", spe$som_clusters_corrected))

pheatmap(log10(tab1 + 10), color = viridis(100)) 
pheatmap(log10(tab2 + 10), color = viridis(100)) 
pheatmap(log10(tab3 + 10), color = viridis(100)) 
```

Mention cluster stability metrics https://www.bioconductor.org/packages/release/bioc/vignettes/bluster/inst/doc/diagnostics.html

## Classification approaches {#classification}

### Manual labelling of cells

### Training a classifier

### Classifier performance

### Classification of new data

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>
