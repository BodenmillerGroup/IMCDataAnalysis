# Preprocessing IMC data

To follow the code in this section, please install [imcRtools](https://github.com/BodenmillerGroup/imcRtools) from Github.

```{r install-dependencies, message = FALSE}
library(devtools)

install_github("BodenmillerGroup/imcRtools")
```

To test the scripts, please also access the raw data via:

```{r access-data, message=FALSE}
sm_url <- "https://data.mendeley.com/public-files/datasets/v58yj49pfr/files/b39223d2-2825-4e79-9875-86fa0e1c55d2/file_downloaded?dl=1"

download.file(sm_url, "data/Figure_S5.zip")
unzip("data/Figure_S5.zip", exdir="data", overwrite=TRUE)
unlink("data/Figure_S5.zip")
```

## Read in the data

Overview on how to read in pre-processed data.

## Generate a spillover matrix

In this section, we will highlight the use of `imcRtools` and `CATALYST` to generate a spillover matrix for IMC data.

### Read in the data

First, we need to read in the txt files.

```{r, message=FALSE}
library(tidyverse)

# Read txt files
cur_txts_names <- list.files("data/Figure_S5/Spillover_Matrix_1/", full.names = TRUE)
cur_txts <- lapply(cur_txts_names, read_delim, delim = "\t")

names(cur_txts) <- str_match(cur_txts_names, "[A-Za-z]{2}[0-9]{2,3}")
```

### Quality control

Visualize median expression

```{r QC, message = FALSE}
library(pheatmap)
library(viridis)

cur_medians <- lapply(cur_txts, function(x){
    cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) 
    cur_m <- colMedians(as.matrix(cur_txt))
    names(cur_m) <- colnames(cur_txt)
    return(cur_m)
})

cur_medians <- do.call(rbind, cur_medians)

# Order matrix by metal
cur_medians <- cur_medians[order(as.numeric(str_match(rownames(cur_medians), "[0-9]{2,3}"))),
                           order(as.numeric(str_match(colnames(cur_medians), "[0-9]{2,3}")))]

pheatmap(log10(cur_medians + 1), cluster_rows = FALSE, cluster_cols = FALSE,
         color = viridis(100))

# Visualize a threshold - multiplication with 1 to change logical to numeric
pheatmap(1 * (cur_medians > 200), 
         cluster_rows = FALSE, cluster_cols = FALSE)
```

## Optional binning

If the signals are too low, pixels can be summed:

```{r binning, message=FALSE}
library(zoo)

bin_size = 10

cur_txts_binned <- lapply(cur_txts, function(x){
        cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) %>%
            as.matrix()
        cur_txt <- apply(cur_txt, 2, rollapply, width = bin_size, FUN = sum, by = bin_size)
        return(cur_txt)
})
```