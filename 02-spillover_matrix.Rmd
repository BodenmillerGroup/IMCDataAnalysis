# Generate a spillover matrix

In this section, we will highlight the use of `imcRtools` and `CATALYST` to generate a spillover matrix for IMC data.

To test the scripts, please access the raw data via:

```{r access-data, message=FALSE}
sm_url <- "https://data.mendeley.com/public-files/datasets/v58yj49pfr/files/b39223d2-2825-4e79-9875-86fa0e1c55d2/file_downloaded?dl=1"

download.file(sm_url, "data/Figure_S5.zip")
unzip("data/Figure_S5.zip", exdir="data", overwrite=TRUE)
unlink("data/Figure_S5.zip")
```

### Read in the data

First, we need to read in the txt files.

```{r, message=FALSE}
library(tidyverse)

# Read txt files
cur_txts_names <- list.files("data/Figure_S5/Spillover_Matrix_1/", full.names = TRUE)
cur_txts <- lapply(cur_txts_names, read_delim, delim = "\t")

names(cur_txts) <- str_match(cur_txts_names, "[A-Za-z]{2}[0-9]{2,3}")
```

### Quality control

Visualize median expression

```{r QC, message = FALSE}
library(pheatmap)
library(viridis)
library(matrixStats)

cur_medians <- lapply(cur_txts, function(x){
    cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) 
    cur_m <- colMedians(as.matrix(cur_txt))
    names(cur_m) <- colnames(cur_txt)
    return(cur_m)
})

cur_medians <- do.call(rbind, cur_medians)

# Order matrix by metal
cur_medians <- cur_medians[order(as.numeric(str_match(rownames(cur_medians), "[0-9]{2,3}"))),
                           order(as.numeric(str_match(colnames(cur_medians), "[0-9]{2,3}")))]

pheatmap(log10(cur_medians + 1), cluster_rows = FALSE, cluster_cols = FALSE,
         color = viridis(100))

# Visualize a threshold - multiplication with 1 to change logical to numeric
pheatmap(1 * (cur_medians > 200), 
         cluster_rows = FALSE, cluster_cols = FALSE)
```

## Optional binning

If the signals are too low, pixels can be summed:

```{r binning, message=FALSE,}
library(zoo)

bin_size = 10

cur_txts_binned <- lapply(cur_txts, function(x){
        cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) %>%
            as.matrix()
        cur_txt <- apply(cur_txt, 2, function(y){rollapply(y, width = bin_size, FUN = sum, by = bin_size)})
        return(cur_txt)
})

cur_medians <- lapply(cur_txts_binned, function(x){
    cur_m <- colMedians(as.matrix(x))
    names(cur_m) <- colnames(x)
    return(cur_m)
})

cur_medians <- do.call(rbind, cur_medians)

# Order matrix by metal
cur_medians <- cur_medians[order(as.numeric(str_match(rownames(cur_medians), "[0-9]{2,3}"))),
                           order(as.numeric(str_match(colnames(cur_medians), "[0-9]{2,3}")))]

pheatmap(log10(cur_medians + 1), cluster_rows = FALSE, cluster_cols = FALSE,
         color = viridis(100))

# Visualize a threshold - multiplication with 1 to change logical to numeric
pheatmap(1 * (cur_medians > 200), 
         cluster_rows = FALSE, cluster_cols = FALSE)
```

### Format the SingleCellExperiment

Here, we will reformat the raw data into a `SingleCellExperiment` container that can be used with CATALYST.

```{r make-SingleCellExperiment, message=FALSE}
library(CATALYST)

cur_counts <- do.call(rbind, cur_txts) %>%
    select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) %>%
    rename_with(~ str_match(string = .x, pattern = "[A-Za-z]{2}[0-9]{2,3}Di")) %>%
    as.matrix()

sce <- SingleCellExperiment(assays = list(counts = t(cur_counts),
                                          exprs = t(asinh(cur_counts/5))))
rowData(sce) <- DataFrame(channel_name = rownames(sce),
                          marker_name = rownames(sce))
colData(sce) <- DataFrame(sample_id = rep(names(cur_txts), times = sapply(cur_txts, nrow)))
sce$sample_mass <- str_match(sce$sample_id, pattern = "[0-9]{2,3}")

sce <- assignPrelim(sce, bc_key = as.numeric(str_match(rownames(sce), pattern = "[0-9]{2,3}")))
sce <- estCutoffs(sce)
sce <- applyCutoffs(sce)
```

### Remove pixels with incorrect labels and stains with few correctly identified pixels

```{r correct-estimates}
# Remove incorrectly labelled pixels
sce$bc_id[sce$bc_id != 0 & sce$bc_id != sce$sample_mass] <- 0

# Remove small populations - not applicable in this dataset
minevent <- 40
cur_stats <- table(sce$bc_id)
nonfreq <- names(cur_stats)[cur_stats < minevent]
sce$bc_id[sce$bc_id %in% nonfreq] <- 0
```

### Compute spillover matrix

```{r compute-spillover}
sce <- computeSpillmat(sce)

plotSpillmat(sce)
```

### Save spillover matrix as csv

Next, we will write out the spillover matrix as csv.

### Save spillover matrix as image


### Sanity check that spillover matrix is correct

```{r integration-test}
correct_sm <- read.csv("data/Figure_S5/paper_version_Spillover_Matrix_1_sm.csv")
rownames(correct_sm) <- correct_sm[,1]
correct_sm <- as.matrix(correct_sm[,-1])

current_sm <- metadata(sce)$spillover_matrix
current_sm <- current_sm[rownames(correct_sm),colnames(correct_sm)]

stopifnot(all.equal(correct_sm, current_sm, tolerance = 0.01))
```