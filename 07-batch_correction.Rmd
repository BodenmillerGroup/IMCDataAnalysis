# Batch effect correction

In Section \@ref(cell-quality) we observed staining/expression differences
betweem the individual samples. This can arise due to technical (e.g.,
differences in sample processing) as well as biological (e.g. differential
expression between patients) reasons. However, the combination of these effects
hinders cell phenotyping via clustering as highlighted in Section \@ref(clustering).

To correct for differences between the samples, we can use computational
strategies developed for correcting batch effects in single-cell RNA sequencing
data. In the following sections, we will use functions of the
[batchelor](https://www.bioconductor.org/packages/release/bioc/html/batchelor.html),
[harmony](https://github.com/immunogenomics/harmony) and
[Seurat](https://satijalab.org/seurat/articles/integration_introduction.html)
packages to correct for such batch effects.

Of note: the correction approaches presented here aim at removing any differences
between samples. This will also remove biological differences between the patients.

## Read data

First, we will read in the `SpatialExperiment` object containing the single-cell
data.

```{r read-data-batch-correction, message=FALSE}
spe <- readRDS("data/spe.rds")
```

## fastMNN correction

The `batchelor` package provides the `mnnCorrect` and `fastMNN` functions to
correct for differences between samples/batches. Both functions build up on
finding mutual nearest neighbors (MNN) among the cells of different samples and
correct expression differences between the cells. The `mnnCorrect` function 
returns corrected expression counts while the `fastMNN` functions performs the 
correction on a reduced dimension space. As such, `fastMNN` returns integrated
cells in form of a low dimensional embedding.

### Perform sample correction

Here, we apply the `fastMNN` function to correct for differences between the 
patients. By setting `auto.merge = TRUE` the function estimates the best 
batch merging order by maximizing the number of MNN pairs at each merging step. 
This is more time consuming than merging sequentially as batches appear in the 
dataset (default). We again select the markers defined in Section \@ref(cell-processing)
for sample correction.

The function returns a `SingleCellExperiment` object which contains corrected
low-dimensional coordinates for each cell in the `reducedDim(out, "corrected")`
slot. This low-dimensional embedding can be further used for clustering and
non-linear dimensionality reduction. We transfer the corrected cooridnates
to the main `SpatialExperiment` object.

```{r batch-correction-fastMNN, message=FALSE, warning=FALSE}
library(batchelor)
set.seed(220228)
out <- fastMNN(spe, batch = spe$patient_id,
               auto.merge = TRUE,
               subset.row = rowData(spe)$use_channel,
               assay.type = "exprs")

# Transfer the correction results to the main spe object
reducedDim(spe, "fastMNN") <- reducedDim(out, "corrected")
```

### Quality control of correction results

The `fastMNN` function further returns outputs that can be used to assess the
quality of the batch correction. The `metadata(out)$merge.info` entry collects
diagnostics for each individual merging step. Here, the `batch.size` and
`lost.var` entries are important. The `batch.size` entry reports the relative
magnitute of the batch effect and the `lost.var` entry represents the percentage
of lost variance per mergin step. A large `batch.size` and low `lost.var`
indicate sufficient batch correction.

```{r batch-correction-fastMNN-QC, message=FALSE}
merge_info <- metadata(out)$merge.info 

DataFrame(left = merge_info$left,
          right = merge_info$right,
          batch.size = merge_info$batch.size,
          max_lost_var = rowMax(merge_info$lost.var))
```

### Visualization

The simplest option to check if the sample effects were corrected is by using
non-linear dimensionality reduction techniques and observe mixing of cells across
samples. We will recompute the UMAP embedding using the corrected
low-dimensional coordinates for each cell.

```{r dimred-batch-correction-fastMNN, message=FALSE, warning=FALSE}
library(scater)

set.seed(220228)
spe <- runUMAP(spe, dimred= "fastMNN", name = "UMAP_mnnCorrected") 
```

Next, we visualize the corrected UMAP while overlaying patient IDs.

```{r visualizing-batch-correction-fastMNN-1, message=FALSE, warning=FALSE, fig.height=4}
library(cowplot)
library(dittoSeq)
library(viridis)

# visualize patient id 
p1 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP before correction")
p2 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP_mnnCorrected", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP after correction")

plot_grid(p1, p2)
```

We now also visualize the expression of selected markers across all cells 
before and after batch correction.

```{r visualizing-batch-correction-fastMNN-2, warning=FALSE, message=FALSE}
markers <- c("Ecad", "CD45RO", "CD20", "CD3", "FOXP3", "CD206", "MPO", "SMA", "Ki67")

# Before correction
plot_list <- multi_dittoDimPlot(spe, var = markers, reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = markers, reduction.use = "UMAP_mnnCorrected", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list) 
```

We observe that immune cells across patients are merged after batch correction 
using `fastMNN`. However, the tumor cells of different patients still cluster
separately.

## harmony correction

The `harmony` algorithm performs batch correction by iteratively clustering
and correcting the positions of cells in PCA space [TODO: cite harmony]. It
requires a matrix of transformed expression counts and internally performs
PCA before kmeans clustering. We will first create the expression matrix and
call the `HarmonyMatrix` function to perform the correction. 

Similar to the `fastMNN` function, `harmony` returns the corrected
low-dimensional coordinates for each cell. These can be saved in the
`reducedDim` slot.

```{r batch-correction-harmony, message=FALSE}
library(harmony)

mat <- t(assay(spe, "exprs")[rowData(spe)$use_channel,])

harmony_emb <- HarmonyMatrix(mat, spe$patient_id, 
                             do_pca = TRUE)

reducedDim(spe, "harmony") <- harmony_emb
```

### Visualization

We will now again visualize the cells in low dimensions after UMAP embedding.

```{r dimred-batch-correction-harmony, message=FALSE}
set.seed(220228)
spe <- runUMAP(spe, dimred = "harmony", name = "UMAP_harmony") 
```

```{r visualizing-batch-correction-harmony-1, message=FALSE, warning=FALSE, fig.height=4}
# visualize patient id 
p1 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP before correction")
p2 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP_harmony", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP after correction")

plot_grid(p1, p2)
```

And we visualize selected marker expression as defined above.

```{r visualizing-batch-correction-harmony-2, warning=FALSE, message=FALSE}
# Before correction
plot_list <- multi_dittoDimPlot(spe, var = markers, reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list) 

# After correction
plot_list <- multi_dittoDimPlot(spe, var = markers, reduction.use = "UMAP_harmony", 
                   assay = "exprs", size = 0.2, list.out = TRUE) 
plot_list <- lapply(plot_list, function(x) x + scale_color_viridis())
plot_grid(plotlist = plot_list) 
```

We observe a more aggressive merging of cells from different patients compared
to the results after `fastMNN` correction. Important immune cell and epithelial
markers are expressed in proximal cells as visualized on the UMAP.

## Seurat correction

```{r, message=FALSE, eval=FALSE}
library(Seurat)
library(SeuratObject)
seurat_obj <- as.Seurat(spe, counts = "counts", data = "exprs")
seurat_obj <- AddMetaData(seurat_obj, as.data.frame(colData(spe)))

seurat.list <- SplitObject(seurat_obj, split.by = "patient_id")

anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = rownames(spe)[rowData(spe)$use_channel])

combined <- IntegrateData(anchorset = anchors)

DefaultAssay(combined) <- "integrated"

# Run the standard workflow for visualization and clustering
combined <- ScaleData(combined, verbose = FALSE)
combined <- RunPCA(combined, npcs = 30, verbose = FALSE)
```

### Visualization

```{r, message=FALSE, eval=FALSE}
library(scater)

reducedDim(spe, "seurat_integrated") <- combined@reductions$pca@cell.embeddings

set.seed(220228)
spe <- runUMAP(spe, dimred = "seurat_integrated", name = "UMAP_seurat") 
spe <- runTSNE(spe, dimred = "seurat_integrated", name = "TSNE_seurat") 
```

```{r visualizing-batch-correction-seurat, message=FALSE, eval=FALSE}
library(patchwork)
library(dittoSeq)
library(viridis)

# visualize patient id 
p1 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP before correction")
p2 <- dittoDimPlot(spe, var = "patient_id", 
                   reduction.use = "UMAP_seurat", size = 0.2) + 
    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +
    ggtitle("Patient ID on UMAP after correction")

p1 + p2
```

Visualize markers

```{r, warning=FALSE, eval=FALSE}
p1 <- dittoDimPlot(spe, var = "Ecad", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "Ecad") +
    ggtitle("E-Cadherin expression before correction")
p2 <- dittoDimPlot(spe, var = "Ecad", reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "Ecad") +
    ggtitle("E-Cadherin expression after correction")

p1 + p2

p1 <- dittoDimPlot(spe, var = "CD45RO", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45RO") +
    ggtitle("CD45RO expression before correction")
p2 <- dittoDimPlot(spe, var = "CD45RO", reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45RO") +
    ggtitle("CD45RO expression after correction")

p1 + p2

p1 <- dittoDimPlot(spe, var = "CD20", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "Ecad") +
    ggtitle("CD20 expression before correction")
p2 <- dittoDimPlot(spe, var = "CD20", reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45RO") +
    ggtitle("CD20 expression after correction")

p1 + p2

p1 <- dittoDimPlot(spe, var = "CD3", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "Ecad") +
    ggtitle("CD3 expression before correction")
p2 <- dittoDimPlot(spe, var = "CD3", reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "CD45RO") +
    ggtitle("CD3 expression after correction")

p1 + p2

p1 <- dittoDimPlot(spe, var = "FOXP3", reduction.use = "UMAP", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "FOXP3") +
    ggtitle("FOXP3 expression before correction")
p2 <- dittoDimPlot(spe, var = "FOXP3", reduction.use = "UMAP_seurat", 
                   assay = "exprs", size = 0.2) +
    scale_color_viridis(name = "FOXP3") +
    ggtitle("FOXP3 expression after correction")

p1 + p2
```

## Save objects

The modified `SpatialExperiment` object is saved for further downstream analysis.

```{r save-objects-batch-correction, eval=FALSE}
saveRDS(spe, "data/spe.rds")
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>