# Performing spatial analysis

Highly multiplexed imaging technologies acquire the spatial distributions 
of molecule abundances across a tissue section. As such, analyzing single cells
in their spatial tissue context is a key strength of these technologies.

A number of software packages such as
[squidpy](https://squidpy.readthedocs.io/en/stable/),
[giotto](https://rubd.github.io/Giotto_site/) and
[Seurat](https://satijalab.org/seurat/articles/spatial_vignette_2.html) have
been developed to analyse and visualize cells in their spatial context. The
following chapter will highlight the use of
[imcRtools](https://bioconductor.org/packages/release/bioc/html/imcRtools.html)
and other Bioconductor tools tools to visualize and analyse single-cell data
obtained from highly multiplexed imaging technologies.

We will first read in the spatially-annotated single-cell data processed in the 
previous sections.

```{r spatial-load-data, message=FALSE}
library(SpatialExperiment)
spe <- readRDS("data/spe.rds")
```

## Build interaction graphs

Many spatial analysis approaches either compare the observed versus expected
number of cells around a given cell type (point process) or utilize interaction
graphs (spatial object graphs) to estimate clustering or interaction frequencies
between cell types.

The [steinbock](https://bodenmillergroup.github.io/steinbock/latest/cli/measurement/) 
framework allows the construction of these spatial graphs. During image 
processing (see Section \@ref(image-processing)), we have constructed
a spatial graph by expanding the individual cell masks by 4 pixels. 

The `imcRtools` package further allows the *ad hoc* consctruction of spatial
graphs directly using a `SpatialExperiment` or `SingleCellExperiment` object
while considering the spatial location (centroids) of individual cells. The
[buildSpatialGraph](https://bodenmillergroup.github.io/imcRtools/reference/buildSpatialGraph.html)
function allows constructing spatial graphs by detecting the k-nearest neighbors
in 2D (`knn`), by detecting all cells within a given distance to the centre cell
(`expansion`) and by Delaunay triangulation (`delaunay`).

When constructing a knn graph, the number of neighbors (`k`) needs to be set and
the maximum distance to consider (`max_dist`) can be set. When constructing a
graph via expansion, the distance to expand (`threshold`) needs to be specified.
For graphs to be constructed via Delaunay triangulation, the `max_dist`
parameter can be set to avoid unusually large connections at the edge of the
image.

```{r build-spatial-graphs, message=FALSE}
library(imcRtools)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "knn", k = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "expansion", threshold = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "delaunay", max_dist = 50)
```

The spatial graphs are stored in `colPair(spe, name)`. These are `SelfHits`
objects representing edge lists in which the first column indicates the index of
the "from" cell and the second column the index of the "to" cell. Each
edge list is newly constructed when subsetting the object.

```{r show-colPairNames}
colPairNames(spe)
```

Here, `colPair(spe, "neighborhood")` stores the spatial graph constructed by
`steinbock`, `colPair(spe, "knn_interaction_graph")` stores the knn spatial
graph, `colPair(spe, "expansion_interaction_graph")` stores the expansion graph
and `colPair(spe, "delaunay_interaction_graph")` stores the graph constructed by
Delaunay triangulation.

## Spatial visualization

Section \@ref(image-visualization) highlights the use of the
[cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html)
package to visualize multichannel images and segmentation masks. Here, we
introduce the
[plotSpatial](https://bodenmillergroup.github.io/imcRtools/reference/plotSpatial.html)
function of the `imcRtools` package to visualize the cells' centroids and
cell-cell interactions as spatial graphs.

In the following example, we select one image for visualization purposes. 
Here, each dot (node) represents a cell and edges are drawn between cells
in close physical proximity as detected by `steinbock` or the `buildSpatialGraph`
function. Nodes are variably colored based on the cell type and edges are
colored in grey.

```{r spatial-viz-1, message=FALSE, fig.width=7, fig.height=7}
library(ggplot2)
library(viridis)

# steinbock interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("steinbock interaction graph")

# knn interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("knn interaction graph")

# expansion interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE, 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("expansion interaction graph")

# delaunay interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "delaunay_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("delaunay interaction graph")
```

Nodes can also be colored based on the cells' expression levels (e.g.,
E-cadherin expression) and their size can be adjusted (e.g., based on measured
cell area).

```{r spatial-viz-2, fig.width=7, fig.height=7}
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "Ecad", 
            assay_type = "exprs",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("E-cadherin expression")
```

Finally, the `plotSpatial` function allows displaying all images at once. This
visualization can be useful to quickly detect larger structures of interest.

```{r spatial-viz-3, fig.height=12, fig.width=12}
plotSpatial(spe, 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            node_size_fix = 0.5) + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype)
```

For a full documentation on the `plotSpatial` function, please refer to
`?plotSpatial`.

## Spatial community analysis

The detection of spatial communities was proposed by [@Jackson2020]. Here,
cells are clustered solely based on their interactions as defined by the
spatial object graph. In the following example, we perform spatial community 
detection separately for tumor and stromal cells.

The general procedure is as follows: 
* subset the object to contain either tumor or stromal cells  
* create an `igraph` object from the edge list stored in `colPair(tumor_spe, "neighborhood")`  
* perform community detection using the Louvain algorithm  
* store the community IDs in a vector and replace all communities with a size
smaller than 10 by `NA`  

Both tumor and stromal spatial communities are stored in the `colData` of
the `SpatialExperiment` object.

```{r spatial-community, message=FALSE}
library(igraph)

# Spatial community detection - tumor
tumor_spe <- spe[,spe$celltype == "Tumor"]
gr <- graph_from_edgelist(as.matrix(colPair(tumor_spe, "neighborhood")), directed = FALSE)
cl_comm <- cluster_louvain(gr)
comm_tumor <- paste0("Tumor_", membership(cl_comm))
comm_tumor[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_tumor) <- colnames(tumor_spe)

# Spatial community detection - non-tumor
stroma_spe <- spe[,spe$celltype != "Tumor"]
gr <- graph_from_edgelist(as.matrix(colPair(stroma_spe, "neighborhood")), directed = FALSE)
cl_comm <- cluster_louvain(gr)
comm_stroma <- paste0("Stroma_", membership(cl_comm))
comm_stroma[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_stroma) <- colnames(stroma_spe)

comm <- c(comm_tumor, comm_stroma)

spe$spatial_community <- comm[colnames(spe)]
```

We can now separately visualize the tumor and stromal communities.

```{r spatial-community-viz, fig.height=12, fig.width=12}
plotSpatial(spe[,spe$celltype == "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial tumor communities") +
    scale_color_manual(values = rev(colors()))

plotSpatial(spe[,spe$celltype != "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial non-tumor communities") +
    scale_color_manual(values = rev(colors()))
```

The example data was acquired using a panel that mainly focuses on immune cells.
We are therefore unable to detect many tumor sub-phenotypes and will therefore
focus on the stromal communities.

In the next step, we calculate the fraction of cell types within each spatial stromal
community. 

```{r spatial-community-heatmap, message=FALSE}
library(tidyverse)
library(pheatmap)
library(viridis)

for_plot <- colData(spe) %>% as_tibble() %>%
    filter(celltype != "Tumor") %>%
    group_by(spatial_community, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = spatial_community, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-spatial_community)

pheatmap(for_plot, color = viridis(100), show_rownames = FALSE)
```
We observe that many spatial stromal communities are made up of myeloid cells or
"stromal" (non-immune) cells. Other communities are mainly made up of B cells
and BnT cells indicating tertiray lymphoid structures. While plasma cells tend
to aggregate, only in few spatial stromal communities one can observe mainly
CD4+ or CD8+ T cells.

## Cellular neighborhood analysis

In the following section, we will highlight the use of `imcRtools` to detect
cellular neighborhoods. This approach has been proposed by [@Goltsev2018] and
[@Schurch2020] to group cells based on information of their direct neighborhood.

[@Goltsev2018] perfomed Delaunay triangulation-based graph construction, 
neighborhood aggregation and then clustered cells. [@Schurch2020] on the 
other hand constructed a 10-nearest neighbor graph before aggregating
information across neighboring cells. 

In the following code chunk we will use the 20-nearest neighbor graph
as constructed above to define the direct cellular neighborhood. The
[aggregateNeighbors](https://bodenmillergroup.github.io/imcRtools/reference/aggregateNeighbors.html)
function now performs neighborhood aggregation in 2 ways:

1. For each cell it computes the fraction of cells of a certain type (e.g., cell
type) among its neighbors.
2. For each cell it aggregates (e.g., mean) the expression counts across all
neighboring cells.

Based on these measures, cells can now be clustered into cellular neighborhoods.
We will first compute the fraction of the different cell types among the
20-nearest neighbors and use kmeans clustering to group cells into 10 cellular
neighborhoods.

```{r cn-analysis, fig.height=12, fig.width=12}
# By celltypes
spe <- aggregateNeighbors(spe, colPairName = "knn_interaction_graph", 
                          aggregate_by = "metadata", count_by = "celltype")

set.seed(220705)

cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 10)
spe$cn_celltypes <- as.factor(cn_1$cluster)

plotSpatial(spe, 
            node_color_by = "cn_celltypes", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

We will now visualize the cell type compositions of the detected cellular
neighborhoods (CN).

```{r, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(cn_celltypes, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cn_celltypes, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cn_celltypes)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

CN 10 and CN 1 are mainly composed of tumor cells with CN 10 forming the tumor/stroma border.
CN 8 is mainly composed of B and BnT cells indicating TLS. CN 9 is composed 
of aggregated plasma cells and CN 3 contains most T cells.

We will now detect cellular neighborhoods by computing the mean expression 
across the 20-nearest neighbor prior to clustering.

```{r, fig.height=12, fig.width=12}
# By expression
spe <- aggregateNeighbors(spe, colPairName = "knn_interaction_graph", 
                          aggregate_by = "expression", assay_type = "exprs",
                          subset_row = rowData(spe)$use_channel)
cn_2 <- kmeans(spe$mean_aggregatedExpression, centers = 10)
spe$cn_expression <- as.factor(cn_2$cluster)

plotSpatial(spe, 
            node_color_by = "cn_expression", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```
Also here, we can visualize the cell type composition of each cellular 
neighborhood.

```{r, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(cn_expression, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cn_expression, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cn_expression)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

When clustering cells based on the mean expression within the direct
neighborhood, tumor patches are split across CN 2, CN 3 and CN 6 without forming
a clear tumor/stroma interface. This result reflects patient-to-patient
differences in the expression of tumor markers. CN 1 again contains B cells and
BnT cells representing TLS but CN 7 and CN 9 (T cell rich neighborhoods) are
expanded compared to the previous CN detection approach. CN detection based on
mean marker expression is therefore sensitive to staining/expression differences
between samples as well as lateral spillover due to imperfect segmentation.

**Of note:** constructing a 20-nearest neighbor graph and clustering using
kmeans with `k=10` is only an example. Similar to the analysis done in Section
\@ref(snn-graph), it is recommended to perform a parameter sweep across
different graph construction algorithms and different parmaters `k` for kmeans
clustering. Finsing the best CN detection settings is also subject to the
question at hand. Constructing graphs with more neighbours usually results in
larger CNs.

An alternative to the `aggregateNeighbors` function is provided by the
[lisaClust](https://bioconductor.org/packages/release/bioc/html/lisaClust.html)
Bioconductor package [@Patrick2021]. In contrast to `imcRtools`, the `lisaClust`
package computes local indicators of spatial associations (LISA) functions and
clusters cells based on those. More precise, the package summarizes L-functions
from a Poisson point process model to derive numeric vectors for each cell which
can then again be clustered using kmeans.

The `lisa` function requires a `SegmentedCells` object which can be generated
using the
[spicyR](https://www.bioconductor.org/packages/release/bioc/html/spicyR.html)
package.

```{r lisaClust-1, message=FALSE}
library(lisaClust)
library(spicyR)

cells <- data.frame(row.names = colnames(spe))
cells$ObjectNumber <- spe$ObjectNumber
cells$ImageNumber <- spe$sample_id
cells$AreaShape_Center_X <- spatialCoords(spe)[,"Pos_X"]
cells$AreaShape_Center_Y <- spatialCoords(spe)[,"Pos_Y"]
cells$cellType <- spe$celltype

lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)

lisa_sc
```

After creating the `SegmentedCells` object, the `lisa` function computes LISA
curves across a given set of distances. In the following example, we calculate
the LISA curves within a 10µm, 20µm and 50µm neighborhood of each cell. 
Increasing these radii will lead to broader and smoother spatial clusters.
However, a number of parameters should be tested to estimate the robustness
of the results.

```{r lisaClust-2, fig.height=12, fig.width=12}
m <- lisa(lisa_sc, Rs = c(10, 20, 50))

# Set NA to 0
lisaCurves[is.na(lisaCurves)] <- 0

lisa_clusters <- kmeans(lisaCurves, centers = 10)$cluster

spe$lisa_clusters <- as.factor(lisa_clusters)

plotSpatial(spe, 
            node_color_by = "lisa_clusters", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

Similar to the example above, we can now observe the cell type composition
per spatial cluster.

```{r lisaClust-3, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(lisa_clusters, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = lisa_clusters, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-lisa_clusters)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
```

Int this case, CN 9, CN 8 and CN 4 contain tumor cells with CN 4 forming the 
tumor/stroma interface. CN 3 and CN 7 represent TLS with CN 7 being the 
TLS core and CN 3 being the margin. CN 6 indicates clustered plasma cells 
and CN 1 represents clustered myeloid cells and neutrophiles.

## Patch detection

The previous section focused on detecting cellular neighborhoods in a rather
unsupervised fashion. However, the `imcRtools` package also provides methods for
detecting spatial compartments in a supervised fashion. The
[patchDetection](https://bodenmillergroup.github.io/imcRtools/reference/patchDetection.html)
function allows the detection of connected sets of similar cells as proposed by
[@Hoch2022]. In the following example, we will use the `patchDetection` detect
function to detect tumor patches in three steps:

1. Find connected sets of tumor cells (using the `steinbock` graph).  
2. Components which contain less than 10 cells are excluded.  
3. Expand the components by 1µm to construct a concave hull around the patch and
include cells within the patch.

```{r patchDetection-1, fig.height=12, fig.width=12}
spe <- patchDetection(spe, 
                      patch_cells = spe$celltype == "Tumor",
                      img_id = "sample_id",
                      expand_by = 1,
                      min_patch_size = 10,
                      colPairName = "neighborhood")

plotSpatial(spe, 
            node_color_by = "patch_id", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    scale_color_manual(values = rev(colors()))
```

We can now calculate the fraction of T cells within each tumor patch to roughly
estimate T cell infiltration.

```{r patchDetection-2, message=FALSE}
colData(spe) %>% as_tibble() %>%
    group_by(patch_id, sample_id) %>%
    summarize(Tcell_count = sum(celltype == "CD8" | celltype == "CD4"),
              patch_size = n(),
              Tcell_freq = Tcell_count / patch_size) %>%
    ggplot() +
        geom_point(aes(log10(patch_size), Tcell_freq, color = sample_id)) +
    theme_classic()
```

We observe an increase of T cell infiltration with tumor patch size. This effect
is most likely cause by sparse but fully connected tumor cell regions which
contain many stromal cells.

## Interaction analysis

The next section focuses on statistically testing the pariwise interaction
between all cell types of the dataset. For this, the `imcRtools` package
provides the [testInteractions](https://bodenmillergroup.github.io/imcRtools/) 
function which implements the interaction testing strategy proposed by
[@Shapiro2017]. 

Per grouping level (e.g., image), the `testInteractions` function computes the 
averaged cell type/cell type interaction count and computes this count against
an empirical null distribution which is generated by permuting all cell labels.

In the following example, we use the `steinbock` generated spatial interaction
graph and estimate the interaction or avoidance between cell types in the
dataset.

```{r testInteractions-1, message=FALSE}
library(scales)
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood")

head(out)
```

The returned `DataFrame` lists the test results per grouping level (in this case
the image ID, `group_by`), "from" cell type (`from_label`) and "to" cell type
(`to_label`). The `sigval` entry indicates if a pair of cell types is
significantly interacting (`sigval = 1`), if a pair of cell types is
significantly avoiding (`sigval = -1`) or if no significant interaction or
avoidance was detected.

These results can be visualized by computing the sum of the `sigval` entries
across all images:

```{r testInteractions-2, message=FALSE}
out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
In the plot above red tiles indicate cell type pairs that were detected to 
significantly interact on a large number of images. On the other hand, blue
tiles show cell type pairs which tend to avoid each other on a large number 
of images. 

Here we can observe that tumor cells are mostly compartmentalized and are in
avoidance with other cell types. As expected, B cells interact with BnT cells; 
regulatory T cells interact with CD4+ T cells and CD8+ T cells. Most cell types
show self interactions indicating spatial clustering. 

The `imcRtools` package further implements an interaction testing strategy 
proposed by [@Schulz2018] where the hypothesis is tested if at least n cells
of a certain type are located around a target cell type. This type of testing
can be performed by selecting `method = "patch"` and specifying the number
of patch cells via the `patch_size` parameter.

```{r testInteractions-3, message=FALSE}
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood",
                        method = "patch", 
                        patch_size = 3)

out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

These results are comparable to the interaction testing presented above. The
main difference comes from the lack of symmetry. We can now for example see that
3 or more myeloid cells sit around CD4+ T cells while this interaction is not
as strong when considering CD4+ T cells sitting around myeloid cells.

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>


