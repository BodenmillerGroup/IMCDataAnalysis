# Performing spatial analysis

Highly multiplexed imaging technologies acquire the spatial distributions 
of molecule abundances across a tissue section. As such, analyzing single cells
in their spatial tissue context is a key strength of these technologies.

A number of software packages such as
[squidpy](https://squidpy.readthedocs.io/en/stable/),
[giotto](https://rubd.github.io/Giotto_site/) and
[Seurat](https://satijalab.org/seurat/articles/spatial_vignette_2.html) have
been developed to analyse and visualize cells in their spatial context. The
following chapter will highlight the use of
[imcRtools](https://bioconductor.org/packages/release/bioc/html/imcRtools.html)
and other Bioconductor tools tools to visualize and analyse single-cell data
obtained from highly multiplexed imaging technologies.

We will first read in the spatially-annotated single-cell data processed in the 
previous sections.

```{r spatial-load-data, message=FALSE}
library(SpatialExperiment)
spe <- readRDS("data/spe.rds")
```

## Build interaction graphs

Many spatial analysis approaches either compare the observed versus expected
number of cells around a given cell type (point process) or utilize interaction
graphs (spatial object graphs) to estimate clustering or interaction frequencies
between cell types.

The [steinbock](https://bodenmillergroup.github.io/steinbock/latest/cli/measurement/) 
framework allows the construction of these spatial graphs. During image 
processing (see Section \@ref(image-processing)), we have constructed
a spatial graph by expanding the individual cell masks by 4 pixels. 

The `imcRtools` package further allows the *ad hoc* consctruction of spatial
graphs directly using a `SpatialExperiment` or `SingleCellExperiment` object
while considering the spatial location (centroids) of individual cells. The
[buildSpatialGraph](https://bodenmillergroup.github.io/imcRtools/reference/buildSpatialGraph.html)
function allows constructing spatial graphs by detecting the k-nearest neighbors
in 2D (`knn`), by detecting all cells within a given distance to the centre cell
(`expansion`) and by Delaunay triangulation (`delaunay`).

When constructing a knn graph, the number of neighbors (`k`) needs to be set and
the maximum distance to consider (`max_dist`) can be set. When constructing a
graph via expansion, the distance to expand (`threshold`) needs to be specified.
For graphs to be constructed via Delaunay triangulation, the `max_dist`
parameter can be set to avoid unusually large connections at the edge of the
image.

```{r build-spatial-graphs, message=FALSE}
library(imcRtools)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "knn", k = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "expansion", threshold = 20)
spe <- buildSpatialGraph(spe, img_id = "sample_id", type = "delaunay", max_dist = 50)
```

The spatial graphs are stored in `colPair(spe, name)`. These are `SelfHits`
objects representing edge lists in which the first column indicates the index of
the "from" cell and the second column the index of the "to" cell. Each
edge list is newly constructed when subsetting the object.

```{r show-colPairNames}
colPairNames(spe)
```

Here, `colPair(spe, "neighborhood")` stores the spatial graph constructed by
`steinbock`, `colPair(spe, "knn_interaction_graph")` stores the knn spatial
graph, `colPair(spe, "expansion_interaction_graph")` stores the expansion graph
and `colPair(spe, "delaunay_interaction_graph")` stores the graph constructed by
Delaunay triangulation.

## Spatial visualization

Section \@ref(image-visualization) highlights the use of the
[cytomapper](https://www.bioconductor.org/packages/release/bioc/html/cytomapper.html)
package to visualize multichannel images and segmentation masks. Here, we
introduce the
[plotSpatial](https://bodenmillergroup.github.io/imcRtools/reference/plotSpatial.html)
function of the `imcRtools` package to visualize the cells' centroids and
cell-cell interactions as spatial graphs.

In the following example, we select one image for visualization purposes. 
Here, each dot (node) represents a cell and edges are drawn between cells
in close physical proximity as detected by `steinbock` or the `buildSpatialGraph`
function. Nodes are variably colored based on the cell type and edges are
colored in grey.

```{r spatial-viz-1, message=FALSE, fig.width=7, fig.height=7}
library(ggplot2)
library(viridis)

# steinbock interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "neighborhood", 
            nodes_first = FALSE, 
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("steinbock interaction graph")

# knn interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "knn_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("knn interaction graph")

# expansion interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE, 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("expansion interaction graph")

# delaunay interaction graph 
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "delaunay_interaction_graph", 
            nodes_first = FALSE,
            edge_color_fix = "grey") + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +
    ggtitle("delaunay interaction graph")
```

Nodes can also be colored based on the cells' expression levels (e.g.,
E-cadherin expression) and their size can be adjusted (e.g., based on measured
cell area).

```{r spatial-viz-2, fig.width=7, fig.height=7}
plotSpatial(spe[,spe$sample_id == "Patient3_001"], 
            node_color_by = "Ecad", 
            assay_type = "exprs",
            img_id = "sample_id", 
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            nodes_first = FALSE, 
            node_size_by = "area", 
            directed = FALSE,
            edge_color_fix = "grey") + 
    scale_size_continuous(range = c(0.1, 2)) +
    ggtitle("E-cadherin expression")
```

Finally, the `plotSpatial` function allows displaying all images at once. This
visualization can be useful to quickly detect larger structures of interest.

```{r spatial-viz-3, fig.height=12, fig.width=12}
plotSpatial(spe, 
            node_color_by = "celltype", 
            img_id = "sample_id", 
            node_size_fix = 0.5) + 
    scale_color_manual(values = metadata(spe)$color_vectors$celltype)
```

For a full documentation on the `plotSpatial` function, please refer to
`?plotSpatial`.

## Spatial community analysis

The detection of spatial communities was proposed by [@Jackson2020]. Here,
cells are clustered solely based on their interactions as defined by the
spatial object graph. In the following example, we perform spatial community 
detection separately for tumor and stromal cells.

The general procedure is as follows: 
* subset the object to contain either tumor or stromal cells  
* create an `igraph` object from the edge list stored in `colPair(tumor_spe, "neighborhood")`  
* perform community detection using the Louvain algorithm  
* store the community IDs in a vector and replace all communities with a size
smaller than 10 by `NA`  

Both tumor and stromal spatial communities are stored in the `colData` of
the `SpatialExperiment` object.

```{r spatial-community, message=FALSE}
library(igraph)

# Spatial community detection - tumor
tumor_spe <- spe[,spe$celltype == "Tumor"]
gr <- graph_from_edgelist(as.matrix(colPair(tumor_spe, "neighborhood")), directed = FALSE)
cl_comm <- cluster_louvain(gr)
comm_tumor <- paste0("Tumor_", membership(cl_comm))
comm_tumor[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_tumor) <- colnames(tumor_spe)

# Spatial community detection - non-tumor
stroma_spe <- spe[,spe$celltype != "Tumor"]
gr <- graph_from_edgelist(as.matrix(colPair(stroma_spe, "neighborhood")), directed = FALSE)
cl_comm <- cluster_louvain(gr)
comm_stroma <- paste0("Stroma_", membership(cl_comm))
comm_stroma[membership(cl_comm) %in% which(sizes(cl_comm) < 10)] <- NA
names(comm_stroma) <- colnames(stroma_spe)

comm <- c(comm_tumor, comm_stroma)

spe$spatial_community <- comm[colnames(spe)]
```

We can now separately visualize the tumor and stromal communities.

```{r spatial-community-viz, fig.height=12, fig.width=12}
plotSpatial(spe[,spe$celltype == "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial tumor communities")

plotSpatial(spe[,spe$celltype != "Tumor"], 
            node_color_by = "spatial_community", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none") +
    ggtitle("Spatial non-tumor communities")
```

The example data was acquired using a panel that mainly focuses on immune cells.
We are therefore unable to detect many tumor sub-phenotypes and will therefore
focus on the stromal communities.

In the next step, we calculate the fraction of cell types within each spatial stromal
community. 

```{r spatial-community-heatmap, message=FALSE}
library(tidyverse)
library(pheatmap)
library(viridis)

for_plot <- colData(spe) %>% as_tibble() %>%
    filter(celltype != "Tumor") %>%
    group_by(spatial_community, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = spatial_community, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-spatial_community)

pheatmap(for_plot, color = viridis(100), show_rownames = FALSE)
```
We observe that many spatial stromal communities are made up of myeloid cells or
"stromal" (non-immune) cells. Other communities are mainly made up of B cells
and BnT cells indicating tertiray lymphoid structures. While plasma cells tend
to aggregate, only in few spatial stromal communities one can observe mainly
CD4+ or CD8+ T cells.

## Cellular neighborhood analysis

```{r cn-analysis, fig.height=12, fig.width=12}
# By celltypes
spe <- aggregateNeighbors(spe, colPairName = "knn_interaction_graph", 
                          aggregate_by = "metadata", count_by = "celltype")
cn_1 <- kmeans(spe$aggregatedNeighbors, centers = 10)
spe$cn_celltypes <- as.factor(cn_1$cluster)

plotSpatial(spe, 
            node_color_by = "cn_celltypes", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

```{r, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(cn_celltypes, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cn_celltypes, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cn_celltypes)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         show_rownames = FALSE, scale = "column")
```

```{r, fig.height=12, fig.width=12}
# By expression
spe <- aggregateNeighbors(spe, colPairName = "knn_interaction_graph", 
                          aggregate_by = "expression", assay_type = "exprs",
                          subset_row = rowData(spe)$use_channel)
cn_2 <- kmeans(spe$mean_aggregatedExpression, centers = 10)
spe$cn_expression <- as.factor(cn_2$cluster)

plotSpatial(spe, 
            node_color_by = "cn_expression", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

```{r, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(cn_expression, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = cn_expression, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-cn_expression)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         show_rownames = FALSE, scale = "column")
```

Via lisaClust

```{r lisaClust, message=FALSE, fig.height=12, fig.width=12}
library(lisaClust)
library(spicyR)

cells <- data.frame(row.names = colnames(spe))
cells$ObjectNumber <- spe$ObjectNumber
cells$ImageNumber <- spe$sample_id
cells$AreaShape_Center_X <- spatialCoords(spe)[,"Pos_X"]
cells$AreaShape_Center_Y <- spatialCoords(spe)[,"Pos_Y"]
cells$cellType <- spe$celltype

lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)

lisaCurves <- lisa(lisa_sc, Rs = c(10,20,50))
lisaCurves[is.na(lisaCurves)] <- 0

lisa_clusters <- kmeans(lisaCurves, centers = 10)$cluster

spe$lisa_clusters <- as.factor(lisa_clusters)

plotSpatial(spe, 
            node_color_by = "lisa_clusters", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    scale_color_brewer(palette = "Set3")
```

```{r, message=FALSE}
for_plot <- colData(spe) %>% as_tibble() %>%
    group_by(lisa_clusters, celltype) %>%
    summarize(count = n()) %>%
    mutate(freq = count / sum(count)) %>%
    pivot_wider(id_cols = lisa_clusters, names_from = celltype, 
                values_from = freq, values_fill = 0) %>%
    ungroup() %>%
    select(-lisa_clusters)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         show_rownames = FALSE, scale = "column")
```

## Patch detection

```{r, fig.height=12, fig.width=12}
spe <- patchDetection(spe, 
                      patch_cells = spe$celltype == "Tumor",
                      img_id = "sample_id",
                      expand_by = 1,
                      min_patch_size = 10,
                      colPairName = "neighborhood")

plotSpatial(spe, 
            node_color_by = "patch_id", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
    theme(legend.position = "none")
```

T cell frequency per tumor patch

```{r, message=FALSE}
colData(spe) %>% as_tibble() %>%
    group_by(patch_id, sample_id) %>%
    summarize(Tcell_count = sum(celltype == "CD8" | celltype == "CD4"),
              patch_size = n(),
              Tcell_freq = Tcell_count / patch_size) %>%
    ggplot() +
        geom_point(aes(log10(patch_size), Tcell_freq, color = sample_id)) +
    theme_classic()
```

## Interaction analysis

```{r, message=FALSE}
library(scales)
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood")

head(out)

out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
out <- testInteractions(spe, 
                        group_by = "sample_id",
                        label = "celltype", 
                        colPairName = "neighborhood",
                        method = "patch", 
                        patch_size = 3)

out %>% as_tibble() %>%
    group_by(from_label, to_label) %>%
    summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %>%
    ggplot() +
        geom_tile(aes(from_label, to_label, fill = sum_sigval)) +
        scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Session Info

<details>
   <summary>SessionInfo</summary>
   
```{r, echo = FALSE}
sessionInfo()
```
</details>


