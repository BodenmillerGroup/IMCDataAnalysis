# Generate a spillover matrix

This section highlights how to generate a spillover matrix from individually
acquired single metal spots on an agarose slide. Each spot needs to be imaged as
its own acquisition/ROI and individual .txt files containing the pixel
intensities per spot need to be available. For complete details on the spillover
correction approach, please refer to [the original
publication](https://www.cell.com/cell-systems/fulltext/S2405-4712(18)30063-2)[@Chevrier2017].

The original code is available on Github
[here](https://github.com/BodenmillerGroup/cyTOFcompensation), however, due to
changes in the
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
package, the analysis was not reproducible using the newest version. The
following workflow uses the newest package versions to generate a spillover
matrix.

In brief, the highlighted workflow comprises 5 steps:

1. Reading in the data
2. Quality control 
3. (Optional) pixel binning
4. "Debarcoding" for pixel assignment
5. Pixel selection for spillover matrix estimation
6. Spillover matrix generation
7. Saving the results

## Read in the data

Here, we will read in the individual .txt files into a named list. The
`imcRtools` package exports the `prepareSCEfromTXT` function, which creates a
`SingleCellExperiment` object form the data contained in the .txt files. This
object can be used directly by the `CATALYST` package to estimate the spillover.

One crucial step is to name the list of .txt files correctly. The
`prepareSCEfromTXT` function expects a names list, where each name represents
the metal spot in the format `(mt)(mass)` (e.g. `Sm152` for Samarium isotope
with the atomic mass 152).

```{r read-txts, message=FALSE}
library(imcRtools)
library(readr)
library(stringr)

# Read txt files
cur_txts_names <- list.files("data/Figure_S5/Spillover_Matrix_1/", full.names = TRUE)
cur_txts <- lapply(cur_txts_names, read_delim, delim = "\t")

names(cur_txts) <- str_extract(cur_txts_names, "[A-Za-z]{1,2}[0-9]{2,3}")

# Create SingleCellExperiment
sce <- prepareSCEfromTXT(cur_txts) 
```

## Quality control

In the next step, we will observe the median pixel intensities per spot.
This is crucial as low intensities 

```{r QC, message = FALSE}
library(pheatmap)
library(viridis)
library(matrixStats)

cur_medians <- lapply(cur_txts, function(x){
    cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) 
    cur_m <- colMedians(as.matrix(cur_txt))
    names(cur_m) <- colnames(cur_txt)
    return(cur_m)
})

cur_medians <- do.call(rbind, cur_medians)

# Order matrix by metal
cur_medians <- cur_medians[order(as.numeric(str_extract(rownames(cur_medians), "[0-9]{2,3}"))),
                           order(as.numeric(str_extract(colnames(cur_medians), "[0-9]{2,3}")))]

pheatmap(log10(cur_medians + 1), cluster_rows = FALSE, cluster_cols = FALSE,
         color = viridis(100))

# Visualize a threshold - multiplication with 1 to change logical to numeric
pheatmap(1 * (cur_medians > 200), 
         cluster_rows = FALSE, cluster_cols = FALSE)
```

## Optional binning

If the signals are too low, pixels can be summed:

```{r binning, message=FALSE,}
library(zoo)

bin_size = 10

cur_txts_binned <- lapply(cur_txts, function(x){
        cur_txt <- x %>% select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) %>%
            as.matrix()
        cur_txt <- apply(cur_txt, 2, function(y){rollapply(y, width = bin_size, FUN = sum, by = bin_size)})
        return(cur_txt)
})

cur_medians <- lapply(cur_txts_binned, function(x){
    cur_m <- colMedians(as.matrix(x))
    names(cur_m) <- colnames(x)
    return(cur_m)
})

cur_medians <- do.call(rbind, cur_medians)

# Order matrix by metal
cur_medians <- cur_medians[order(as.numeric(str_extract(rownames(cur_medians), "[0-9]{2,3}"))),
                           order(as.numeric(str_extract(colnames(cur_medians), "[0-9]{2,3}")))]

pheatmap(log10(cur_medians + 1), cluster_rows = FALSE, cluster_cols = FALSE,
         color = viridis(100))

# Visualize a threshold - multiplication with 1 to change logical to numeric
pheatmap(1 * (cur_medians > 200), 
         cluster_rows = FALSE, cluster_cols = FALSE)
```

## Format the SingleCellExperiment

Here, we will reformat the raw data into a `SingleCellExperiment` container that can be used with CATALYST.

```{r make-SingleCellExperiment, message=FALSE}
library(CATALYST)

cur_counts <- do.call(rbind, cur_txts) %>%
    select(-c(Start_push, End_push, Pushes_duration, X, Y, Z)) %>%
    rename_with(~ str_match(string = .x, pattern = "[A-Za-z]{1,2}[0-9]{2,3}Di")) %>%
    as.matrix()

sce <- SingleCellExperiment(assays = list(counts = t(cur_counts),
                                          exprs = t(asinh(cur_counts/5))))
rowData(sce) <- DataFrame(channel_name = rownames(sce),
                          marker_name = rownames(sce))
colData(sce) <- DataFrame(sample_id = rep(names(cur_txts), times = sapply(cur_txts, nrow)))
sce$sample_mass <- str_match(sce$sample_id, pattern = "[0-9]{2,3}")

sce <- assignPrelim(sce, bc_key = as.numeric(str_match(rownames(sce), pattern = "[0-9]{2,3}")))
sce <- estCutoffs(sce)
sce <- applyCutoffs(sce)
```

## Remove pixels with incorrect labels and stains with few correctly identified pixels

```{r correct-estimates}
# Remove incorrectly labelled pixels
sce$bc_id[sce$bc_id != 0 & sce$bc_id != sce$sample_mass] <- 0

# Remove small populations - not applicable in this dataset
minevent <- 40
cur_stats <- table(sce$bc_id)
nonfreq <- names(cur_stats)[cur_stats < minevent]
sce$bc_id[sce$bc_id %in% nonfreq] <- 0
```

## Compute spillover matrix

```{r compute-spillover}
sce <- computeSpillmat(sce)

plotSpillmat(sce)
```

### Save spillover matrix as csv

Next, we will write out the spillover matrix as csv.

### Save spillover matrix as image


### Sanity check that spillover matrix is correct

```{r integration-test}
correct_sm <- read.csv("data/Figure_S5/paper_version_Spillover_Matrix_1_sm.csv")
rownames(correct_sm) <- correct_sm[,1]
correct_sm <- as.matrix(correct_sm[,-1])

current_sm <- metadata(sce)$spillover_matrix
current_sm <- current_sm[rownames(correct_sm),colnames(correct_sm)]

stopifnot(all.equal(correct_sm, current_sm, tolerance = 0.01))
```

```{r sessionInfo}
sessionInfo()
```