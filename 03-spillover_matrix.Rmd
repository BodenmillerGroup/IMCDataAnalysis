# Spillover correction

This section highlights how to generate a spillover matrix from individually
acquired single metal spots on an agarose slide. Each spot needs to be imaged as
its own acquisition/ROI and individual .txt files containing the pixel
intensities per spot need to be available. For complete details on the spillover
correction approach, please refer to [the original
publication](https://www.cell.com/cell-systems/fulltext/S2405-4712(18)30063-2) [@Chevrier2017].

The original code is available on Github
[here](https://github.com/BodenmillerGroup/cyTOFcompensation), however, due to
changes in the
[CATALYST](https://bioconductor.org/packages/release/bioc/html/CATALYST.html)
package, the analysis was not reproducible using the newest version. The
following workflow uses the newest package versions to generate a spillover
matrix.

In brief, the highlighted workflow comprises 5 steps:

1. Reading in the data
2. Quality control 
3. (Optional) pixel binning
4. "Debarcoding" for pixel assignment
5. Pixel selection for spillover matrix estimation
6. Spillover matrix generation
7. Saving the results

## Read in the data

Here, we will read in the individual .txt files into a named list. The
`imcRtools` package exports the `prepareSCEfromTXT` function, which creates a
`SingleCellExperiment` object form the data contained in the .txt files. This
object can be used directly by the `CATALYST` package to estimate the spillover.

One crucial step is to name the list of .txt files correctly. The
`prepareSCEfromTXT` function expects a names list, where each name represents
the metal spot in the format `(mt)(mass)` (e.g. `Sm152` for Samarium isotope
with the atomic mass 152).

For further downstream analysis, we will asinh-transform the data using a
cofactor of 5; a common transformation for CyTOF data [@Bendall2011].

```{r read-txts, message=FALSE}
library(imcRtools)
library(readr)
library(stringr)

# Read txt files
cur_txts_names <- list.files("data/Figure_S5/Spillover_Matrix_1/", full.names = TRUE)
cur_txts <- lapply(cur_txts_names, read_delim, delim = "\t")

names(cur_txts) <- str_extract(cur_txts_names, "[A-Za-z]{1,2}[0-9]{2,3}")

# Create SingleCellExperiment
sce <- prepareSCEfromTXT(cur_txts) 
assay(sce, "exprs") <- asinh(counts(sce)/5)
```

## Quality control

In the next step, we will observe the median pixel intensities per spot.
This type of visualization serves two purposes:

1. Small median pixel intensities (< 200 counts) might hinder the robust
estimation of the channel spillover. In that case, consecutive pixels can be
summed (see [Optional pixel binning](#pixel_binning)).

2. Each spotted metal (column) should show the highest median pixel intensity in its
corresponding channel (row). If this is not the case, either the naming of the
.txt files was incorrect or the incorrect metal was spotted.

```{r QC-heatmap, message = FALSE, fig.width=7, fig.height=7}
# Log10 median pixel counts per spot and channel
plotSpotHeatmap(sce)

# Thresholded on 200 pixel counts
plotSpotHeatmap(sce, log = FALSE, threshold = 200)
```

As we can see, all median pixel intensities are > 200 counts for each spot.
Channels for which no spot was placed (Xe134, Eu153, Ir191, Ir193), show either
no spillover (Ir191, Ir193), constant signal (Xe134) or spillover from
neighboring channels (Eu153).

## Optional pixel binning {#pixel_binning}

In cases where median pixel intensities are low (< 200 counts), consecutive
pixels can be binned to increase the robustness of the spillover estimation.
The `imcRtools` package provides the `binAcrossPixels` function,
which performs aggregation for each channel across `bin_size` consecutive pixels 
per spotted metal.

```{r binning, message=FALSE, fig.width=7, fig.height=7}
# Define grouping
bin_size = 10

sce2 <- binAcrossPixels(sce, bin_size = bin_size)

# Log10 median pixel counts per spot and channel
plotSpotHeatmap(sce2)

# Thresholded on 200 pixel counts
plotSpotHeatmap(sce2, log = FALSE, threshold = 200)
```

Here, we can see an increase in the median pixel intensities and accumulation of
off-diagonal signal. Due to already high original pixel intensities, we will
refrain from aggregating across consecutive pixels for this demonstration.

## Filtering incorrectly assigned pixels

The following step uses functions provided by the `CATALYST` package to
"debarcode" the pixels. Based on the intensity distribution of all channel,
pixels are assigned to their corresponding barcode; here this is the already
known metal spot. This procedure serves the purpose to identify pixels that
cannot be robustly assigned to the spotted metal. Pixels of such kind can be
regarded as "noisy", "background" or "artefacts" that should be removed prior to
spillover estimation.

We will also need to specify which channels were spotted (argument `bc_key`).
This information is directly contained in the `colData(sce)` slot.

The general workflow for pixel debarcoding is as follows:

1. assign preliminary metal mass to each pixel
2. for each pixel, estimate a cutoff parameter for the distance between 
positive and negative pixel sets
3. apply the estimated cutoffs to identify truly positive pixels

```{r debarcoding, message=TRUE}
library(CATALYST)

bc_key <- as.numeric(unique(sce$sample_mass))

sce <- assignPrelim(sce, bc_key = bc_key)
sce <- estCutoffs(sce)
sce <- applyCutoffs(sce)
```

The obtained `SingleCellExperiment` now contains the additional `bc_id` entry.
For each pixel, this numeric vector indicates the assigned mass (e.g. `161`) or
`0`, meaning unassigned. 

This information can be visualized in form of a heatmap:

```{r assignment-heatmap, fig.width=7, fig.height=7}
library(pheatmap)
cur_table <- table(sce$bc_id, sce$sample_mass)

pheatmap(log10(cur_table + 1),
         cluster_rows = FALSE,
         cluster_cols = FALSE)
```

We can see here, that all pixels were assigned to the right mass and that all
pixel sets are made up if > 1000 pixels.

However, in cases where incorrect assignment occurred or where few pixels were
measured for some spots, the `imcRtools` package exports a simple helper
function to exclude pixels based on these criteria:

```{r pixel-filtering}
sce <- filterPixels(sce)
```

## Compute spillover matrix

Based on the single-positive pixels, we use the `CATALYST::computeSpillmat()`
function to computes the spillover matrix and `CATALYST::plotSpillmat()` to
visualize it:

```{r compute-spillover, fig.width=7, fig.height=7}
sce <- computeSpillmat(sce)

plotSpillmat(sce, isotope_list = isotope_list2)
```

As we can see, the largest spillover appears in `In113 --> In115` and we also
observe the `+16` oxide impurities for e.g. `Nd148 --> Dy164`.

Please follow the [CATALYST vignette](https://bioconductor.org/packages/release/bioc/vignettes/CATALYST/inst/doc/preprocessing.html#compensation)
to learn how to apply this spillover matrix for single-cell based spillover
compensation. Here, we will save the spillover matrix as .csv and as image for
use in the [IMC segmentation
pipeline](https://github.com/BodenmillerGroup/ImcSegmentationPipeline) as part
of the `CorrectSpilloverApply` and `CorrectSpilloverMeasurements` module
[here](https://github.com/BodenmillerGroup/ImcPluginsCP).

### Save spillover matrix as csv

Next, we will write out the spillover matrix as csv.

### Save spillover matrix as image

TODO

```{r integration-test, include = FALSE}
library(testthat)
correct_sm <- read.csv("data/Figure_S5/paper_version_Spillover_Matrix_1_sm.csv")
rownames(correct_sm) <- correct_sm[,1]
correct_sm <- as.matrix(correct_sm[,-1])

current_sm <- metadata(sce)$spillover_matrix

expect_equal(correct_sm, current_sm, tolerance = 0.001)
```

<details>
   <summary>SessionInfo</summary>
   
```{r sessionInfo-1, echo = FALSE}
sessionInfo()
```
</details>

