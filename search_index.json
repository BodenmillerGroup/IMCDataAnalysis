[["index.html", "Analysis workflow for IMC data 1 IMC Data Analysis Workflow 1.1 Disclaimer 1.2 Update freeze 1.3 Feedback and contributing 1.4 Maintainer 1.5 Contributors 1.6 Citation 1.7 Changelog", " Analysis workflow for IMC data Authors: Nils Eling 1,2,*, Vito Zanotelli 1,2, Michelle Daniel 1,2, Daniel Schulz 1,2, Jonas Windhager 1,2, Lasse Meyer 1,2 Compiled: 2024-01-05 1 IMC Data Analysis Workflow This workflow highlights the use of common R/Bioconductor packages to analyze single-cell data obtained from segmented multi-channel images. We will not perform multi-channel image processing and segmentation in R but rather link to available approaches in Section 3. While we use imaging mass cytometry (IMC) data as an example, the concepts presented here can be applied to images obtained by other highly-multiplexed imaging technologies (e.g. CODEX, MIBI, mIF, etc.). We will give an introduction to IMC in Section 2 and highlight strategies to extract single-cell data from multi-channel images in Section 3. Reproducible code written in R is available from Section 4 onwards and the workflow can be largely divided into the following parts: Preprocessing (reading in the data, spillover correction) Image- and cell-level quality control, low-dimensional visualization Sample/batch effect correction Cell phenotyping via clustering or classification Single-cell and image visualization Spatial analyses 1.1 Disclaimer Multi-channel image and spatial, single-cell analysis is complex and we highlight an example workflow here. However, this workflow is not complete and does not cover all possible aspects of exploratory data analysis. Instead, we demonstrate this workflow as a solid basis that supports other aspects of data analysis. It offers interoperability with other packages for single-cell and spatial analysis and the user will need to become familiar with the general framework to efficiently analyse data obtained from multiplexed imaging technologies. 1.2 Update freeze This workflow has been actively developed until December 2023. At that time we used the most recent (v.0.16.0) version of steinbock to process the example data. If you are having issues when using newer versions of steinbock please open an issue here. 1.3 Feedback and contributing We provide the workflow as an open-source resource. It does not mean that this workflow is tested on all possible datasets or biological questions and there exist multiple ways of analysing data. It is therefore recommended to check the results and question their biological interpretation. If you notice an issue or missing information, please report an issue here. We also welcome contributions in form of pull requests or feature requests in form of issues. Have a look at the source code at: https://github.com/BodenmillerGroup/IMCDataAnalysis 1.4 Maintainer Daniel Schulz 1.5 Contributors Nils Eling Vito Zanotelli Daniel Schulz Jonas Windhager Michelle Daniel Lasse Meyer 1.6 Citation The workflow has been published in https://www.nature.com/articles/s41596-023-00881-0 which you can cite as follows: Windhager, J., Zanotelli, V.R.T., Schulz, D. et al. An end-to-end workflow for multiplexed image processing and analysis. Nat Protoc (2023). 1.7 Changelog Version 1.0.0 [2023-06-30] First stable release of the workflow Version 1.0.1 [2023-10-19] Added seed before predict call after training a classifier Version 1.0.2 [2023-11-27] Added developers documentation Added more ways to visualize cell type composition per CN Version 1.0.3 [2024-01-05] Updated cytoviewer citation and corresponding text * nils.eling@uzh.ch 1: Department for Quantitative Biomedicine, University of Zurich 2: Institute for Molecular Health Sciences, ETH Zurich "],["intro.html", "2 Introduction 2.1 Technical details of IMC 2.2 IMC data format", " 2 Introduction Highly multiplexed imaging (HMI) enables the simultaneous detection of dozens of biological molecules (e.g., proteins, transcripts; also referred to as “markers”) in tissues. Recently established multiplexed tissue imaging technologies rely on cyclic staining with fluorescently-tagged antibodies (Lin et al. 2018; Gut, Herrmann, and Pelkmans 2018), or the use of oligonucleotide-tagged (Goltsev et al. 2018; Saka et al. 2019) or metal-tagged (Giesen et al. 2014; Angelo et al. 2014) antibodies, among others. The key strength of these technologies is that they allow in-depth analysis of single cells within their spatial tissue context. As a result, these methods have enabled analysis of the spatial architecture of the tumor microenvironment (Lin et al. 2018; Jackson et al. 2020; Ali et al. 2020; Schürch et al. 2020), determination of nucleic acid and protein abundances for assessment of spatial co-localization of cell types and chemokines (Hoch et al. 2022) and spatial niches of virus infected cells (Jiang et al. 2022), and characterization of pathological features during COVID-19 infection (Rendeiro et al. 2021; Mitamura et al. 2021), Type 1 diabetes progression (Damond et al. 2019) and autoimmune disease (Ferrian et al. 2021). Imaging mass cytometry (IMC) utilizes metal-tagged antibodies to detect over 40 proteins and other metal-tagged molecules in biological samples. IMC can be used to perform highly multiplexed imaging and is particularly suited to profiling selected areas of tissues across many samples. Overview of imaging mass cytometry data acquisition. Taken from (Giesen et al. 2014) IMC has first been published in 2014 (Giesen et al. 2014) and has been commercialized by Standard BioToolsTM to be distributed as the Hyperion Imaging SystemTM (documentation is available here). Similar to other HMI technologies such as MIBI (Angelo et al. 2014), CyCIF (Lin et al. 2018), 4i (Gut, Herrmann, and Pelkmans 2018), CODEX (Goltsev et al. 2018) and SABER (Saka et al. 2019), IMC captures the spatial expression of multiple proteins in parallel. With a nominal 1 μm resolution, IMC is able to detect cytoplasmic and nuclear localization of proteins. The current ablation frequency of IMC is 200Hz, meaning that a 1 mm\\(^2\\) area can be imaged within about 2 hours. 2.1 Technical details of IMC Technical aspects of how data acquisition works can be found in the original publication (Giesen et al. 2014). Briefly, antibodies to detect targets in biological material are labeled with heavy metals (e.g., lanthanides) that do not occur in biological systems and thus can be used upon binding to their target as a readout similar to fluorophores in fluorescence microscopy. Thin sections of the biological sample on a glass slide are stained with an antibody cocktail. Stained microscopy slides are mounted on a precise motor-driven stage inside the ablation chamber of the IMC instrument. A high-energy UV laser is focused on the tissue, and each individual laser shot ablates tissue from an area of roughly 1 μm\\(^2\\). The energy of the laser is absorbed by the tissue resulting in vaporization followed by condensation of the ablated material. The ablated material from each laser shot is transported in the gas phase into the plasma of the mass cytometer, where first atomization of the particles and then ionization of the atoms occurs. The ion cloud is then transferred into a vacuum, and all ions below a mass of 80 m/z are filtered using a quadrupole mass filter. The remaining ions (mostly those used to tag antibodies) are analyzed in a time-of-flight mass spectrometer to ultimately obtain an accumulated mass spectrum from all ions that correspond to a single laser shot. One can regard this spectrum as the information underlying a 1 μm\\(^2\\) pixel. With repetitive laser shots (e.g., at 200 Hz) and a simultaneous lateral sample movement, a tissue can be ablated pixel by pixel. Ultimately an image is reconstructed from each pixel mass spectrum. In principle, IMC can be applied to the same type of samples as conventional fluorescence microscopy. The largest distinction from fluorescence microscopy is that for IMC, primary-labeled antibodies are commonly used, whereas in fluorescence microscopy secondary antibodies carrying fluorophores are widely applied. Additionally, for IMC, samples are dried before acquisition and can be stored for years. Formalin-fixed and paraffin-embedded (FFPE) samples are widely used for IMC. The FFPE blocks are cut to 2-5 μm thick sections and are stained, dried, and analyzed with IMC. 2.1.1 Metal-conjugated antobodies and staining Metal-labeled antibodies are used to stain molecules in tissues enabling to delineate tissue structures, cells, and subcellular structures. Metal-conjugated antibodies can either be purchased directly from Standard BioToolsTM (MaxPar IMC Antibodies), or antibodies can be purchased and labeled individually (MaxPar Antibody Labeling). Antibody labeling using the MaxPar kits is performed via TCEP antibody reduction followed by crosslinking with sulfhydryl-reactive maleimide-bearing metal polymers. For each antibody it is essential to validate its functionality, specificity and optimize its usage to provide optimal signal to noise. To facilitate antibody handling, a database is highly useful. Airlab is such a platform; it allows antibody lot tracking, validation data uploads, and panel generation for subsequent upload to the IMC acquisition software from Standard BioToolsTM Depending on the sample type, different staining protocols can be used. Generally, once antibodies of choice have been conjugated to a metal tag, titration experiments are performed to identify the optimal staining concentration. For FFPE samples, different staining protocols have been described, and different antibodies show variable staining with different protocols. Protocols such as the one provided by Standard BioToolsTM or the one describe by (Ijsselsteijn et al. 2019) are recommended. Briefly, for FFPE tissues, a dewaxing step is performed to remove the paraffin used to embed the material, followed by a graded re-hydration of the samples. Thereafter, heat-induced epitope retrieval (HIER), a step aiming at the reversal of formalin-based fixation, is used to unmask epitopes within tissues and make them accessible to antibodies. Epitope unmasking is generally performed in either basic, EDTA-based buffers (pH 9.2) or acidic, citrate-based buffers (pH 6). Next, a buffer containing bovine serum albumin (BSA) is used to block non-specific binding. This buffer is also used to dilute antibody stocks for the actual antibody staining. Staining time and temperature may vary and optimization must be performed to ensure that each single antibody performs well. However, overnight staining at 4°C or 3-5 hours at room temperature seem to be suitable in many cases. Following antibody incubation, unbound antibodies are washed away and a counterstain comparable to DAPI is applied to enable the identification of nuclei. The Iridium intercalator from Standard BioToolsTM is a reagent of choice and applied in a brief 5 minute staining. Finally, the samples are washed again and then dried under an airflow. Once dried, the samples are ready for analysis using IMC and are usually stable for a long period of time (at least one year). 2.1.2 Data acquisition Data is acquired using the CyTOF software from Standard BioToolsTM (see manuals here). The regions of interest are selected by providing coordinates for ablation. To determine the region to be imaged, so called “panoramas” can be generated. These are stitched images of single fields of views of about 200 μm in diameter. Panoramas provide an optical overview of the tissue with a resolution similar to 10x in microscopy and are intended to help with the selection of regions of interest for ablation. The tissue should be centered on the glass side, since the imaging mass cytometer cannot access roughly 5 mm from each of the slide edges. Currently, the instruments can process one slide at a time and usually one MCD file per sample slide is generated. Many regions of interest can be defined on a single slide and acquisition parameters such as channels to acquire, acquisition speed (100 Hz or 200 Hz), ablation energy, and other parameters are user-defined. It is recommended that all isotope channels are recorded. This will result in larger raw data files but valuable information such as potential contamination of the argon gas (e.g., Xenon) or of the samples (e.g., lead, barium) is stored. To process a large number of slides or to select regions on whole-slide samples, panoramas may not provide sufficient information. If this is the case, multi-color immunofluorescence of the same slide prior to staining with metal-labeled antibodies may be performed. To allow for region selection based on immunofluorescence images and to align those images with a panorama of the same or consecutive sections of the sample, we developed napping. Acquisition time is directly proportional to the total size of ablation, and run times for samples of large area or for large sample numbers can roughly be calculated by dividing the ablation area in square micrometer by the ablation speed (e.g., 200Hz). In addition to the proprietary MCD file format, TXT files can also be generated for each region of interest. This is recommended as a back-up option in case of errors that may corrupt MCD files but not TXT files. 2.2 IMC data format Upon completion of the acquisition an MCD file of variable size is generated. A single MCD file can hold raw acquisition data for multiple regions of interest, optical images providing a slide level overview of the sample (“panoramas”), and detailed metadata about the experiment. Additionally, for each acquisition a TXT file is generated which holds the same pixel information as the matched acquisition in the MCD file. The Hyperion Imaging SystemTM produces files in the following folder structure: . +-- {XYZ}_ROI_001_1.txt +-- {XYZ}_ROI_002_2.txt +-- {XYZ}_ROI_003_3.txt +-- {XYZ}.mcd Here, {XYZ} defines the filename, ROI_001, ROI_002, ROI_003 are user-defined names (descriptions) for the selected regions of interest (ROI), and 1, 2, 3 indicate the unique acquisition identifiers. The ROI description entry can be specified in the Standard BioTools software when selecting ROIs. The MCD file contains the raw imaging data and the full metadata of all acquired ROIs, while each TXT file contains data of a single ROI without metadata. To follow a consistent naming scheme and to bundle all metadata, we recommend to zip the folder. Each ZIP file should only contain data from a single MCD file, and the name of the ZIP file should match the name of the MCD file. We refer to this data as raw data and the further processing of this data is described in Section 3. References "],["processing.html", "3 Multi-channel image processing 3.1 Image pre-processing (IMC specific) 3.2 Image segmentation 3.3 Feature extraction 3.4 Data export 3.5 Data import into R", " 3 Multi-channel image processing This book focuses on common analysis steps of spatially-resolved single-cell data after image segmentation and feature extraction. In this chapter, the sections describe the processing of multiplexed imaging data, including file type conversion, image segmentation, feature extraction and data export. To obtain more detailed information on the individual image processing approaches, please visit their repositories: steinbock: The steinbock toolkit offers tools for multi-channel image processing using the command-line or Python code (Windhager, Bodenmiller, and Eling 2021). Supported tasks include IMC data pre-processing, multi-channel image segmentation, object quantification and data export to a variety of file formats. It supports functionality similar to those of the IMC Segmentation Pipeline (see below) and further allows deep-learning enabled image segmentation. The toolkit is available as platform-independent Docker container, ensuring reproducibility and user-friendly installation. Read more in the Docs. IMC Segmentation Pipeline: The IMC segmentation pipeline offers a rather manual way of segmenting multi-channel images using a pixel classification-based approach. We continue to maintain the pipeline but recommend the use of the steinbock toolkit for multi-channel image processing. Raw IMC data pre-processing is performed using the readimc Python package to convert raw MCD files into OME-TIFF and TIFF files. After image cropping, an Ilastik pixel classifier is trained for image classification prior to image segmentation using CellProfiler. Features (i.e., mean pixel intensity) of segmented objects (i.e., cells) are quantified and exported. Read more in the Docs. 3.1 Image pre-processing (IMC specific) Image pre-processing is technology dependent. While most multiplexed imaging technologies generated TIFF or OME-TIFF files which can be directly segmented using the steinbock toolkit, IMC produces data in the proprietary data format MCD. To facilitate IMC data pre-processing, the readimc open-source Python package allows extracting the multi-modal (IMC acquisitions, panoramas), multi-region, multi-channel information contained in raw IMC images. Both the IMC Segmentation Pipeline and the steinbock toolkit use the readimc package for IMC data pre-processing. Starting from IMC raw data and a “panel” file, individual acquisitions are extracted as TIFF files and OME-TIFF files if using the IMC Segmentation Pipeline. The panel contains information of antibodies used in the experiment and the user can specify which channels to keep for downstream analysis. When using the IMC Segmentation Pipeline, random tiles are cropped from images for convenience of pixel labelling. 3.2 Image segmentation The IMC Segmentation Pipeline supports pixel classification-based image segmentation while steinbock supports pixel classification-based and deep learning-based segmentation. Pixel classification-based image segmentation is performed by training a random forest classifier using Ilastik on the randomly extracted image crops and selected image channels. Pixels are classified as nuclear, cytoplasmic, or background. Employing a customizable CellProfiler pipeline, the probabilities are then thresholded for segmenting nuclei, and nuclei are expanded into cytoplasmic regions to obtain cell masks. Deep learning-based image segmentation is performed as presented by (Greenwald et al. 2021). Briefly, steinbock first aggregates user-defined image channels to generate two-channel images representing nuclear and cytoplasmic signals. Next, the DeepCell Python package is used to run Mesmer, a deep learning-enabled segmentation algorithm pre-trained on TissueNet, to automatically obtain cell masks without any further user input. Segmentation masks are single-channel images that match the input images in size, with non-zero grayscale values indicating the IDs of segmented objects (e.g., cells). These masks are written out as TIFF files after segmentation. 3.3 Feature extraction Using the segmentation masks together with their corresponding multi-channel images, the IMC Segmentation Pipeline as well as the steinbock toolkit extract object-specific features. These include the mean pixel intensity per object and channel, morphological features (e.g., object area) and the objects’ locations. Object-specific features are written out as CSV files where rows represent individual objects and columns represent features. Furthermore, the IMC Segmentation Pipeline and the steinbock toolkit compute spatial object graphs, in which nodes correspond to objects, and nodes in spatial proximity are connected by an edge. These graphs serve as a proxy for interactions between neighboring cells. They are stored as edge list in form of one CSV file per image. Both approaches also write out image-specific metadata (e.g., width and height) as a CSV file. 3.4 Data export To further facilitate compatibility with downstream analysis, steinbock exports data to a variety of file formats such as OME-TIFF for images, FCS for single-cell data, the anndata format (Virshup et al. 2021) for data analysis in Python, and various graph file formats for network analysis using software such as CytoScape (Shannon et al. 2003). For export to OME-TIFF, steinbock uses xtiff, a Python package developed for writing multi-channel TIFF stacks. 3.5 Data import into R In Section 5, we will highlight the use of the imcRtools and cytomapper R/Bioconductor packages to read spatially-resolved, single-cell and images as generated by the IMC Segmentation Pipeline and the steinbock toolkit into the statistical programming language R. All further downstream analyses are performed in R and detailed in the following sections. References "],["prerequisites.html", "4 Prerequisites 4.1 Obtain the code 4.2 Software requirements 4.3 Image processing 4.4 Download example data 4.5 Software versions", " 4 Prerequisites The analysis presented in this book requires a basic understanding of the R programing language. An introduction to R can be found here and in the book R for Data Science. Furthermore, it is beneficial to be familiar with single-cell data analysis using the Bioconductor framework. The Orchestrating Single-Cell Analysis with Bioconductor book gives an excellent overview on data containers and basic analysis that are being used here. An overview on IMC as technology and necessary image processing steps can be found on the IMC workflow website. Before we get started on IMC data analysis, we will need to make sure that software dependencies are installed and the example data is downloaded. 4.1 Obtain the code This book provides R code to perform single-cell and spatial data analysis. You can copy the individual code chunks into your R scripts or you can obtain the full code of the book via: git clone https://github.com/BodenmillerGroup/IMCDataAnalysis.git 4.2 Software requirements The R packages needed to execute the presented workflow can either be manually installed (see section 4.2.2) or are available within a provided Docker container (see section 4.2.1). The Docker option is useful if you want to exactly reproduce the presented analysis across operating systems; however, the manual install gives you more flexibility for exploratory data analysis. 4.2.1 Using Docker For reproducibility purposes, we provide a Docker container here. After installing Docker you can first pull the container via: docker pull ghcr.io/bodenmillergroup/imcdataanalysis:latest and then run the container: docker run -v /path/to/IMCDataAnalysis:/home/rstudio/IMCDataAnalysis \\ -e PASSWORD=bioc -p 8787:8787 \\ ghcr.io/bodenmillergroup/imcdataanalysis:latest Here, the /path/to/ needs to be adjusted to where you keep the code and data of the book. Of note: it is recommended to use a date-tagged version of the container to ensure reproducibility. This can be done via: docker pull ghcr.io/bodenmillergroup/imcdataanalysis:&lt;year-month-date&gt; An RStudio server session can be accessed via a browser at localhost:8787 using Username: rstudio and Password: bioc. Navigate to IMCDataAnalysis and open the IMCDataAnalysis.Rproj file. Code in the individual files can now be executed or the whole workflow can be build by entering bookdown::render_book(). 4.2.2 Manual installation The following section describes how to manually install all needed R packages when not using the provided Docker container. To install all R packages needed for the analysis, please run: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(c(&quot;rmarkdown&quot;, &quot;bookdown&quot;, &quot;pheatmap&quot;, &quot;viridis&quot;, &quot;zoo&quot;, &quot;devtools&quot;, &quot;testthat&quot;, &quot;tiff&quot;, &quot;distill&quot;, &quot;ggrepel&quot;, &quot;patchwork&quot;, &quot;mclust&quot;, &quot;RColorBrewer&quot;, &quot;uwot&quot;, &quot;Rtsne&quot;, &quot;harmony&quot;, &quot;Seurat&quot;, &quot;SeuratObject&quot;, &quot;cowplot&quot;, &quot;kohonen&quot;, &quot;caret&quot;, &quot;randomForest&quot;, &quot;ggridges&quot;, &quot;cowplot&quot;, &quot;gridGraphics&quot;, &quot;scales&quot;, &quot;tiff&quot;, &quot;harmony&quot;, &quot;Matrix&quot;, &quot;CATALYST&quot;, &quot;scuttle&quot;, &quot;scater&quot;, &quot;dittoSeq&quot;, &quot;tidyverse&quot;, &quot;BiocStyle&quot;, &quot;batchelor&quot;, &quot;bluster&quot;, &quot;scran&quot;, &quot;lisaClust&quot;, &quot;spicyR&quot;, &quot;iSEE&quot;, &quot;imcRtools&quot;, &quot;cytomapper&quot;, &quot;imcdatasets&quot;, &quot;cytoviewer&quot;)) # Github dependencies devtools::install_github(&quot;i-cyto/Rphenograph&quot;) 4.2.3 Major package versions Throughout the analysis, we rely on different R software packages. This section lists the most commonly used packages in this workflow. Data containers: SpatialExperiment version 1.12.0 SingleCellExperiment version 1.24.0 Data analysis: CATALYST version 1.26.0 imcRtools version 1.8.0 scuttle version 1.12.0 scater version 1.30.1 batchelor version 1.18.1 bluster version 1.12.0 scran version 1.30.0 harmony version 1.2.0 Seurat version 5.0.1 lisaClust version 1.10.1 caret version 6.0.94 Data visualization: cytomapper version 1.14.0 cytoviewer version 1.2.0 dittoSeq version 1.14.0 Tidy R: tidyverse version 2.0.0 4.3 Image processing The analysis presented here fully relies on packages written in the programming language R and primarily focuses on analysis approaches downstream of image processing. The example data available at https://zenodo.org/record/7575859 were processed (file type conversion, image segmentation, feature extraction as explained in Section 3) using the steinbock toolkit. The exact command line interface calls to process the raw data are shown below: #!/usr/bin/env bash BASEDIR=$(cd -- &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd -P) cd &quot;${BASEDIR}&quot; # raw data collection mkdir raw wget https://zenodo.org/record/6449127/files/IMCWorkflow.ilp wget https://zenodo.org/record/6449127/files/analysis.zip unzip analysis.zip rm analysis.zip rm -r analysis/cpinp rm -r analysis/cpout rm -r analysis/histocat rm -r analysis/ilastik rm -r analysis/ometiff cd raw wget https://zenodo.org/record/5949116/files/panel.csv wget https://zenodo.org/record/5949116/files/Patient1.zip wget https://zenodo.org/record/5949116/files/Patient2.zip wget https://zenodo.org/record/5949116/files/Patient3.zip wget https://zenodo.org/record/5949116/files/Patient4.zip cd ${BASEDIR} # steinbock alias setup shopt -s expand_aliases alias steinbock=&quot;docker run -v ${BASEDIR}:/data -u $(id -u):$(id -g) ghcr.io/bodenmillergroup/steinbock:0.16.0&quot; # raw data preprocessing steinbock preprocess imc panel --namecol Clean_Target steinbock preprocess imc images --hpf 50 # random forest-based segmentation using Ilastik/CellProfiler steinbock classify ilastik prepare --cropsize 500 --seed 123 rm pixel_classifier.ilp &amp;&amp; mv IMCWorkflow.ilp pixel_classifier.ilp rm -r ilastik_crops &amp;&amp; mv analysis/crops ilastik_crops steinbock classify ilastik fix --no-backup steinbock classify ilastik run steinbock segment cellprofiler prepare steinbock segment cellprofiler run -o masks_ilastik # deep learning-based whole-cell segmentation using DeepCell/Mesmer steinbock segment deepcell --app mesmer --minmax -o masks_deepcell # single-cell feature extraction steinbock measure intensities --masks masks_deepcell steinbock measure regionprops --masks masks_deepcell steinbock measure neighbors --masks masks_deepcell --type expansion --dmax 4 # data export steinbock export ome steinbock export histocat --masks masks_deepcell steinbock export csv intensities regionprops -o cells.csv steinbock export csv intensities regionprops --no-concat -o cells_csv steinbock export fcs intensities regionprops -o cells.fcs steinbock export fcs intensities regionprops --no-concat -o cells_fcs steinbock export anndata --intensities intensities --data regionprops --neighbors neighbors -o cells.h5ad steinbock export anndata --intensities intensities --data regionprops --neighbors neighbors --no-concat -o cells_h5ad steinbock export graphs --data intensities # archiving zip -r img.zip img zip -r ilastik_img.zip ilastik_img zip -r ilastik_crops.zip ilastik_crops zip -r ilastik_probabilities.zip ilastik_probabilities zip -r masks_ilastik.zip masks_ilastik zip -r masks_deepcell.zip masks_deepcell zip -r intensities.zip intensities zip -r regionprops.zip regionprops zip -r neighbors.zip neighbors zip -r ome.zip ome zip -r histocat.zip histocat zip -r cells_csv.zip cells_csv zip -r cells_fcs.zip cells_fcs zip -r cells_h5ad.zip cells_h5ad zip -r graphs.zip graphs 4.4 Download example data Throughout this tutorial, we will access a number of different data types. To declutter the analysis scripts, we will already download all needed data here. To highlight the basic steps of IMC data analysis, we provide example data that were acquired as part of the Integrated iMMUnoprofiling of large adaptive CANcer patient cohorts projects (immucan.eu). The raw data of 4 patients can be accessed online at zenodo.org/record/7575859. We will only download the sample/patient metadata information here: download.file(&quot;https://zenodo.org/record/7575859/files/sample_metadata.csv&quot;, destfile = &quot;data/sample_metadata.csv&quot;) 4.4.1 Processed multiplexed imaging data The IMC raw data was either processed using the steinbock toolkit or the IMC Segmentation Pipeline. Image processing included file type conversion, cell segmentation and feature extraction. steinbock output This book uses the output of the steinbock framework when applied to process the example data. The processed data includes the single-cell mean intensity files, the single-cell morphological features and spatial locations, spatial object graphs in form of edge lists indicating cells in close proximity, hot pixel filtered multi-channel images, segmentation masks, image metadata and channel metadata. All these files will be downloaded here for later use. The commands which were used to generate this data can be found in the shell script above. # download intensities url &lt;- &quot;https://zenodo.org/record/7624451/files/intensities.zip&quot; destfile &lt;- &quot;data/steinbock/intensities.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/steinbock&quot;, overwrite=TRUE) unlink(destfile) # download regionprops url &lt;- &quot;https://zenodo.org/record/7624451/files/regionprops.zip&quot; destfile &lt;- &quot;data/steinbock/regionprops.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/steinbock&quot;, overwrite=TRUE) unlink(destfile) # download neighbors url &lt;- &quot;https://zenodo.org/record/7624451/files/neighbors.zip&quot; destfile &lt;- &quot;data/steinbock/neighbors.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/steinbock&quot;, overwrite=TRUE) unlink(destfile) # download images url &lt;- &quot;https://zenodo.org/record/7624451/files/img.zip&quot; destfile &lt;- &quot;data/steinbock/img.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/steinbock&quot;, overwrite=TRUE) unlink(destfile) # download masks url &lt;- &quot;https://zenodo.org/record/7624451/files/masks_deepcell.zip&quot; destfile &lt;- &quot;data/steinbock/masks_deepcell.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/steinbock&quot;, overwrite=TRUE) unlink(destfile) # download individual files download.file(&quot;https://zenodo.org/record/7624451/files/panel.csv&quot;, &quot;data/steinbock/panel.csv&quot;) download.file(&quot;https://zenodo.org/record/7624451/files/images.csv&quot;, &quot;data/steinbock/images.csv&quot;) download.file(&quot;https://zenodo.org/record/7624451/files/steinbock.sh&quot;, &quot;data/steinbock/steinbock.sh&quot;) IMC Segmentation Pipeline output The example data was also processed using the IMC Segmetation Pipeline (version 3). To highlight the use of the reader function for this type of output, we will need to download the cpout folder which is part of the analysis folder. The cpout folder stores all relevant output files of the pipeline. For a full description of the pipeline, please refer to the docs. # download analysis folder url &lt;- &quot;https://zenodo.org/record/7997296/files/analysis.zip&quot; destfile &lt;- &quot;data/ImcSegmentationPipeline/analysis.zip&quot; download.file(url, destfile) unzip(destfile, exdir=&quot;data/ImcSegmentationPipeline&quot;, overwrite=TRUE) unlink(destfile) unlink(&quot;data/ImcSegmentationPipeline/analysis/cpinp/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/crops/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/histocat/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/ilastik/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/ometiff/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/cpout/images/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/cpout/probabilities/&quot;, recursive=TRUE) unlink(&quot;data/ImcSegmentationPipeline/analysis/cpout/masks/&quot;, recursive=TRUE) 4.4.2 Files for spillover matrix estimation To highlight the estimation and correction of channel-spillover as described by (Chevrier et al. 2017), we can access an example spillover-acquisition from: download.file(&quot;https://zenodo.org/record/7575859/files/compensation.zip&quot;, &quot;data/compensation.zip&quot;) unzip(&quot;data/compensation.zip&quot;, exdir=&quot;data&quot;, overwrite=TRUE) unlink(&quot;data/compensation.zip&quot;) 4.4.3 Gated cells In Section 9.3, we present a cell type classification approach that relies on previously gated cells. This ground truth data is available online at zenodo.org/record/8095133 and will be downloaded here for later use: download.file(&quot;https://zenodo.org/record/8095133/files/gated_cells.zip&quot;, &quot;data/gated_cells.zip&quot;) unzip(&quot;data/gated_cells.zip&quot;, exdir=&quot;data&quot;, overwrite=TRUE) unlink(&quot;data/gated_cells.zip&quot;) 4.5 Software versions SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] cytoviewer_1.2.0 caret_6.0-94 ## [3] lattice_0.21-9 lisaClust_1.10.1 ## [5] scran_1.30.0 bluster_1.12.0 ## [7] lubridate_1.9.3 forcats_1.0.0 ## [9] stringr_1.5.1 dplyr_1.1.4 ## [11] purrr_1.0.2 readr_2.1.4 ## [13] tidyr_1.3.0 tibble_3.2.1 ## [15] tidyverse_2.0.0 dittoSeq_1.14.0 ## [17] cytomapper_1.14.0 EBImage_4.44.0 ## [19] imcRtools_1.8.0 scater_1.30.1 ## [21] ggplot2_3.4.4 scuttle_1.12.0 ## [23] SpatialExperiment_1.12.0 CATALYST_1.26.0 ## [25] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0 ## [27] Biobase_2.62.0 GenomicRanges_1.54.1 ## [29] GenomeInfoDb_1.38.5 IRanges_2.36.0 ## [31] S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [33] MatrixGenerics_1.14.0 matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] vroom_1.6.5 tiff_0.1-12 ## [3] nnet_7.3-19 goftest_1.2-3 ## [5] DT_0.31 HDF5Array_1.30.0 ## [7] TH.data_1.1-2 vctrs_0.6.5 ## [9] spatstat.random_3.2-2 digest_0.6.33 ## [11] png_0.1-8 shape_1.4.6 ## [13] proxy_0.4-27 ggrepel_0.9.4 ## [15] spicyR_1.14.2 deldir_2.0-2 ## [17] parallelly_1.36.0 magick_2.8.2 ## [19] MASS_7.3-60 reshape2_1.4.4 ## [21] httpuv_1.6.13 foreach_1.5.2 ## [23] withr_2.5.2 xfun_0.41 ## [25] ggpubr_0.6.0 ellipsis_0.3.2 ## [27] survival_3.5-7 RTriangle_1.6-0.12 ## [29] ggbeeswarm_0.7.2 RProtoBufLib_2.14.0 ## [31] drc_3.0-1 systemfonts_1.0.5 ## [33] zoo_1.8-12 GlobalOptions_0.1.2 ## [35] gtools_3.9.5 promises_1.2.1 ## [37] rstatix_0.7.2 globals_0.16.2 ## [39] rhdf5filters_1.14.1 rhdf5_2.46.1 ## [41] miniUI_0.1.1.1 archive_1.1.7 ## [43] units_0.8-5 generics_0.1.3 ## [45] concaveman_1.1.0 zlibbioc_1.48.0 ## [47] ScaledMatrix_1.10.0 ggraph_2.1.0 ## [49] polyclip_1.10-6 GenomeInfoDbData_1.2.11 ## [51] SparseArray_1.2.3 fftwtools_0.9-11 ## [53] xtable_1.8-4 doParallel_1.0.17 ## [55] evaluate_0.23 S4Arrays_1.2.0 ## [57] hms_1.1.3 bookdown_0.37 ## [59] irlba_2.3.5.1 colorspace_2.1-0 ## [61] spatstat.data_3.0-3 magrittr_2.0.3 ## [63] later_1.3.2 viridis_0.6.4 ## [65] spatstat.geom_3.2-7 future.apply_1.11.1 ## [67] XML_3.99-0.16 cowplot_1.1.2 ## [69] class_7.3-22 svgPanZoom_0.3.4 ## [71] pillar_1.9.0 nlme_3.1-163 ## [73] iterators_1.0.14 compiler_4.3.2 ## [75] beachmat_2.18.0 shinycssloaders_1.0.0 ## [77] stringi_1.8.3 gower_1.0.1 ## [79] sf_1.0-15 tensor_1.5 ## [81] minqa_1.2.6 ClassifyR_3.6.2 ## [83] plyr_1.8.9 crayon_1.5.2 ## [85] abind_1.4-5 locfit_1.5-9.8 ## [87] sp_2.1-2 graphlayouts_1.0.2 ## [89] bit_4.0.5 terra_1.7-65 ## [91] sandwich_3.1-0 codetools_0.2-19 ## [93] multcomp_1.4-25 recipes_1.0.9 ## [95] BiocSingular_1.18.0 bslib_0.6.1 ## [97] e1071_1.7-14 GetoptLong_1.0.5 ## [99] mime_0.12 MultiAssayExperiment_1.28.0 ## [101] splines_4.3.2 circlize_0.4.15 ## [103] Rcpp_1.0.11 sparseMatrixStats_1.14.0 ## [105] knitr_1.45 utf8_1.2.4 ## [107] clue_0.3-65 lme4_1.1-35.1 ## [109] listenv_0.9.0 nnls_1.5 ## [111] DelayedMatrixStats_1.24.0 ggsignif_0.6.4 ## [113] Matrix_1.6-4 scam_1.2-14 ## [115] statmod_1.5.0 tzdb_0.4.0 ## [117] svglite_2.1.3 tweenr_2.0.2 ## [119] pkgconfig_2.0.3 pheatmap_1.0.12 ## [121] tools_4.3.2 cachem_1.0.8 ## [123] viridisLite_0.4.2 DBI_1.2.0 ## [125] numDeriv_2016.8-1.1 fastmap_1.1.1 ## [127] rmarkdown_2.25 scales_1.3.0 ## [129] grid_4.3.2 shinydashboard_0.7.2 ## [131] broom_1.0.5 sass_0.4.8 ## [133] carData_3.0-5 rpart_4.1.21 ## [135] farver_2.1.1 tidygraph_1.3.0 ## [137] mgcv_1.9-0 yaml_2.3.8 ## [139] cli_3.6.2 lifecycle_1.0.4 ## [141] mvtnorm_1.2-4 lava_1.7.3 ## [143] backports_1.4.1 BiocParallel_1.36.0 ## [145] cytolib_2.14.0 timechange_0.2.0 ## [147] gtable_0.3.4 rjson_0.2.21 ## [149] ggridges_0.5.5 parallel_4.3.2 ## [151] pROC_1.18.5 limma_3.58.1 ## [153] colourpicker_1.3.0 jsonlite_1.8.8 ## [155] edgeR_4.0.3 bitops_1.0-7 ## [157] bit64_4.0.5 Rtsne_0.17 ## [159] FlowSOM_2.10.0 spatstat.utils_3.0-4 ## [161] BiocNeighbors_1.20.1 flowCore_2.14.0 ## [163] jquerylib_0.1.4 metapod_1.10.1 ## [165] dqrng_0.3.2 timeDate_4032.109 ## [167] shiny_1.8.0 ConsensusClusterPlus_1.66.0 ## [169] htmltools_0.5.7 distances_0.1.10 ## [171] glue_1.6.2 XVector_0.42.0 ## [173] RCurl_1.98-1.13 classInt_0.4-10 ## [175] jpeg_0.1-10 gridExtra_2.3 ## [177] boot_1.3-28.1 igraph_1.6.0 ## [179] R6_2.5.1 cluster_2.1.4 ## [181] Rhdf5lib_1.24.1 ipred_0.9-14 ## [183] nloptr_2.0.3 DelayedArray_0.28.0 ## [185] tidyselect_1.2.0 vipor_0.4.7 ## [187] plotrix_3.8-4 ggforce_0.4.1 ## [189] raster_3.6-26 car_3.1-2 ## [191] future_1.33.1 ModelMetrics_1.2.2.2 ## [193] rsvd_1.0.5 munsell_0.5.0 ## [195] KernSmooth_2.23-22 data.table_1.14.10 ## [197] htmlwidgets_1.6.4 ComplexHeatmap_2.18.0 ## [199] RColorBrewer_1.1-3 rlang_1.1.2 ## [201] spatstat.sparse_3.0-3 spatstat.explore_3.2-5 ## [203] lmerTest_3.1-3 colorRamps_2.3.1 ## [205] ggnewscale_0.4.9 fansi_1.0.6 ## [207] hardhat_1.3.0 beeswarm_0.4.0 ## [209] prodlim_2023.08.28 References "],["read-data.html", "5 Read in the data 5.1 Read in single-cell information 5.2 Single-cell processing 5.3 Read in images 5.4 Generate single-cell data from images 5.5 Accessing publicly available IMC datasets 5.6 Save objects 5.7 Session Info", " 5 Read in the data This section describes how to read in single-cell data and images into R after image processing and segmentation (see Section 3). To highlight examples for IMC data analysis, we provide already processed data at 10.5281/zenodo.6043599. This data has already been downloaded in Section 4.4 and can be accessed in the folder data. We use the imcRtools package to read in single-cell data extracted using the steinbock framework or the IMC Segmentation Pipeline. Both image processing approaches also generate multi-channel images and segmentation masks that can be read into R using the cytomapper package. library(imcRtools) library(cytomapper) 5.1 Read in single-cell information For single-cell data analysis in R the SingleCellExperiment (Amezquita et al. 2019) data container is commonly used within the Bioconductor framework. It allows standardized access to (i) expression data, (ii) cellular metadata (e.g., cell type), (iii) feature metadata (e.g., marker name) and (iv) experiment-wide metadata. For an in-depth introduction to the SingleCellExperiment container, please refer to the SingleCellExperiment class. The SpatialExperiment class (Righelli et al. 2022) is an extension of the SingleCellExperiment class. It was developed to store spatial data in addition to single-cell data and an extended introduction is accessible here. To read in single-cell data generated by the steinbock framework or the IMC Segmentation Pipeline, the imcRtools package provides the read_steinbock and read_cpout functions, respectively. By default, the data is read into a SpatialExperiment object; however, data can be read in as a SingleCellExperiment object by setting return_as = \"sce\". All functions presented in this book are applicable to both data containers. 5.1.1 steinbock generated data The downloaded example data (Section 4.4) processed with the steinbock framework can be read in with the read_steinbock function provided by imcRtools. For more information, please refer to ?read_steinbock. spe &lt;- read_steinbock(&quot;data/steinbock/&quot;) spe ## class: SpatialExperiment ## dim: 40 47859 ## metadata(0): ## assays(1): counts ## rownames(40): MPO HistoneH3 ... DNA1 DNA2 ## rowData names(12): channel name ... Final.Concentration...Dilution ## uL.to.add ## colnames: NULL ## colData names(8): sample_id ObjectNumber ... width_px height_px ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialCoords names(2) : Pos_X Pos_Y ## imgData names(1): sample_id By default, single-cell data is read in as SpatialExperiment object. The summarized pixel intensities per channel and cell (here mean intensity) are stored in the counts slot. Columns represent cells and rows represent channels. counts(spe)[1:5,1:5] ## [,1] [,2] [,3] [,4] [,5] ## MPO 0.5751064 0.4166667 0.4975494 0.890154 0.1818182 ## HistoneH3 3.1273082 11.3597883 2.3841440 7.712961 1.4512715 ## SMA 0.2600939 1.6720383 0.1535190 1.193948 0.2986703 ## CD16 2.0347747 2.5880536 2.2943074 15.629083 0.6084220 ## CD38 0.2530137 0.6826669 1.1902979 2.126060 0.2917793 Metadata associated to individual cells are stored in the colData slot. After initial image processing, these metadata include the numeric identifier (ObjectNumber), the area, and morphological features of each cell. In addition, sample_id stores the image name from which each cell was extracted and the width and height of the corresponding images are stored. head(colData(spe)) ## DataFrame with 6 rows and 8 columns ## sample_id ObjectNumber area axis_major_length axis_minor_length ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 Patient1_001 1 12 7.40623 1.89529 ## 2 Patient1_001 2 24 16.48004 1.96284 ## 3 Patient1_001 3 17 9.85085 1.98582 ## 4 Patient1_001 4 24 8.08290 3.91578 ## 5 Patient1_001 5 22 8.79367 3.11653 ## 6 Patient1_001 6 25 9.17436 3.46929 ## eccentricity width_px height_px ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 0.966702 600 600 ## 2 0.992882 600 600 ## 3 0.979470 600 600 ## 4 0.874818 600 600 ## 5 0.935091 600 600 ## 6 0.925744 600 600 The main difference between the SpatialExperiment and the SingleCellExperiment data container is the way spatial locations of all cells are stored. For the SingleCellExperiment container, the locations are stored in the colData slot while the SpatialExperiment container stores them in the spatialCoords slot: head(spatialCoords(spe)) ## Pos_X Pos_Y ## [1,] 468.5833 0.4166667 ## [2,] 515.8333 0.4166667 ## [3,] 587.2353 0.4705882 ## [4,] 192.2500 1.2500000 ## [5,] 231.7727 0.9090909 ## [6,] 270.1600 1.0400000 The spatial object graphs generated by steinbock (see Section 3.3 are read into a colPair slot with the name neighborhood of the SpatialExperiment (or SingleCellExperiment) object. Cell-cell interactions (cells in close spatial proximity) are represented as “edge list” (stored as SelfHits object). Here, the left side represents the column indices of the SpatialExperiment object of the “from” cells and the right side represents the column indices of the “to” cells. For visualization of the spatial object graphs, please refer to Section 12.2. colPair(spe, &quot;neighborhood&quot;) ## SelfHits object with 257116 hits and 0 metadata columns: ## from to ## &lt;integer&gt; &lt;integer&gt; ## [1] 1 27 ## [2] 1 55 ## [3] 2 10 ## [4] 2 44 ## [5] 2 81 ## ... ... ... ## [257112] 47858 47836 ## [257113] 47859 47792 ## [257114] 47859 47819 ## [257115] 47859 47828 ## [257116] 47859 47854 ## ------- ## nnode: 47859 Finally, metadata regarding the channels are stored in the rowData slot. This information is extracted from the panel.csv file. Channels have the same order as the rows in the panel.csv file for which the keep column is set to 1, and match the order of channels in the multi-channel images (see Section 5.3). For the example data, channels are ordered by isotope mass. head(rowData(spe)) ## DataFrame with 6 rows and 12 columns ## channel name keep ilastik deepcell cellpose ## &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;logical&gt; ## MPO Y89 MPO 1 NA NA NA ## HistoneH3 In113 HistoneH3 1 1 1 NA ## SMA In115 SMA 1 NA NA NA ## CD16 Pr141 CD16 1 NA NA NA ## CD38 Nd142 CD38 1 NA NA NA ## HLADR Nd143 HLADR 1 NA NA NA ## Tube.Number Target Antibody.Clone Stock.Concentration ## &lt;numeric&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; ## MPO 2101 Myeloperoxidase MPO Polyclonal MPO 500 ## HistoneH3 2113 Histone H3 D1H2 500 ## SMA 1914 SMA 1A4 500 ## CD16 2079 CD16 EPR16784 500 ## CD38 2095 CD38 EPR4106 500 ## HLADR 2087 HLA-DR TAL 1B5 500 ## Final.Concentration...Dilution uL.to.add ## &lt;character&gt; &lt;character&gt; ## MPO 4 ug/mL 0.8 ## HistoneH3 1 ug/mL 0.2 ## SMA 0.25 ug/mL 0.05 ## CD16 5 ug/mL 1 ## CD38 2.5 ug/mL 0.5 ## HLADR 1 ug/mL 0.2 5.1.2 IMC Segmentation Pipeline generated data The IMC Segmentation Pipeline offers an alternative approach to multiplexed image processing and segmentation. The default pipeline is also available via steinbock. The IMC Segmentation Pipeline is based on Ilastik pixel classification and image segmentation using CellProfiler. We recommend to become familiar with the pipeline as it allows flexible extension to more complicated image analysis and segmentation tasks. For standard image analysis and segmentation, steinbock is the preferred choice. Please refer to the documentation to get an overview on the pipeline. All relevant output storing single-cell data is contained in the cpout folder. For reading in the single-cell measurement, the imcRtools package offers the read_cpout function: spe2 &lt;- read_cpout(&quot;data/ImcSegmentationPipeline/analysis/cpout/&quot;) rownames(spe2) &lt;- rowData(spe2)$Clean_Target spe2 ## class: SpatialExperiment ## dim: 40 43796 ## metadata(0): ## assays(1): counts ## rownames(40): MPO HistoneH3 ... DNA1 DNA2 ## rowData names(11): Tube.Number Metal.Tag ... ilastik deepcell ## colnames: NULL ## colData names(12): sample_id ObjectNumber ... Metadata_acid ## Metadata_description ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialCoords names(2) : Pos_X Pos_Y ## imgData names(1): sample_id Similar to the steinbock output, cell morphological features and image level metadata are stored in the colData(spe2) slot, the interaction information is contained in colPair(spe2, type = \"neighborhood\") and the mean intensity per channel and cell is stored in counts(spe2). 5.1.3 Reading custom files When not using steinbock or the ImcSegmentationPipeline, the single-cell information has to be read in from custom files. We now demonstrate how to generate a SpatialExperiment object from single-cell data contained in individual files. As an example, we use files generated by CellProfiler as part of the ImcSegmentationPipeline. First we will read in the single-cell features stored in a CSV file: library(readr) cur_features &lt;- read_csv(&quot;data/ImcSegmentationPipeline/analysis/cpout/cell.csv&quot;) dim(cur_features) ## [1] 43796 941 head(colnames(cur_features)) ## [1] &quot;ImageNumber&quot; &quot;ObjectNumber&quot; ## [3] &quot;AreaShape_Area&quot; &quot;AreaShape_BoundingBoxArea&quot; ## [5] &quot;AreaShape_BoundingBoxMaximum_X&quot; &quot;AreaShape_BoundingBoxMaximum_Y&quot; This file contains a large number of single-cell features including the cell identifier (ObjectNumber), the image identifier (ImageNumber), morphological features (AreaShape_*), the cells’ locations (Location_Center_*) and the mean pixel intensity per cell and per channel (Intensity_MeanIntensity_FullStack_*). Now, we split the features into intensity features, cell-specific metadata and the physical location of the cells: counts &lt;- cur_features[,grepl(&quot;Intensity_MeanIntensity_FullStack&quot;, colnames(cur_features))] meta &lt;- cur_features[,c(&quot;ImageNumber&quot;, &quot;ObjectNumber&quot;, &quot;AreaShape_Area&quot;, &quot;AreaShape_Eccentricity&quot;, &quot;AreaShape_MeanRadius&quot;)] coords &lt;- cur_features[,c(&quot;Location_Center_X&quot;, &quot;Location_Center_Y&quot;)] CellProfiler writes out the mean pixel intensities after scaling them bit a scaling factor which is bit encoding-specific. The images to which the IMC Segmentation Pipeline was applied were saved with 16-bit encoding. This means for the example data, the mean pixel intensities need to be scaled by a factor of 2 ^ 16 - 1 = 65535. counts &lt;- counts * 65535 In addition, CellProfiler does not order the channel numerically but rather as a character; 1, 10, 2, 3, ... rather than 1, 2, 3, .... Therefore we will need to reorder the channels. library(stringr) cur_ch &lt;- str_split(colnames(counts), &quot;_&quot;, simplify = TRUE)[,4] cur_ch &lt;- sub(&quot;c&quot;, &quot;&quot;, cur_ch) counts &lt;- counts[,order(as.numeric(cur_ch))] From these features we can now construct the SpatialExperiment object. spe3 &lt;- SpatialExperiment(assays = list(counts = t(counts)), colData = meta, sample_id = as.character(meta$ImageNumber), spatialCoords = as.matrix(coords)) Next, we can store the spatial cell graph generated by CellProfiler in the colPairs slot of the object. Spatial cell graphs are usually stored as edge list in form of a CSV file. The colPairs slot requires a SelfHits entry storing an edge list where numeric entries represent the index of the from and to cell in the SpatialExperiment object. To generate such an edge list, we need to match the cell IDs contained in the CSV against the cell IDs in the SpatialExperiment object. cur_pairs &lt;- read_csv(&quot;data/ImcSegmentationPipeline/analysis/cpout/Object relationships.csv&quot;) cur_from &lt;- paste(cur_pairs$`First Image Number`, cur_pairs$`First Object Number`) cur_to &lt;- paste(cur_pairs$`Second Image Number`, cur_pairs$`Second Object Number`) edgelist &lt;- SelfHits(from = match(cur_from, paste(spe3$ImageNumber, spe3$ObjectNumber)), to = match(cur_to, paste(spe3$ImageNumber, spe3$ObjectNumber)), nnode = ncol(spe3)) colPair(spe3, &quot;neighborhood&quot;) &lt;- edgelist For further downstream analysis, we will use the steinbock results. 5.2 Single-cell processing After reading in the single-cell data, few further processing steps need to be taken. Add additional metadata We can set the colnames of the object to generate unique identifiers per cell: colnames(spe) &lt;- paste0(spe$sample_id, &quot;_&quot;, spe$ObjectNumber) It is also often the case that sample-specific metadata are available externally. For the current data, we need to link the cancer type (also referred to as “Indication”) to each sample. This metadata is available as external CSV file: library(tidyverse) # Read patient metadata meta &lt;- read_csv(&quot;data/sample_metadata.csv&quot;) # Extract patient id and ROI id from sample name spe$patient_id &lt;- str_extract(spe$sample_id, &quot;Patient[1-4]&quot;) spe$ROI &lt;- str_extract(spe$sample_id, &quot;00[1-8]&quot;) # Store cancer type in SPE object spe$indication &lt;- meta$Indication[match(spe$patient_id, meta$`Sample ID`)] unique(spe$patient_id) ## [1] &quot;Patient1&quot; &quot;Patient2&quot; &quot;Patient3&quot; &quot;Patient4&quot; unique(spe$ROI) ## [1] &quot;001&quot; &quot;002&quot; &quot;003&quot; &quot;004&quot; &quot;005&quot; &quot;006&quot; &quot;007&quot; &quot;008&quot; unique(spe$indication) ## [1] &quot;SCCHN&quot; &quot;BCC&quot; &quot;NSCLC&quot; &quot;CRC&quot; The selected patients were diagnosed with different cancer types: SCCHN - head and neck cancer BCC - breast cancer NSCLC - lung cancer CRC - colorectal cancer Transform counts The distribution of expression counts across cells is often observed to be skewed towards the right side meaning lots of cells display low counts and few cells have high counts. To avoid analysis biases from these high-expressing cells, the expression counts are commonly transformed or clipped. Here, we perform counts transformation using an inverse hyperbolic sine function. This transformation is commonly applied to flow cytometry data. The cofactor here defines the expression range on which no scaling is performed. While the cofactor for CyTOF data is often set to 5, IMC data usually display much lower counts. We therefore apply a cofactor of 1. However, other transformations such as log(counts(spe) + 0.01) should be tested when analysing IMC data. library(dittoSeq) dittoRidgePlot(spe, var = &quot;CD3&quot;, group.by = &quot;patient_id&quot;, assay = &quot;counts&quot;) + ggtitle(&quot;CD3 - before transformation&quot;) ## Warning in (function (mapping = NULL, data = NULL, stat = &quot;density_ridges&quot;, : ## Ignoring unknown parameters: `size` assay(spe, &quot;exprs&quot;) &lt;- asinh(counts(spe)/1) dittoRidgePlot(spe, var = &quot;CD3&quot;, group.by = &quot;patient_id&quot;, assay = &quot;exprs&quot;) + ggtitle(&quot;CD3 - after transformation&quot;) ## Warning in (function (mapping = NULL, data = NULL, stat = &quot;density_ridges&quot;, : ## Ignoring unknown parameters: `size` Define interesting channels For downstream analysis such as visualization, dimensionality reduction and clustering, only a subset of markers should be used. As convenience, we can store an additional entry in the rowData slot that specifies the markers of interest. Here, we deselect the nuclear markers, which were primarily used for cell segmentation, and keep all other biological targets. However, more informed marker selection should be performed to exclude lowly expressed marker or markers with low signal-to-noise ratio. rowData(spe)$use_channel &lt;- !grepl(&quot;DNA|Histone&quot;, rownames(spe)) Define color schemes We will define color schemes for different metadata entries of the data and conveniently store them in the metadata slot of the SpatialExperiment which will be helpful for downstream data visualizations. We will use colors from the RColorBrewer and dittoSeq packages but any other coloring package will suffice. library(RColorBrewer) color_vectors &lt;- list() ROI &lt;- setNames(brewer.pal(length(unique(spe$ROI)), name = &quot;BrBG&quot;), unique(spe$ROI)) patient_id &lt;- setNames(brewer.pal(length(unique(spe$patient_id)), name = &quot;Set1&quot;), unique(spe$patient_id)) sample_id &lt;- setNames(c(brewer.pal(6, &quot;YlOrRd&quot;)[3:5], brewer.pal(6, &quot;PuBu&quot;)[3:6], brewer.pal(6, &quot;YlGn&quot;)[3:5], brewer.pal(6, &quot;BuPu&quot;)[3:6]), unique(spe$sample_id)) indication &lt;- setNames(brewer.pal(length(unique(spe$indication)), name = &quot;Set2&quot;), unique(spe$indication)) color_vectors$ROI &lt;- ROI color_vectors$patient_id &lt;- patient_id color_vectors$sample_id &lt;- sample_id color_vectors$indication &lt;- indication metadata(spe)$color_vectors &lt;- color_vectors 5.3 Read in images The cytomapper package allows multi-channel image handling and visualization within the Bioconductor framework. The most common data format for multi-channel images or segmentation masks is the TIFF file format, which is used by steinbock and the IMC segementation pipeline to save images. Here, we will read in multi-channel images and segmentation masks into a CytoImageList data container. It allows storing multiple multi-channel images and requires matched channels across all images within the object. The loadImages function is used to read in processed multi-channel images and their corresponding segmentation masks. Of note: the multi-channel images generated by steinbock are saved as 32-bit images while the segmentation masks are saved as 16-bit images. To correctly scale pixel values of the segmentation masks when reading them in, we will need to set as.is = TRUE. images &lt;- loadImages(&quot;data/steinbock/img/&quot;) ## All files in the provided location will be read in. masks &lt;- loadImages(&quot;data/steinbock/masks_deepcell/&quot;, as.is = TRUE) ## All files in the provided location will be read in. In the case of multi-channel images, it is beneficial to set the channelNames for easy visualization. Using the steinbock framework, the channel order of the single-cell data matches the channel order of the multi-channel images. However, it is recommended to make sure that the channel order is identical between the single-cell data and the images. channelNames(images) &lt;- rownames(spe) images ## CytoImageList containing 14 image(s) ## names(14): Patient1_001 Patient1_002 Patient1_003 Patient2_001 Patient2_002 Patient2_003 Patient2_004 Patient3_001 Patient3_002 Patient3_003 Patient4_005 Patient4_006 Patient4_007 Patient4_008 ## Each image contains 40 channel(s) ## channelNames(40): MPO HistoneH3 SMA CD16 CD38 HLADR CD27 CD15 CD45RA CD163 B2M CD20 CD68 Ido1 CD3 LAG3 / LAG33 CD11c PD1 PDGFRb CD7 GrzB PDL1 TCF7 CD45RO FOXP3 ICOS CD8a CarbonicAnhydrase CD33 Ki67 VISTA CD40 CD4 CD14 Ecad CD303 CD206 cleavedPARP DNA1 DNA2 For visualization shown in Section 11 we will need to add additional metadata to the elementMetadata slot of the CytoImageList objects. This slot is easily accessible using the mcols function. Here, we will store the matched sample_id, patient_id and indication information within the elementMetadata slot of the multi-channel images and segmentation masks objects. It is crucial that the order of the images in both CytoImageList objects is the same. all.equal(names(images), names(masks)) ## [1] TRUE # Extract patient id from image name patient_id &lt;- str_extract(names(images), &quot;Patient[1-4]&quot;) # Retrieve cancer type per patient from metadata file indication &lt;- meta$Indication[match(patient_id, meta$`Sample ID`)] # Store patient and image level information in elementMetadata mcols(images) &lt;- mcols(masks) &lt;- DataFrame(sample_id = names(images), patient_id = patient_id, indication = indication) 5.4 Generate single-cell data from images An alternative way of generating a SingleCellExperiment object directly from the multi-channel images and segmentation masks is supported by the measureObjects function of the cytomapper package. For each cell present in the masks object, the function computes the mean pixel intensity per channel as well as morphological features (area, radius, major axis length, eccentricity) and the location of cells: cytomapper_sce &lt;- measureObjects(masks, image = images, img_id = &quot;sample_id&quot;) cytomapper_sce ## class: SingleCellExperiment ## dim: 40 47859 ## metadata(0): ## assays(1): counts ## rownames(40): MPO HistoneH3 ... DNA1 DNA2 ## rowData names(0): ## colnames: NULL ## colData names(10): sample_id object_id ... patient_id indication ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): 5.5 Accessing publicly available IMC datasets The imcdatasets R/Bioconductor package provides a number of publicly available IMC datasets. For a complete introduction to the package, please refer to the documentation. Here, we can read in example data of (Damond et al. 2019) taken from patients diagnosed with Type I Diabetes. The example here consists of a CytoImageList object of 100 images, a CytoImageList object of 100 segmentation masks and a SingleCellExperiment object containing 252059 cells. Of note: downloading the images takes quite some time and uses 8GB of memory. library(imcdatasets) pancreasImages &lt;- Damond_2019_Pancreas(data_type = &quot;images&quot;) pancreasMasks &lt;- Damond_2019_Pancreas(data_type = &quot;masks&quot;) pancreasSCE &lt;- Damond_2019_Pancreas(data_type = &quot;sce&quot;) 5.6 Save objects Finally, the generated data objects can be saved for further downstream processing and analysis. saveRDS(spe, &quot;data/spe.rds&quot;) saveRDS(images, &quot;data/images.rds&quot;) saveRDS(masks, &quot;data/masks.rds&quot;) 5.7 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 RColorBrewer_1.1-3 ## [3] dittoSeq_1.14.0 lubridate_1.9.3 ## [5] forcats_1.0.0 dplyr_1.1.4 ## [7] purrr_1.0.2 tidyr_1.3.0 ## [9] tibble_3.2.1 ggplot2_3.4.4 ## [11] tidyverse_2.0.0 stringr_1.5.1 ## [13] readr_2.1.4 cytomapper_1.14.0 ## [15] EBImage_4.44.0 imcRtools_1.8.0 ## [17] SpatialExperiment_1.12.0 SingleCellExperiment_1.24.0 ## [19] SummarizedExperiment_1.32.0 Biobase_2.62.0 ## [21] GenomicRanges_1.54.1 GenomeInfoDb_1.38.5 ## [23] IRanges_2.36.0 S4Vectors_0.40.2 ## [25] BiocGenerics_0.48.1 MatrixGenerics_1.14.0 ## [27] matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] later_1.3.2 bitops_1.0-7 ## [3] svgPanZoom_0.3.4 polyclip_1.10-6 ## [5] lifecycle_1.0.4 sf_1.0-15 ## [7] rprojroot_2.0.4 lattice_0.21-9 ## [9] vroom_1.6.5 MASS_7.3-60 ## [11] magrittr_2.0.3 sass_0.4.8 ## [13] rmarkdown_2.25 jquerylib_0.1.4 ## [15] yaml_2.3.8 httpuv_1.6.13 ## [17] sp_2.1-2 cowplot_1.1.2 ## [19] DBI_1.2.0 pkgload_1.3.3 ## [21] abind_1.4-5 zlibbioc_1.48.0 ## [23] ggraph_2.1.0 RCurl_1.98-1.13 ## [25] tweenr_2.0.2 GenomeInfoDbData_1.2.11 ## [27] ggrepel_0.9.4 RTriangle_1.6-0.12 ## [29] terra_1.7-65 pheatmap_1.0.12 ## [31] units_0.8-5 svglite_2.1.3 ## [33] DelayedMatrixStats_1.24.0 codetools_0.2-19 ## [35] DelayedArray_0.28.0 DT_0.31 ## [37] scuttle_1.12.0 ggforce_0.4.1 ## [39] tidyselect_1.2.0 raster_3.6-26 ## [41] farver_2.1.1 viridis_0.6.4 ## [43] jsonlite_1.8.8 BiocNeighbors_1.20.1 ## [45] e1071_1.7-14 ellipsis_0.3.2 ## [47] tidygraph_1.3.0 ggridges_0.5.5 ## [49] systemfonts_1.0.5 tools_4.3.2 ## [51] Rcpp_1.0.11 glue_1.6.2 ## [53] gridExtra_2.3 SparseArray_1.2.3 ## [55] xfun_0.41 HDF5Array_1.30.0 ## [57] shinydashboard_0.7.2 withr_2.5.2 ## [59] fastmap_1.1.1 rhdf5filters_1.14.1 ## [61] fansi_1.0.6 digest_0.6.33 ## [63] timechange_0.2.0 R6_2.5.1 ## [65] mime_0.12 colorspace_2.1-0 ## [67] jpeg_0.1-10 utf8_1.2.4 ## [69] generics_0.1.3 data.table_1.14.10 ## [71] class_7.3-22 graphlayouts_1.0.2 ## [73] htmlwidgets_1.6.4 S4Arrays_1.2.0 ## [75] pkgconfig_2.0.3 gtable_0.3.4 ## [77] XVector_0.42.0 brio_1.1.4 ## [79] htmltools_0.5.7 bookdown_0.37 ## [81] fftwtools_0.9-11 scales_1.3.0 ## [83] png_0.1-8 knitr_1.45 ## [85] tzdb_0.4.0 rjson_0.2.21 ## [87] proxy_0.4-27 cachem_1.0.8 ## [89] rhdf5_2.46.1 KernSmooth_2.23-22 ## [91] parallel_4.3.2 vipor_0.4.7 ## [93] concaveman_1.1.0 desc_1.4.3 ## [95] pillar_1.9.0 grid_4.3.2 ## [97] vctrs_0.6.5 promises_1.2.1 ## [99] distances_0.1.10 beachmat_2.18.0 ## [101] xtable_1.8-4 archive_1.1.7 ## [103] beeswarm_0.4.0 evaluate_0.23 ## [105] magick_2.8.2 cli_3.6.2 ## [107] locfit_1.5-9.8 compiler_4.3.2 ## [109] rlang_1.1.2 crayon_1.5.2 ## [111] labeling_0.4.3 classInt_0.4-10 ## [113] ggbeeswarm_0.7.2 stringi_1.8.3 ## [115] viridisLite_0.4.2 BiocParallel_1.36.0 ## [117] nnls_1.5 munsell_0.5.0 ## [119] tiff_0.1-12 Matrix_1.6-4 ## [121] hms_1.1.3 sparseMatrixStats_1.14.0 ## [123] bit64_4.0.5 Rhdf5lib_1.24.1 ## [125] shiny_1.8.0 highr_0.10 ## [127] igraph_1.6.0 bslib_0.6.1 ## [129] bit_4.0.5 References "],["spillover-correction.html", "6 Spillover correction 6.1 Generate the spillover matrix 6.2 Single-cell data compensation 6.3 Image compensation 6.4 Write out compensated images 6.5 Save objects 6.6 Session Info", " 6 Spillover correction Original scripts: Vito Zanotelli, adapted/maintained by: Nils Eling This section highlights how to generate a spillover matrix from individually acquired single metal spots on an agarose slide. Each spot needs to be imaged as its own acquisition/ROI and individual TXT files containing the pixel intensities per spot need to be available. For complete details on the spillover correction approach, please refer to the original publication (Chevrier et al. 2017). Spillover slide preparation: Prepare 2% agarose in double distilled H\\(_2\\)O in a beaker and melt it in a microwave until well dissolved. Dip a blank superfrost plus glass microscope slide into the agarose and submerge it until the label. Remove the slide and prop it up against a support to allow the excess agarose to run off onto paper towels. Allow the slide to dry completely (at least 30 minutes). Retrieve all the antibody conjugates used in the panel for which the spillover matrix is to be generated and place them on ice. Arrange them in a known order (e.g., mass of the conjugated metal). Pipette 0.3 µl spots of 0.4% trypan blue dye into an array on the slide. Prepare one spot per antibody, and make sure the spots are well separated. Pipette 0.3 µl of each antibody conjugate (usually at 0.5 mg/ml) onto a unique blue spot, taking care to avoid different antibodies bleeding into each other. Note the exact location of each conjugate on the slide. Let the spots dry completely, at least 1 hour. Spillover slide acquisition: Create a JPEG or PNG image of the slide using a mobile phone camera or flat-bed scanner. In the CyTOF software, create a new file and import the slide image into it. Create a panorama across all the spots to visualize their locations. Within each spot, create a region of interest (ROI) with a width of 200 pixels and a height of 10 pixels. Name each ROI with the mass and name of the metal conjugate contained in the spot, e.g “Ir193” or “Ho165”. This will be how each TXT file is named. Set the profiling type of each ROI to “Local”. Apply the antibody panel to all the ROIs. This panel should contain all (or more) of the isotopes in the panel, with the correct metal specified. For example: if the metal used is Barium 138, make sure this, rather than Lanthanum 138, is selected. Save the file, make sure “Generate Text File” is selected, and start the acquisition. This procedure will generate an MCD file similar to the one available on zenodo: 10.5281/zenodo.5949115 The original code of the spillover correction manuscript is available on Github here; however, due to changes in the CATALYST package, users were not able to reproduce the analysis using the newest software versions. The following workflow uses the newest package versions to generate a spillover matrix and perform spillover correction. In brief, the highlighted workflow comprises 9 steps: Reading in the data Quality control (Optional) pixel binning “Debarcoding” for pixel assignment Pixel selection for spillover matrix estimation Spillover matrix generation Saving the results Single-cell compensation Image compensation 6.1 Generate the spillover matrix In the first step, we will generate a spillover matrix based on the single-metal spots and save it for later use. 6.1.1 Read in the data Here, we will read in the individual TXT files into a SingleCellExperiment object. This object can be used directly by the CATALYST package to estimate the spillover. For this to work, the TXT file names need to contain the spotted metal isotope name. By default, the first occurrence of the isotope in the format (mt)(mass) (e.g. Sm152 for Samarium isotope with the atomic mass 152) will be used as spot identifier. Alternatively, a named list of already read-in pixel intensities can be provided. For more information, please refer to the man page ?readSCEfromTXT. For further downstream analysis, we will asinh-transform the data using a cofactor of 5; a common transformation for CyTOF data (Bendall et al. 2011). As the pixel intensities are larger than the cell intensities, the cofactor here is larger than the cofactor when transforming the mean cell intensities. library(imcRtools) # Create SingleCellExperiment from TXT files sce &lt;- readSCEfromTXT(&quot;data/compensation/&quot;) ## Spotted channels: Y89, In113, In115, Pr141, Nd142, Nd143, Nd144, Nd145, Nd146, Sm147, Nd148, Sm149, Nd150, Eu151, Sm152, Eu153, Sm154, Gd155, Gd156, Gd158, Tb159, Gd160, Dy161, Dy162, Dy163, Dy164, Ho165, Er166, Er167, Er168, Tm169, Er170, Yb171, Yb172, Yb173, Yb174, Lu175, Yb176 ## Acquired channels: Ar80, Y89, In113, In115, Xe131, Xe134, Ba136, La138, Pr141, Nd142, Nd143, Nd144, Nd145, Nd146, Sm147, Nd148, Sm149, Nd150, Eu151, Sm152, Eu153, Sm154, Gd155, Gd156, Gd158, Tb159, Gd160, Dy161, Dy162, Dy163, Dy164, Ho165, Er166, Er167, Er168, Tm169, Er170, Yb171, Yb172, Yb173, Yb174, Lu175, Yb176, Ir191, Ir193, Pt196, Pb206 ## Channels spotted but not acquired: ## Channels acquired but not spotted: Ar80, Xe131, Xe134, Ba136, La138, Ir191, Ir193, Pt196, Pb206 assay(sce, &quot;exprs&quot;) &lt;- asinh(counts(sce)/5) 6.1.2 Quality control In the next step, we will observe the median pixel intensities per spot and threshold on medians &lt; 200 counts. These types of visualization serve two purposes: Small median pixel intensities (&lt; 200 counts) might hinder the robust estimation of the channel spillover. In that case, consecutive pixels can be summed (see Optional pixel binning). Each spotted metal (row) should show the highest median pixel intensity in its corresponding channel (column). If this is not the case, either the naming of the TXT files was incorrect or the incorrect metal was spotted. # Log10 median pixel counts per spot and channel plotSpotHeatmap(sce) # Thresholded on 200 pixel counts plotSpotHeatmap(sce, log = FALSE, threshold = 200) As we can see, nearly all median pixel intensities are &gt; 200 counts for each spot. We also observe acquired channels for which no spot was placed (e.g., Xe134, Ir191, Ir193). 6.1.3 Optional pixel binning In cases where median pixel intensities are low (&lt; 200 counts), consecutive pixels can be summed to increase the robustness of the spillover estimation. The imcRtools package provides the binAcrossPixels function, which performs aggregation for each channel across bin_size consecutive pixels per spotted metal. # Define grouping bin_size = 10 sce2 &lt;- binAcrossPixels(sce, bin_size = bin_size) # Log10 median pixel counts per spot and channel plotSpotHeatmap(sce2) # Thresholded on 200 pixel counts plotSpotHeatmap(sce2, log = FALSE, threshold = 200) Here, we can see an increase in the median pixel intensities and accumulation of off-diagonal signal. Due to already high original pixel intensities, we will refrain from aggregating across consecutive pixels for this demonstration. 6.1.4 Filtering incorrectly assigned pixels The following step uses functions provided by the CATALYST package to “debarcode” the pixels. Based on the intensity distribution of all channels, pixels are assigned to their corresponding barcode; here this is the already known metal spot. This procedure serves the purpose to identify pixels that cannot be robustly assigned to the spotted metal. Pixels of such kind can be regarded as “noisy”, “background” or “artefacts” that should be removed prior to spillover estimation. We will also need to specify which channels were spotted (argument bc_key). This information is directly contained in the colData(sce) slot. To facilitate visualization, we will order the bc_key by mass. The general workflow for pixel debarcoding is as follows: assign a preliminary metal mass to each pixel for each pixel, estimate a cutoff parameter for the distance between positive and negative pixel sets apply the estimated cutoffs to identify truly positive pixels library(CATALYST) bc_key &lt;- as.numeric(unique(sce$sample_mass)) bc_key &lt;- bc_key[order(bc_key)] sce &lt;- assignPrelim(sce, bc_key = bc_key) sce &lt;- estCutoffs(sce) sce &lt;- applyCutoffs(sce) The obtained SingleCellExperiment now contains the additional bc_id entry. For each pixel, this vector indicates the assigned mass (e.g. 161) or 0, meaning unassigned. This information can be visualized in form of a heatmap: library(pheatmap) cur_table &lt;- table(sce$bc_id, sce$sample_mass) # Visualize the correctly and incorrectly assigned pixels pheatmap(log10(cur_table + 1), cluster_rows = FALSE, cluster_cols = FALSE) # Compute the fraction of unassigned pixels per spot cur_table[&quot;0&quot;,] / colSums(cur_table) ## 113 115 141 142 143 144 145 146 147 148 149 ## 0.1985 0.1060 0.2575 0.3195 0.3190 0.3825 0.3545 0.4280 0.3570 0.4770 0.4200 ## 150 151 152 153 154 155 156 158 159 160 161 ## 0.4120 0.4025 0.4050 0.4630 0.4190 0.4610 0.3525 0.4020 0.4655 0.4250 0.5595 ## 162 163 164 165 166 167 168 169 170 171 172 ## 0.4340 0.4230 0.4390 0.4055 0.5210 0.3900 0.3285 0.3680 0.5015 0.4900 0.5650 ## 173 174 175 176 89 ## 0.3125 0.4605 0.4710 0.2845 0.3015 We can see here, that all pixels were assigned to the right mass and that all pixel sets are made up of &gt; 800 pixels. However, in cases where incorrect assignment occurred or where few pixels were measured for some spots, the imcRtools package exports a simple helper function to exclude pixels based on these criteria: sce &lt;- filterPixels(sce, minevents = 40, correct_pixels = TRUE) In the filterPixels function, the minevents parameter specifies the threshold under which correctly assigned pixel sets are excluded from spillover estimation. The correct_pixels parameter indicates whether pixels that were assigned to masses other than the spotted mass should be excluded from spillover estimation. The default values often result in sufficient pixel filtering; however, if very few pixels (~100) are measured per spot, the minevents parameter value needs to be lowered. 6.1.5 Compute spillover matrix Based on the single-positive pixels, we use the CATALYST::computeSpillmat() function to compute the spillover matrix and CATALYST::plotSpillmat() to visualize it. The plotSpillmat function checks the spotted and acquired metal isotopes against a pre-defined CATALYST::isotope_list(). In this data, the Ar80 channel was additionally acquired to check for deviations in signal intensity. Ar80 needs to be added to a custom isotope_list object for visualization. sce &lt;- computeSpillmat(sce) isotope_list &lt;- CATALYST::isotope_list isotope_list$Ar &lt;- 80 plotSpillmat(sce, isotope_list = isotope_list) ## Warning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in ## ggplot2 3.3.4. ## ℹ Please use &quot;none&quot; instead. ## ℹ The deprecated feature was likely used in the CATALYST package. ## Please report the issue at &lt;https://github.com/HelenaLC/CATALYST/issues&gt;. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. # Save spillover matrix in variable sm &lt;- metadata(sce)$spillover_matrix Of note: the visualization of the spillover matrix using CATALYST does currently not visualize spillover between the larger channels. In this case, the spillover matrix is clipped at Yb171. As we can see, the largest spillover appears in In113 --&gt; In115 and we also observe the +16 oxide impurities for e.g. Nd148 --&gt; Dy164. We can save the spillover matrix for external use. write.csv(sm, &quot;data/sm.csv&quot;) 6.2 Single-cell data compensation The CATALYST package can be used to perform spillover compensation on the single-cell mean intensities. Here, the SpatialExperiment object generated in Section 5 is read in. The CATALYST package requires an entry to rowData(spe)$channel_name for the compCytof function to run. This entry should contain the metal isotopes in the form (mt)(mass)Di (e.g., Sm152Di for Samarium isotope with the atomic mass 152). The compCytof function performs channel spillover compensation on the mean pixel intensities per channel and cell. Here, we will not overwrite the assays in the SpatialExperiment object to later highlight the effect of compensation. As shown in Section 5, also the compensated counts are asinh-transformed using a cofactor of 1. spe &lt;- readRDS(&quot;data/spe.rds&quot;) rowData(spe)$channel_name &lt;- paste0(rowData(spe)$channel, &quot;Di&quot;) spe &lt;- compCytof(spe, sm, transform = TRUE, cofactor = 1, isotope_list = isotope_list, overwrite = FALSE) To check the effect of channel spillover compensation, the expression of markers that are affected by spillover (e.g., E-cadherin in channel Yb173 and CD303 in channel Yb174) can be visualized in form of scatter plots before and after compensation. library(dittoSeq) library(patchwork) before &lt;- dittoScatterPlot(spe, x.var = &quot;Ecad&quot;, y.var = &quot;CD303&quot;, assay.x = &quot;exprs&quot;, assay.y = &quot;exprs&quot;) + ggtitle(&quot;Before compensation&quot;) after &lt;- dittoScatterPlot(spe, x.var = &quot;Ecad&quot;, y.var = &quot;CD303&quot;, assay.x = &quot;compexprs&quot;, assay.y = &quot;compexprs&quot;) + ggtitle(&quot;After compensation&quot;) before + after We observe that the spillover Yb173 –&gt; Yb174 was successfully corrected. To facilitate further downstream analysis, the non-compensated assays can now be replaced by their compensated counterparts: assay(spe, &quot;counts&quot;) &lt;- assay(spe, &quot;compcounts&quot;) assay(spe, &quot;exprs&quot;) &lt;- assay(spe, &quot;compexprs&quot;) assay(spe, &quot;compcounts&quot;) &lt;- assay(spe, &quot;compexprs&quot;) &lt;- NULL 6.3 Image compensation The cytomapper package allows channel spillover compensation directly on multi-channel images. The compImage function takes a CytoImageList object and the estimated spillover matrix as input. More info on how to work with CytoImageList objects can be seen in Section 11. At this point, we can read in the CytoImageList object containing multi-channel images as generated in Section 5. The channelNames need to be set according to their metal isotope in the form (mt)(mass)Di and therefore match colnames(sm). library(cytomapper) images &lt;- readRDS(&quot;data/images.rds&quot;) channelNames(images) &lt;- rowData(spe)$channel_name The CATALYST package provides the adaptSpillmat function that corrects the spillover matrix in a way that rows and columns match a predefined set of metals. Please refer to ?compCytof for more information how metals in the spillover matrix are matched to acquired channels in the SingleCellExperiment object. The spillover matrix can now be adapted to exclude channels that were not kept for downstream analysis. adapted_sm &lt;- adaptSpillmat(sm, channelNames(images), isotope_list = isotope_list) ## Compensation is likely to be inaccurate. ## Spill values for the following interactions ## have not been estimated: ## Ir191Di -&gt; Ir193Di ## Ir193Di -&gt; Ir191Di The adapted spillover matrix now matches the channelNames of the CytoImageList object and can be used to perform pixel-level spillover compensation. Here, we parallelise the image compensation on all available minus 2 cores. When working on Windows, you will need to use the SnowParam function instead of MultiCoreParam. library(BiocParallel) images_comp &lt;- compImage(images, adapted_sm, BPPARAM = MulticoreParam()) As a sanity check, we will visualize the image before and after compensation: # Before compensation plotPixels(images[5], colour_by = &quot;Yb173Di&quot;, image_title = list(text = &quot;Yb173 (Ecad) - before&quot;, position = &quot;topleft&quot;), legend = NULL, bcg = list(Yb173Di = c(0, 4, 1))) plotPixels(images[5], colour_by = &quot;Yb174Di&quot;, image_title = list(text = &quot;Yb174 (CD303) - before&quot;, position = &quot;topleft&quot;), legend = NULL, bcg = list(Yb174Di = c(0, 4, 1))) # After compensation plotPixels(images_comp[5], colour_by = &quot;Yb173Di&quot;, image_title = list(text = &quot;Yb173 (Ecad) - after&quot;, position = &quot;topleft&quot;), legend = NULL, bcg = list(Yb173Di = c(0, 4, 1))) plotPixels(images_comp[5], colour_by = &quot;Yb174Di&quot;, image_title = list(text = &quot;Yb174 (CD303) - after&quot;, position = &quot;topleft&quot;), legend = NULL, bcg = list(Yb174Di = c(0, 4, 1))) For convenience, we will re-set the channelNames to their biological targtes: channelNames(images_comp) &lt;- rownames(spe) 6.4 Write out compensated images In the final step, the compensated images are written out as 16-bit TIFF files: library(tiff) dir.create(&quot;data/comp_img&quot;) lapply(names(images_comp), function(x){ writeImage(as.array(images_comp[[x]])/(2^16 - 1), paste0(&quot;data/comp_img/&quot;, x, &quot;.tiff&quot;), bits.per.sample = 16) }) 6.5 Save objects For further downstream analysis, the compensated SpatialExperiment and CytoImageList objects are saved replacing the former objects: saveRDS(spe, &quot;data/spe.rds&quot;) saveRDS(images_comp, &quot;data/images.rds&quot;) 6.6 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 tiff_0.1-12 ## [3] BiocParallel_1.36.0 cytomapper_1.14.0 ## [5] EBImage_4.44.0 patchwork_1.1.3 ## [7] dittoSeq_1.14.0 ggplot2_3.4.4 ## [9] pheatmap_1.0.12 CATALYST_1.26.0 ## [11] imcRtools_1.8.0 SpatialExperiment_1.12.0 ## [13] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0 ## [15] Biobase_2.62.0 GenomicRanges_1.54.1 ## [17] GenomeInfoDb_1.38.5 IRanges_2.36.0 ## [19] S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [21] MatrixGenerics_1.14.0 matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] bitops_1.0-7 sf_1.0-15 ## [3] RColorBrewer_1.1-3 doParallel_1.0.17 ## [5] tools_4.3.2 backports_1.4.1 ## [7] utf8_1.2.4 R6_2.5.1 ## [9] DT_0.31 HDF5Array_1.30.0 ## [11] rhdf5filters_1.14.1 GetoptLong_1.0.5 ## [13] withr_2.5.2 sp_2.1-2 ## [15] gridExtra_2.3 cli_3.6.2 ## [17] archive_1.1.7 sandwich_3.1-0 ## [19] labeling_0.4.3 sass_0.4.8 ## [21] nnls_1.5 mvtnorm_1.2-4 ## [23] readr_2.1.4 proxy_0.4-27 ## [25] ggridges_0.5.5 systemfonts_1.0.5 ## [27] colorRamps_2.3.1 svglite_2.1.3 ## [29] scater_1.30.1 plotrix_3.8-4 ## [31] flowCore_2.14.0 generics_0.1.3 ## [33] shape_1.4.6 gtools_3.9.5 ## [35] vroom_1.6.5 car_3.1-2 ## [37] dplyr_1.1.4 Matrix_1.6-4 ## [39] RProtoBufLib_2.14.0 ggbeeswarm_0.7.2 ## [41] fansi_1.0.6 abind_1.4-5 ## [43] terra_1.7-65 lifecycle_1.0.4 ## [45] multcomp_1.4-25 yaml_2.3.8 ## [47] carData_3.0-5 rhdf5_2.46.1 ## [49] SparseArray_1.2.3 Rtsne_0.17 ## [51] grid_4.3.2 promises_1.2.1 ## [53] crayon_1.5.2 shinydashboard_0.7.2 ## [55] lattice_0.21-9 beachmat_2.18.0 ## [57] cowplot_1.1.2 magick_2.8.2 ## [59] pillar_1.9.0 knitr_1.45 ## [61] ComplexHeatmap_2.18.0 RTriangle_1.6-0.12 ## [63] rjson_0.2.21 codetools_0.2-19 ## [65] glue_1.6.2 data.table_1.14.10 ## [67] vctrs_0.6.5 png_0.1-8 ## [69] gtable_0.3.4 cachem_1.0.8 ## [71] xfun_0.41 S4Arrays_1.2.0 ## [73] mime_0.12 tidygraph_1.3.0 ## [75] ConsensusClusterPlus_1.66.0 survival_3.5-7 ## [77] iterators_1.0.14 cytolib_2.14.0 ## [79] units_0.8-5 ellipsis_0.3.2 ## [81] TH.data_1.1-2 bit64_4.0.5 ## [83] rprojroot_2.0.4 bslib_0.6.1 ## [85] irlba_2.3.5.1 svgPanZoom_0.3.4 ## [87] vipor_0.4.7 KernSmooth_2.23-22 ## [89] colorspace_2.1-0 DBI_1.2.0 ## [91] raster_3.6-26 tidyselect_1.2.0 ## [93] bit_4.0.5 compiler_4.3.2 ## [95] BiocNeighbors_1.20.1 desc_1.4.3 ## [97] DelayedArray_0.28.0 bookdown_0.37 ## [99] scales_1.3.0 classInt_0.4-10 ## [101] distances_0.1.10 stringr_1.5.1 ## [103] digest_0.6.33 fftwtools_0.9-11 ## [105] rmarkdown_2.25 XVector_0.42.0 ## [107] htmltools_0.5.7 pkgconfig_2.0.3 ## [109] jpeg_0.1-10 sparseMatrixStats_1.14.0 ## [111] highr_0.10 fastmap_1.1.1 ## [113] rlang_1.1.2 GlobalOptions_0.1.2 ## [115] htmlwidgets_1.6.4 shiny_1.8.0 ## [117] DelayedMatrixStats_1.24.0 farver_2.1.1 ## [119] jquerylib_0.1.4 zoo_1.8-12 ## [121] jsonlite_1.8.8 BiocSingular_1.18.0 ## [123] RCurl_1.98-1.13 magrittr_2.0.3 ## [125] scuttle_1.12.0 GenomeInfoDbData_1.2.11 ## [127] Rhdf5lib_1.24.1 munsell_0.5.0 ## [129] Rcpp_1.0.11 ggnewscale_0.4.9 ## [131] viridis_0.6.4 stringi_1.8.3 ## [133] ggraph_2.1.0 brio_1.1.4 ## [135] zlibbioc_1.48.0 MASS_7.3-60 ## [137] plyr_1.8.9 parallel_4.3.2 ## [139] ggrepel_0.9.4 graphlayouts_1.0.2 ## [141] splines_4.3.2 hms_1.1.3 ## [143] circlize_0.4.15 locfit_1.5-9.8 ## [145] igraph_1.6.0 ggpubr_0.6.0 ## [147] ggsignif_0.6.4 pkgload_1.3.3 ## [149] reshape2_1.4.4 ScaledMatrix_1.10.0 ## [151] XML_3.99-0.16 drc_3.0-1 ## [153] evaluate_0.23 tzdb_0.4.0 ## [155] foreach_1.5.2 tweenr_2.0.2 ## [157] httpuv_1.6.13 tidyr_1.3.0 ## [159] purrr_1.0.2 polyclip_1.10-6 ## [161] clue_0.3-65 ggforce_0.4.1 ## [163] rsvd_1.0.5 broom_1.0.5 ## [165] xtable_1.8-4 e1071_1.7-14 ## [167] rstatix_0.7.2 later_1.3.2 ## [169] viridisLite_0.4.2 class_7.3-22 ## [171] tibble_3.2.1 FlowSOM_2.10.0 ## [173] beeswarm_0.4.0 cluster_2.1.4 ## [175] concaveman_1.1.0 References "],["image-and-cell-level-quality-control.html", "7 Image and cell-level quality control 7.1 Read in the data 7.2 Segmentation quality control 7.3 Image-level quality control 7.4 Cell-level quality control 7.5 Save objects 7.6 Session Info", " 7 Image and cell-level quality control The following section discusses possible quality indicators for data obtained by IMC and other highly multiplexed imaging technologies. Here, we will focus on describing quality metrics on the single-cell as well as image level. 7.1 Read in the data We will first read in the data processed in previous sections: images &lt;- readRDS(&quot;data/images.rds&quot;) masks &lt;- readRDS(&quot;data/masks.rds&quot;) spe &lt;- readRDS(&quot;data/spe.rds&quot;) 7.2 Segmentation quality control The first step after image segmentation is to observe its accuracy. Without having ground-truth data readily available, a common approach to segmentation quality control is to overlay segmentation masks on composite images displaying channels that were used for segmentation. The cytomapper package supports exactly this tasks by using the plotPixels function. Here, we select 3 random images and perform image- and channel-wise normalization (channels are first min-max normalized and scaled to a range of 0-1 before clipping the maximum intensity to 0.2). library(cytomapper) set.seed(20220118) img_ids &lt;- sample(seq_along(images), 3) # Normalize and clip images cur_images &lt;- images[img_ids] cur_images &lt;- cytomapper::normalize(cur_images, separateImages = TRUE) cur_images &lt;- cytomapper::normalize(cur_images, inputRange = c(0, 0.2)) plotPixels(cur_images, mask = masks[img_ids], img_id = &quot;sample_id&quot;, missing_colour = &quot;white&quot;, colour_by = c(&quot;CD163&quot;, &quot;CD20&quot;, &quot;CD3&quot;, &quot;Ecad&quot;, &quot;DNA1&quot;), colour = list(CD163 = c(&quot;black&quot;, &quot;yellow&quot;), CD20 = c(&quot;black&quot;, &quot;red&quot;), CD3 = c(&quot;black&quot;, &quot;green&quot;), Ecad = c(&quot;black&quot;, &quot;cyan&quot;), DNA1 = c(&quot;black&quot;, &quot;blue&quot;)), image_title = NULL, legend = list(colour_by.title.cex = 0.7, colour_by.labels.cex = 0.7)) We can see that nuclei are centered within the segmentation masks and all cell types are correctly segmented (note: to zoom into the image you can right click and select Open Image in New Tab). A common challenge here is to segment large (e.g., epithelial cells - in cyan) versus small (e.g., B cells - in red). However, the segmentation approach here appears to correctly segment cells across different sizes. An easier and interactive way of observing segmentation quality is to use the interactive image viewer provided by the cytoviewer R/Bioconductor package (Meyer, Eling, and Bodenmiller 2024). Under “Image-level” &gt; “Basic controls”, up to six markers can be selected for visualization. The contrast of each marker can be adjusted. Under “Image-level” &gt; “Advanced controls”, click the “Show cell outlines” box to outline segmented cells on the images. library(cytoviewer) app &lt;- cytoviewer(image = images, mask = masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;) if (interactive()) { shiny::runApp(app) } An additional approach to observe cell segmentation quality and potentially also antibody specificity issues is to visualize single-cell expression in form of a heatmap. Here, we sub-sample the dataset to 2000 cells for visualization purposes and overlay the cancer type from which the cells were extracted. library(dittoSeq) library(viridis) cur_cells &lt;- sample(seq_len(ncol(spe)), 2000) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, cluster_cols = TRUE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = &quot;indication&quot;, annotation_colors = list(indication = metadata(spe)$color_vectors$indication)) We can differentiate between epithelial cells (Ecad+) and immune cells (CD45RO+). Some of the markers are detected in specific cells (e.g., Ki67, CD20, Ecad) while others are more broadly expressed across cells (e.g., HLADR, B2M, CD4). 7.3 Image-level quality control Image-level quality control is often performed using tools that offer a graphical user interface such as QuPath, FIJI and the previously mentioned cytoviewer package. Viewers that were specifically developed for IMC data can be seen here. In this section, we will specifically focus on quantitative metrics to assess image quality. It is often of interest to calculate the signal-to-noise ratio (SNR) for individual channels and markers. Here, we define the SNR as: \\[SNR = I_s/I_n\\] where \\(I_s\\) is the intensity of the signal (mean intensity of pixels with true signal) and \\(I_n\\) is the intensity of the noise (mean intensity of pixels containing noise). This definition of the SNR is just one of many and other measures can be applied. Finding a threshold that separates pixels containing signal and pixels containing noise is not trivial and different approaches can be chosen. Here, we use the otsu thresholding approach to find pixels of the “foreground” (i.e., signal) and “background” (i.e., noise). The SNR is then defined as the mean intensity of foreground pixels divided by the mean intensity of background pixels. We compute this measure as well as the mean signal intensity per image. The plot below shows the average SNR versus the average signal intensity across all images. library(tidyverse) library(ggrepel) library(EBImage) cur_snr &lt;- lapply(names(images), function(x){ img &lt;- images[[x]] mat &lt;- apply(img, 3, function(ch){ # Otsu threshold thres &lt;- otsu(ch, range = c(min(ch), max(ch)), levels = 65536) # Signal-to-noise ratio snr &lt;- mean(ch[ch &gt; thres]) / mean(ch[ch &lt;= thres]) # Signal intensity ps &lt;- mean(ch[ch &gt; thres]) return(c(snr = snr, ps = ps)) }) t(mat) %&gt;% as.data.frame() %&gt;% mutate(image = x, marker = colnames(mat)) %&gt;% pivot_longer(cols = c(snr, ps)) }) cur_snr &lt;- do.call(rbind, cur_snr) cur_snr %&gt;% group_by(marker, name) %&gt;% summarize(log_mean = log2(mean(value))) %&gt;% pivot_wider(names_from = name, values_from = log_mean) %&gt;% ggplot() + geom_point(aes(ps, snr)) + geom_label_repel(aes(ps, snr, label = marker)) + theme_minimal(base_size = 15) + ylab(&quot;Signal-to-noise ratio [log2]&quot;) + xlab(&quot;Signal intensity [log2]&quot;) We observe PD1, LAG3 and cleaved PARP to have high SNR but low signal intensity meaning that in general these markers are not abundantly expressed. The Iridium intercalator (here marked as DNA1 and DNA2) has the highest signal intensity but low SNR. This might be due to staining differences between individual nuclei where some nuclei are considered as background. We do however observe high SNR and sufficient signal intensity for the majority of markers. Otsu thesholding and SNR calculation does not perform well if the markers are lowly abundant. In the next code chunk, we will remove markers that have a positive signal of below 2 per image. cur_snr &lt;- cur_snr %&gt;% pivot_wider(names_from = name, values_from = value) %&gt;% filter(ps &gt; 2) %&gt;% pivot_longer(cols = c(snr, ps)) cur_snr %&gt;% group_by(marker, name) %&gt;% summarize(log_mean = log2(mean(value))) %&gt;% pivot_wider(names_from = name, values_from = log_mean) %&gt;% ggplot() + geom_point(aes(ps, snr)) + geom_label_repel(aes(ps, snr, label = marker)) + theme_minimal(base_size = 15) + ylab(&quot;Signal-to-noise ratio [log2]&quot;) + xlab(&quot;Signal intensity [log2]&quot;) This visualization shows a reduces SNR for PD1, LAG3 and cleaved PARP which was previously inflated due to low signal. Another quality indicator is the image area covered by cells (or biological tissue). This metric identifies ROIs where little cells are present, possibly hinting at incorrect selection of the ROI. We can compute the percentage of covered image area using the metadata contained in the SpatialExperiment object: cell_density &lt;- colData(spe) %&gt;% as.data.frame() %&gt;% group_by(sample_id) %&gt;% # Compute the number of pixels covered by cells and # the total number of pixels summarize(cell_area = sum(area), no_pixels = mean(width_px) * mean(height_px)) %&gt;% # Divide the total number of pixels # by the number of pixels covered by cells mutate(covered_area = cell_area / no_pixels) # Visualize the image area covered by cells per image ggplot(cell_density) + geom_point(aes(reorder(sample_id,covered_area), covered_area)) + theme_minimal(base_size = 15) + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15)) + ylim(c(0, 1)) + ylab(&quot;% covered area&quot;) + xlab(&quot;&quot;) We observe that two of the 14 images show unusually low cell coverage. These two images can now be visualized using cytomapper. # Normalize and clip images cur_images &lt;- images[c(&quot;Patient4_005&quot;, &quot;Patient4_007&quot;)] cur_images &lt;- cytomapper::normalize(cur_images, separateImages = TRUE) cur_images &lt;- cytomapper::normalize(cur_images, inputRange = c(0, 0.2)) plotPixels(cur_images, mask = masks[c(&quot;Patient4_005&quot;, &quot;Patient4_007&quot;)], img_id = &quot;sample_id&quot;, missing_colour = &quot;white&quot;, colour_by = c(&quot;CD163&quot;, &quot;CD20&quot;, &quot;CD3&quot;, &quot;Ecad&quot;, &quot;DNA1&quot;), colour = list(CD163 = c(&quot;black&quot;, &quot;yellow&quot;), CD20 = c(&quot;black&quot;, &quot;red&quot;), CD3 = c(&quot;black&quot;, &quot;green&quot;), Ecad = c(&quot;black&quot;, &quot;cyan&quot;), DNA1 = c(&quot;black&quot;, &quot;blue&quot;)), legend = list(colour_by.title.cex = 0.7, colour_by.labels.cex = 0.7)) These two images display less dense tissue structure but overall the images are intact and appear to be segmented correctly. Finally, it can be beneficial to visualize the mean marker expression per image to identify images with outlying marker expression. This check does not indicate image quality per se but can highlight biological differences. Here, we will use the aggregateAcrossCells function of the scuttle package to compute the mean expression per image. For visualization purposes, we again asinh transform the mean expression values. library(scuttle) image_mean &lt;- aggregateAcrossCells(spe, ids = spe$sample_id, statistics=&quot;mean&quot;, use.assay.type = &quot;counts&quot;) assay(image_mean, &quot;exprs&quot;) &lt;- asinh(counts(image_mean)) dittoHeatmap(image_mean, genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, cluster_cols = TRUE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;indication&quot;, &quot;patient_id&quot;, &quot;ROI&quot;), annotation_colors = list(indication = metadata(spe)$color_vectors$indication, patient_id = metadata(spe)$color_vectors$patient_id, ROI = metadata(spe)$color_vectors$ROI), show_colnames = TRUE) We observe extensive biological variation across the 14 images specifically for some of the cell phenotype markers including the macrophage marker CD206, the B cell marker CD20, the neutrophil marker CD15, and the proliferation marker Ki67. These differences will be further studied in the following chapters. 7.4 Cell-level quality control In the following paragraphs we will look at different metrics and visualization approaches to assess data quality (as well as biological differences) on the single-cell level. Related to the signal-to-noise ratio (SNR) calculated above on the pixel-level, a similar measure can be derived on the single-cell level. Here, we will use a two component Gaussian mixture model for each marker to find cells with positive and negative expression. The SNR is defined as: \\[SNR = I_s/I_n\\] where \\(I_s\\) is the intensity of the signal (mean intensity of cells with positive signal) and \\(I_n\\) is the intensity of the noise (mean intensity of cells lacking expression). To define cells with positive and negative marker expression, we fit the mixture model across the transformed counts of all cells contained in the SpatialExperiment object. Next, for each marker we calculate the mean of the non-transformed counts for the positive and the negative cells. The SNR is then the ratio between the mean of the positive signal and the mean of the negative signal. library(mclust) set.seed(220224) mat &lt;- sapply(seq_len(nrow(spe)), function(x){ cur_exprs &lt;- assay(spe, &quot;exprs&quot;)[x,] cur_counts &lt;- assay(spe, &quot;counts&quot;)[x,] cur_model &lt;- Mclust(cur_exprs, G = 2) mean1 &lt;- mean(cur_counts[cur_model$classification == 1]) mean2 &lt;- mean(cur_counts[cur_model$classification == 2]) signal &lt;- ifelse(mean1 &gt; mean2, mean1, mean2) noise &lt;- ifelse(mean1 &gt; mean2, mean2, mean1) return(c(snr = signal/noise, ps = signal)) }) cur_snr &lt;- t(mat) %&gt;% as.data.frame() %&gt;% mutate(marker = rownames(spe)) cur_snr %&gt;% ggplot() + geom_point(aes(log2(ps), log2(snr))) + geom_label_repel(aes(log2(ps), log2(snr), label = marker)) + theme_minimal(base_size = 15) + ylab(&quot;Signal-to-noise ratio [log2]&quot;) + xlab(&quot;Signal intensity [log2]&quot;) Next, we observe the distributions of cell size across the individual images. Differences in cell size distributions can indicate segmentation biases due to differences in cell density or can indicate biological differences due to cell type compositions (tumor cells tend to be larger than immune cells). dittoPlot(spe, var = &quot;area&quot;, group.by = &quot;sample_id&quot;, plots = &quot;boxplot&quot;) + ylab(&quot;Cell area&quot;) + xlab(&quot;&quot;) summary(spe$area) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 3.00 47.00 70.00 76.38 98.00 466.00 The median cell size is 70 pixels with a median major axis length of 11.3. The largest cell has an area of 466 pixels which relates to a diameter of 21.6 pixels assuming a circular shape. Overall, the distribution of cell sizes is similar across images with images from Patient4_005 and Patient4_007 showing a reduced average cell size. These images contain fewer tumor cells which can explain the smaller average cell size. We detect very small cells in the dataset and will remove them. The chosen threshold is arbitrary and needs to be adjusted per dataset. sum(spe$area &lt; 5) ## [1] 65 spe &lt;- spe[,spe$area &gt;= 5] Another quality indicator can be an absolute measure of cell density often reported in cells per mm\\(^2\\). cell_density &lt;- colData(spe) %&gt;% as.data.frame() %&gt;% group_by(sample_id) %&gt;% summarize(cell_count = n(), no_pixels = mean(width_px) * mean(height_px)) %&gt;% mutate(cells_per_mm2 = cell_count/(no_pixels/1000000)) ggplot(cell_density) + geom_point(aes(reorder(sample_id,cells_per_mm2), cells_per_mm2)) + theme_minimal(base_size = 15) + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) + ylab(&quot;Cells per mm2&quot;) + xlab(&quot;&quot;) The number of cells per mm\\(^2\\) varies across images which also depends on the number of tumor/non-tumor cells. As we can see in the following sections, some immune cells appear in cell dense regions while other stromal regions are less dense. The data presented here originate from samples from different locations with potential differences in pre-processing and each sample was stained individually. These (and other) technical aspects can induce staining differences between samples or batches of samples. Observing potential staining differences can be crucial to assess data quality. We will use ridgeline visualizations to check differences in staining patterns: multi_dittoPlot(spe, vars = rownames(spe)[rowData(spe)$use_channel], group.by = &quot;patient_id&quot;, plots = &quot;ridgeplot&quot;, assay = &quot;exprs&quot;, color.panel = metadata(spe)$color_vectors$patient_id) We observe variations in the distributions of marker expression across patients. These variations may arise partly from different abundances of cells in different images (e.g., Patient3 may have higher numbers of CD11c+ and PD1+ cells) as well as staining differences between samples. While most of the selected markers are specifically expressed in immune cell subtypes, we can see that E-Cadherin (a marker for epithelial (tumor) cells) shows a similar expression range across all patients. Finally, we will use non-linear dimensionality reduction methods to project cells from a high-dimensional (40) down to a low-dimensional (2) space. For this the scater package provides the runUMAP and runTSNE function. To ensure reproducibility, we will need to set a seed; however different seeds and different parameter settings (e.g., the perplexity parameter in the runTSNE function) need to be tested to avoid over-interpretation of visualization artefacts. For dimensionality reduction, we will use all channels that show biological variation across the dataset. However, marker selection can be performed with different biological questions in mind. Here, both the runUMAP and runTSNE function are not deterministic, meaning they produce different results across different runs. We therefore set a seed in this chunk for reproducibility purposes. library(scater) set.seed(220225) spe &lt;- runUMAP(spe, subset_row = rowData(spe)$use_channel, exprs_values = &quot;exprs&quot;) spe &lt;- runTSNE(spe, subset_row = rowData(spe)$use_channel, exprs_values = &quot;exprs&quot;) After dimensionality reduction, the low-dimensional embeddings are stored in the reducedDim slot. reducedDims(spe) ## List of length 2 ## names(2): UMAP TSNE head(reducedDim(spe, &quot;UMAP&quot;)) ## UMAP1 UMAP2 ## Patient1_001_1 -4.810167 -3.777362 ## Patient1_001_2 -4.397347 -3.456036 ## Patient1_001_3 -4.369883 -3.445561 ## Patient1_001_4 -4.081614 -3.162119 ## Patient1_001_5 -6.234012 -2.433976 ## Patient1_001_6 -5.666597 -3.428058 Visualization of the low-dimensional embedding facilitates assessment of potential “batch effects”. The dittoDimPlot function allows flexible visualization. It returns ggplot objects which can be further modified. library(patchwork) # visualize patient id p1 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;TSNE&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on TSNE&quot;) # visualize region of interest id p3 &lt;- dittoDimPlot(spe, var = &quot;ROI&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$ROI) + ggtitle(&quot;ROI ID on UMAP&quot;) p4 &lt;- dittoDimPlot(spe, var = &quot;ROI&quot;, reduction.use = &quot;TSNE&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$ROI) + ggtitle(&quot;ROI ID on TSNE&quot;) # visualize indication p5 &lt;- dittoDimPlot(spe, var = &quot;indication&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$indication) + ggtitle(&quot;Indication on UMAP&quot;) p6 &lt;- dittoDimPlot(spe, var = &quot;indication&quot;, reduction.use = &quot;TSNE&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$indication) + ggtitle(&quot;Indication on TSNE&quot;) (p1 + p2) / (p3 + p4) / (p5 + p6) # visualize marker expression p1 &lt;- dittoDimPlot(spe, var = &quot;Ecad&quot;, reduction.use = &quot;UMAP&quot;, assay = &quot;exprs&quot;, size = 0.2) + scale_color_viridis(name = &quot;Ecad&quot;) + ggtitle(&quot;E-Cadherin expression on UMAP&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;CD45RO&quot;, reduction.use = &quot;UMAP&quot;, assay = &quot;exprs&quot;, size = 0.2) + scale_color_viridis(name = &quot;CD45RO&quot;) + ggtitle(&quot;CD45RO expression on UMAP&quot;) p3 &lt;- dittoDimPlot(spe, var = &quot;Ecad&quot;, reduction.use = &quot;TSNE&quot;, assay = &quot;exprs&quot;, size = 0.2) + scale_color_viridis(name = &quot;Ecad&quot;) + ggtitle(&quot;Ecad expression on TSNE&quot;) p4 &lt;- dittoDimPlot(spe, var = &quot;CD45RO&quot;, reduction.use = &quot;TSNE&quot;, assay = &quot;exprs&quot;, size = 0.2) + scale_color_viridis(name = &quot;CD45RO&quot;) + ggtitle(&quot;CD45RO expression on TSNE&quot;) (p1 + p2) / (p3 + p4) We observe a strong separation of tumor cells (Ecad+ cells) between the patients. Here, each patient was diagnosed with a different tumor type. The separation of tumor cells could be of biological origin since tumor cells tend to display differences in expression between patients and cancer types and/or of technical origin: the panel only contains a single tumor marker (E-Cadherin) and therefore slight technical differences in staining causes visible separation between cells of different patients. Nevertheless, the immune compartment (CD45RO+ cells) mix between patients and we can rule out systematic staining differences between patients. 7.5 Save objects The modified SpatialExperiment object is saved for further downstream analysis. saveRDS(spe, &quot;data/spe.rds&quot;) 7.6 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 patchwork_1.1.3 ## [3] scater_1.30.1 mclust_6.0.1 ## [5] scuttle_1.12.0 ggrepel_0.9.4 ## [7] lubridate_1.9.3 forcats_1.0.0 ## [9] stringr_1.5.1 dplyr_1.1.4 ## [11] purrr_1.0.2 readr_2.1.4 ## [13] tidyr_1.3.0 tibble_3.2.1 ## [15] tidyverse_2.0.0 viridis_0.6.4 ## [17] viridisLite_0.4.2 dittoSeq_1.14.0 ## [19] ggplot2_3.4.4 cytoviewer_1.2.0 ## [21] cytomapper_1.14.0 SingleCellExperiment_1.24.0 ## [23] SummarizedExperiment_1.32.0 Biobase_2.62.0 ## [25] GenomicRanges_1.54.1 GenomeInfoDb_1.38.5 ## [27] IRanges_2.36.0 S4Vectors_0.40.2 ## [29] BiocGenerics_0.48.1 MatrixGenerics_1.14.0 ## [31] matrixStats_1.2.0 EBImage_4.44.0 ## ## loaded via a namespace (and not attached): ## [1] RColorBrewer_1.1-3 jsonlite_1.8.8 ## [3] magrittr_2.0.3 ggbeeswarm_0.7.2 ## [5] magick_2.8.2 farver_2.1.1 ## [7] rmarkdown_2.25 zlibbioc_1.48.0 ## [9] vctrs_0.6.5 memoise_2.0.1 ## [11] DelayedMatrixStats_1.24.0 RCurl_1.98-1.13 ## [13] terra_1.7-65 svgPanZoom_0.3.4 ## [15] htmltools_0.5.7 S4Arrays_1.2.0 ## [17] BiocNeighbors_1.20.1 raster_3.6-26 ## [19] Rhdf5lib_1.24.1 SparseArray_1.2.3 ## [21] rhdf5_2.46.1 sass_0.4.8 ## [23] bslib_0.6.1 desc_1.4.3 ## [25] htmlwidgets_1.6.4 fontawesome_0.5.2 ## [27] cachem_1.0.8 mime_0.12 ## [29] lifecycle_1.0.4 pkgconfig_2.0.3 ## [31] rsvd_1.0.5 colourpicker_1.3.0 ## [33] Matrix_1.6-4 R6_2.5.1 ## [35] fastmap_1.1.1 GenomeInfoDbData_1.2.11 ## [37] shiny_1.8.0 digest_0.6.33 ## [39] colorspace_2.1-0 shinycssloaders_1.0.0 ## [41] rprojroot_2.0.4 irlba_2.3.5.1 ## [43] pkgload_1.3.3 beachmat_2.18.0 ## [45] labeling_0.4.3 fansi_1.0.6 ## [47] nnls_1.5 timechange_0.2.0 ## [49] abind_1.4-5 compiler_4.3.2 ## [51] withr_2.5.2 tiff_0.1-12 ## [53] BiocParallel_1.36.0 highr_0.10 ## [55] HDF5Array_1.30.0 DelayedArray_0.28.0 ## [57] rjson_0.2.21 tools_4.3.2 ## [59] vipor_0.4.7 beeswarm_0.4.0 ## [61] httpuv_1.6.13 glue_1.6.2 ## [63] rhdf5filters_1.14.1 promises_1.2.1 ## [65] grid_4.3.2 Rtsne_0.17 ## [67] generics_0.1.3 gtable_0.3.4 ## [69] tzdb_0.4.0 hms_1.1.3 ## [71] ScaledMatrix_1.10.0 BiocSingular_1.18.0 ## [73] sp_2.1-2 utf8_1.2.4 ## [75] XVector_0.42.0 RcppAnnoy_0.0.21 ## [77] pillar_1.9.0 later_1.3.2 ## [79] lattice_0.21-9 tidyselect_1.2.0 ## [81] locfit_1.5-9.8 miniUI_0.1.1.1 ## [83] knitr_1.45 gridExtra_2.3 ## [85] bookdown_0.37 svglite_2.1.3 ## [87] xfun_0.41 shinydashboard_0.7.2 ## [89] brio_1.1.4 pheatmap_1.0.12 ## [91] stringi_1.8.3 fftwtools_0.9-11 ## [93] yaml_2.3.8 evaluate_0.23 ## [95] codetools_0.2-19 archive_1.1.7 ## [97] BiocManager_1.30.22 cli_3.6.2 ## [99] uwot_0.1.16 xtable_1.8-4 ## [101] systemfonts_1.0.5 munsell_0.5.0 ## [103] jquerylib_0.1.4 Rcpp_1.0.11 ## [105] png_0.1-8 parallel_4.3.2 ## [107] ellipsis_0.3.2 jpeg_0.1-10 ## [109] sparseMatrixStats_1.14.0 bitops_1.0-7 ## [111] SpatialExperiment_1.12.0 scales_1.3.0 ## [113] ggridges_0.5.5 crayon_1.5.2 ## [115] BiocStyle_2.30.0 rlang_1.1.2 ## [117] cowplot_1.1.2 References "],["batch-effects.html", "8 Batch effect correction 8.1 fastMNN correction 8.2 harmony correction 8.3 Seurat correction 8.4 Save objects 8.5 Session Info", " 8 Batch effect correction In Section 7.4 we observed staining/expression differences between the individual samples. This can arise due to technical (e.g., differences in sample processing) as well as biological (e.g., differential expression between patients/indications) effects. However, the combination of these effects hinders cell phenotyping via clustering as highlighted in Section 9.2. To integrate cells across samples, we can use computational strategies developed for correcting batch effects in single-cell RNA sequencing data. In the following sections, we will use functions of the batchelor, harmony and Seurat packages to correct for such batch effects. Of note: the correction approaches presented here aim at removing any differences between samples. This will also remove biological differences between the patients/indications. Nevertheless, integrating cells across samples can facilitate the detection of cell phenotypes via clustering. First, we will read in the SpatialExperiment object containing the single-cell data. spe &lt;- readRDS(&quot;data/spe.rds&quot;) 8.1 fastMNN correction The batchelor package provides the mnnCorrect and fastMNN functions to correct for differences between samples/batches. Both functions build up on finding mutual nearest neighbors (MNN) among the cells of different samples and correct expression differences between the batches (Haghverdi et al. 2018). The mnnCorrect function returns corrected expression counts while the fastMNN functions performs the correction in reduced dimension space. As such, fastMNN returns integrated cells in form of a low dimensional embedding. Paper: Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors Documentation: batchelor 8.1.1 Perform sample correction Here, we apply the fastMNN function to integrate cells between patients. By setting auto.merge = TRUE the function estimates the best batch merging order by maximizing the number of MNN pairs at each merging step. This is more time consuming than merging sequentially based on how batches appear in the dataset (default). We again select the markers defined in Section 5.2 for sample correction. The function returns a SingleCellExperiment object which contains corrected low-dimensional coordinates for each cell in the reducedDim(out, \"corrected\") slot. This low-dimensional embedding can be further used for clustering and non-linear dimensionality reduction. We check that the order of cells is the same between the input and output object and then transfer the corrected coordinates to the main SpatialExperiment object. library(batchelor) set.seed(220228) out &lt;- fastMNN(spe, batch = spe$patient_id, auto.merge = TRUE, subset.row = rowData(spe)$use_channel, assay.type = &quot;exprs&quot;) # Check that order of cells is the same stopifnot(all.equal(colnames(spe), colnames(out))) # Transfer the correction results to the main spe object reducedDim(spe, &quot;fastMNN&quot;) &lt;- reducedDim(out, &quot;corrected&quot;) The computational time of the fastMNN function call is 1.49 minutes. Of note, the warnings that the fastMNN function produces can be avoided as follows: The following warning can be avoided by setting BSPARAM = BiocSingular::ExactParam() Warning in (function (A, nv = 5, nu = nv, maxit = 1000, work = nv + 7, reorth = TRUE, : You&#39;re computing too large a percentage of total singular values, use a standard svd instead. The following warning can be avoided by requesting fewer singular values by setting d = 30 In check_numbers(k = k, nu = nu, nv = nv, limit = min(dim(x)) - : more singular values/vectors requested than available 8.1.2 Quality control of correction results The fastMNN function further returns outputs that can be used to assess the quality of the batch correction. The metadata(out)$merge.info entry collects diagnostics for each individual merging step. Here, the batch.size and lost.var entries are important. The batch.size entry reports the relative magnitude of the batch effect and the lost.var entry represents the percentage of lost variance per merging step. A large batch.size and low lost.var indicate sufficient batch correction. merge_info &lt;- metadata(out)$merge.info merge_info[,c(&quot;left&quot;, &quot;right&quot;, &quot;batch.size&quot;)] ## DataFrame with 3 rows and 3 columns ## left right batch.size ## &lt;List&gt; &lt;List&gt; &lt;numeric&gt; ## 1 Patient4 Patient2 0.381635 ## 2 Patient4,Patient2 Patient1 0.581013 ## 3 Patient4,Patient2,Patient1 Patient3 0.767376 merge_info$lost.var ## Patient1 Patient2 Patient3 Patient4 ## [1,] 0.000000000 0.031154864 0.00000000 0.046198914 ## [2,] 0.043363546 0.009772150 0.00000000 0.011931892 ## [3,] 0.005394755 0.003023119 0.07219394 0.005366304 We observe that Patient4 and Patient2 are most similar with a low batch effect. Merging cells of Patient3 into the combined batch of Patient1, Patient2 and Patient4 resulted in the highest percentage of lost variance and the detection of the largest batch effect. In the next paragraph we can visualize the correction results. 8.1.3 Visualization The simplest option to check if the sample effects were corrected is by using non-linear dimensionality reduction techniques and observe mixing of cells across samples. We will recompute the UMAP embedding using the corrected low-dimensional coordinates for each cell. library(scater) set.seed(220228) spe &lt;- runUMAP(spe, dimred= &quot;fastMNN&quot;, name = &quot;UMAP_mnnCorrected&quot;) Next, we visualize the corrected UMAP while overlaying patient IDs. library(cowplot) library(dittoSeq) library(viridis) # visualize patient id p1 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP before correction&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP after correction&quot;) plot_grid(p1, p2) We observe an imperfect merging of Patient3 into all other samples. This was already seen when displaying the merging information above. We now also visualize the expression of selected markers across all cells before and after batch correction. markers &lt;- c(&quot;Ecad&quot;, &quot;CD45RO&quot;, &quot;CD20&quot;, &quot;CD3&quot;, &quot;FOXP3&quot;, &quot;CD206&quot;, &quot;MPO&quot;, &quot;SMA&quot;, &quot;Ki67&quot;) # Before correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) # After correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP_mnnCorrected&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) We observe that immune cells across patients are merged after batch correction using fastMNN. However, the tumor cells of different patients still cluster separately. 8.2 harmony correction The harmony algorithm performs batch correction by iteratively clustering and correcting the positions of cells in PCA space (Korsunsky et al. 2019). We will first perform PCA on the asinh-transformed counts and then call the RunHarmony function to perform data integration. Paper: Fast, sensitive and accurate integration of single-cell data with Harmony Documentation: harmony Similar to the fastMNN function, harmony returns the corrected low-dimensional coordinates for each cell. These can be transfered to the reducedDim slot of the original SpatialExperiment object. library(harmony) library(BiocSingular) spe &lt;- runPCA(spe, subset_row = rowData(spe)$use_channel, exprs_values = &quot;exprs&quot;, ncomponents = 30, BSPARAM = ExactParam()) set.seed(230616) out &lt;- RunHarmony(spe, group.by.vars = &quot;patient_id&quot;) # Check that order of cells is the same stopifnot(all.equal(colnames(spe), colnames(out))) reducedDim(spe, &quot;harmony&quot;) &lt;- reducedDim(out, &quot;HARMONY&quot;) The computational time of the HarmonyMatrix function call is 0.48 minutes. 8.2.1 Visualization We will now again visualize the cells in low dimensions after UMAP embedding. set.seed(220228) spe &lt;- runUMAP(spe, dimred = &quot;harmony&quot;, name = &quot;UMAP_harmony&quot;) # visualize patient id p1 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP before correction&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP_harmony&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP after correction&quot;) plot_grid(p1, p2) And we visualize selected marker expression as defined above. # Before correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) # After correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP_harmony&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) We observe a more aggressive merging of cells from different patients compared to the results after fastMNN correction. Importantly, immune cell and epithelial markers are expressed in distinct regions of the UMAP. 8.3 Seurat correction The Seurat package provides a number of functionalities to analyze single-cell data. As such it also allows the integration of cells across different samples. Conceptually, Seurat performs batch correction similarly to fastMNN by finding mutual nearest neighbors (MNN) in low dimensional space before correcting the expression values of cells (Stuart et al. 2019). Paper: Comprehensive Integration of Single-Cell Data Documentation: Seurat To use Seurat, we will first create a Seurat object from the SpatialExperiment object and add relevant metadata. The object also needs to be split by patient prior to integration. library(Seurat) library(SeuratObject) seurat_obj &lt;- as.Seurat(spe, counts = &quot;counts&quot;, data = &quot;exprs&quot;) seurat_obj &lt;- AddMetaData(seurat_obj, as.data.frame(colData(spe))) seurat.list &lt;- SplitObject(seurat_obj, split.by = &quot;patient_id&quot;) To avoid long run times, we will use an approach that relies on reciprocal PCA instead of canonical correlation analysis for dimensionality reduction and initial alignment. For an extended tutorial on how to use Seurat for data integration, please refer to their vignette. We will first define the features used for integration and perform PCA on cells of each patient individually. The FindIntegrationAnchors function detects MNNs between cells of different patients and the IntegrateData function corrects the expression values of cells. We slightly increase the number of neighbors to be considered for MNN detection (the k.anchor parameter). This increases the integration strength. features &lt;- rownames(spe)[rowData(spe)$use_channel] seurat.list &lt;- lapply(X = seurat.list, FUN = function(x) { x &lt;- ScaleData(x, features = features, verbose = FALSE) x &lt;- RunPCA(x, features = features, verbose = FALSE, approx = FALSE) return(x) }) anchors &lt;- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features, reduction = &quot;rpca&quot;, k.anchor = 20) combined &lt;- IntegrateData(anchorset = anchors) We now select the integrated assay and perform PCA dimensionality reduction. The cell coordinates in PCA reduced space can then be transferred to the original SpatialExperiment object. Of note: by splitting the object into individual batch-specific objects, the ordering of cells in the integrated object might not match the ordering of cells in the input object. In this case, columns will need to be reordered. Here, we test if the ordering of cells in the integrated Seurat object matches the ordering of cells in the main SpatialExperiment object. DefaultAssay(combined) &lt;- &quot;integrated&quot; combined &lt;- ScaleData(combined, verbose = FALSE) combined &lt;- RunPCA(combined, npcs = 30, verbose = FALSE, approx = FALSE) # Check that order of cells is the same stopifnot(all.equal(colnames(spe), colnames(combined))) reducedDim(spe, &quot;seurat&quot;) &lt;- Embeddings(combined, reduction = &quot;pca&quot;) The computational time of the Seurat function calls is 2.87 minutes. 8.3.1 Visualization As above, we recompute the UMAP embeddings based on Seurat integrated results and visualize the embedding. set.seed(220228) spe &lt;- runUMAP(spe, dimred = &quot;seurat&quot;, name = &quot;UMAP_seurat&quot;) Visualize patient IDs. # visualize patient id p1 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP before correction&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP_seurat&quot;, size = 0.2) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + ggtitle(&quot;Patient ID on UMAP after correction&quot;) plot_grid(p1, p2) Visualization of marker expression. # Before correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) # After correction plot_list &lt;- multi_dittoDimPlot(spe, var = markers, reduction.use = &quot;UMAP_seurat&quot;, assay = &quot;exprs&quot;, size = 0.2, list.out = TRUE) plot_list &lt;- lapply(plot_list, function(x) x + scale_color_viridis()) plot_grid(plotlist = plot_list) Similar to the methods presented above, Seurat integrates immune cells correctly. When visualizing the patient IDs, slight patient-to-patient differences within tumor cells can be detected. Choosing the correct integration approach is challenging without having ground truth cell labels available. It is recommended to compare different techniques and different parameter settings. Please refer to the documentation of the individual tools to become familiar with the possible parameter choices. Furthermore, in the following section, we will discuss clustering and classification approaches in light of expression differences between samples. In general, it appears that MNN-based approaches are less conservative in terms of merging compared to harmony. On the other hand, harmony could well merge cells in a way that regresses out biological signals. 8.4 Save objects The modified SpatialExperiment object is saved for further downstream analysis. saveRDS(spe, &quot;data/spe.rds&quot;) 8.5 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 Seurat_5.0.1 ## [3] SeuratObject_5.0.1 sp_2.1-2 ## [5] BiocSingular_1.18.0 harmony_1.2.0 ## [7] Rcpp_1.0.11 viridis_0.6.4 ## [9] viridisLite_0.4.2 dittoSeq_1.14.0 ## [11] cowplot_1.1.2 scater_1.30.1 ## [13] ggplot2_3.4.4 scuttle_1.12.0 ## [15] SpatialExperiment_1.12.0 batchelor_1.18.1 ## [17] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0 ## [19] Biobase_2.62.0 GenomicRanges_1.54.1 ## [21] GenomeInfoDb_1.38.5 IRanges_2.36.0 ## [23] S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [25] MatrixGenerics_1.14.0 matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] RcppAnnoy_0.0.21 splines_4.3.2 ## [3] later_1.3.2 bitops_1.0-7 ## [5] tibble_3.2.1 polyclip_1.10-6 ## [7] fastDummies_1.7.3 lifecycle_1.0.4 ## [9] rprojroot_2.0.4 globals_0.16.2 ## [11] lattice_0.21-9 MASS_7.3-60 ## [13] magrittr_2.0.3 plotly_4.10.3 ## [15] sass_0.4.8 rmarkdown_2.25 ## [17] jquerylib_0.1.4 yaml_2.3.8 ## [19] httpuv_1.6.13 sctransform_0.4.1 ## [21] spam_2.10-0 spatstat.sparse_3.0-3 ## [23] reticulate_1.34.0 pbapply_1.7-2 ## [25] RColorBrewer_1.1-3 ResidualMatrix_1.12.0 ## [27] pkgload_1.3.3 abind_1.4-5 ## [29] zlibbioc_1.48.0 Rtsne_0.17 ## [31] purrr_1.0.2 RCurl_1.98-1.13 ## [33] GenomeInfoDbData_1.2.11 ggrepel_0.9.4 ## [35] irlba_2.3.5.1 spatstat.utils_3.0-4 ## [37] listenv_0.9.0 pheatmap_1.0.12 ## [39] goftest_1.2-3 RSpectra_0.16-1 ## [41] spatstat.random_3.2-2 fitdistrplus_1.1-11 ## [43] parallelly_1.36.0 DelayedMatrixStats_1.24.0 ## [45] leiden_0.4.3.1 codetools_0.2-19 ## [47] DelayedArray_0.28.0 tidyselect_1.2.0 ## [49] farver_2.1.1 ScaledMatrix_1.10.0 ## [51] spatstat.explore_3.2-5 jsonlite_1.8.8 ## [53] BiocNeighbors_1.20.1 ellipsis_0.3.2 ## [55] progressr_0.14.0 ggridges_0.5.5 ## [57] survival_3.5-7 tools_4.3.2 ## [59] ica_1.0-3 glue_1.6.2 ## [61] gridExtra_2.3 SparseArray_1.2.3 ## [63] xfun_0.41 dplyr_1.1.4 ## [65] withr_2.5.2 fastmap_1.1.1 ## [67] fansi_1.0.6 digest_0.6.33 ## [69] rsvd_1.0.5 R6_2.5.1 ## [71] mime_0.12 colorspace_2.1-0 ## [73] scattermore_1.2 tensor_1.5 ## [75] spatstat.data_3.0-3 RhpcBLASctl_0.23-42 ## [77] utf8_1.2.4 tidyr_1.3.0 ## [79] generics_0.1.3 data.table_1.14.10 ## [81] httr_1.4.7 htmlwidgets_1.6.4 ## [83] S4Arrays_1.2.0 uwot_0.1.16 ## [85] pkgconfig_2.0.3 gtable_0.3.4 ## [87] lmtest_0.9-40 XVector_0.42.0 ## [89] brio_1.1.4 htmltools_0.5.7 ## [91] dotCall64_1.1-1 bookdown_0.37 ## [93] scales_1.3.0 png_0.1-8 ## [95] knitr_1.45 reshape2_1.4.4 ## [97] rjson_0.2.21 nlme_3.1-163 ## [99] cachem_1.0.8 zoo_1.8-12 ## [101] stringr_1.5.1 KernSmooth_2.23-22 ## [103] parallel_4.3.2 miniUI_0.1.1.1 ## [105] vipor_0.4.7 desc_1.4.3 ## [107] pillar_1.9.0 grid_4.3.2 ## [109] vctrs_0.6.5 RANN_2.6.1 ## [111] promises_1.2.1 beachmat_2.18.0 ## [113] xtable_1.8-4 cluster_2.1.4 ## [115] waldo_0.5.2 beeswarm_0.4.0 ## [117] evaluate_0.23 magick_2.8.2 ## [119] cli_3.6.2 compiler_4.3.2 ## [121] rlang_1.1.2 crayon_1.5.2 ## [123] future.apply_1.11.1 labeling_0.4.3 ## [125] plyr_1.8.9 ggbeeswarm_0.7.2 ## [127] stringi_1.8.3 deldir_2.0-2 ## [129] BiocParallel_1.36.0 munsell_0.5.0 ## [131] lazyeval_0.2.2 spatstat.geom_3.2-7 ## [133] Matrix_1.6-4 RcppHNSW_0.5.0 ## [135] patchwork_1.1.3 sparseMatrixStats_1.14.0 ## [137] future_1.33.1 shiny_1.8.0 ## [139] highr_0.10 ROCR_1.0-11 ## [141] igraph_1.6.0 bslib_0.6.1 References "],["cell-phenotyping.html", "9 Cell phenotyping 9.1 Load data 9.2 Clustering approaches 9.3 Classification approach 9.4 Session Info", " 9 Cell phenotyping A common step during single-cell data analysis is the annotation of cells based on their phenotype. Defining cell phenotypes is often subjective and relies on previous biological knowledge. The Orchestrating Single Cell Analysis with Bioconductor book presents a number of approaches to phenotype cells detected by single-cell RNA sequencing based on reference datasets or gene set analysis. In highly-multiplexed imaging, target proteins or molecules are manually selected based on the biological question at hand. It narrows down the feature space and facilitates the manual annotation of clusters to derive cell phenotypes. We will therefore discuss and compare a number of clustering approaches to group cells based on their similarity in marker expression in Section 9.2. Unlike single-cell RNA sequencing or CyTOF data, single-cell data derived from highly-multiplexed imaging data often suffers from “lateral spillover” between neighboring cells. This spillover caused by imperfect segmentation often hinders accurate clustering to define specific cell phenotypes in multiplexed imaging data. Tools have been developed to correct lateral spillover between cells (Bai et al. 2021) but the approach requires careful selection of the markers to correct. In Section 9.3 we will train and apply a random forest classifier to classify cell phenotypes in the dataset as alternative approach to clustering-based cell phenotyping. This approach has been previously used to identify major cell phenotypes in metastatic melanoma and avoids clustering of cells (Hoch et al. 2022). 9.1 Load data We will first read in the previously generated SpatialExperiment object and sample 2000 cells to visualize cluster membership. library(SpatialExperiment) spe &lt;- readRDS(&quot;data/spe.rds&quot;) # Sample cells set.seed(220619) cur_cells &lt;- sample(seq_len(ncol(spe)), 2000) 9.2 Clustering approaches In the first section, we will present clustering approaches to identify cellular phenotypes in the dataset. These methods group cells based on their similarity in marker expression or by their proximity in low dimensional space. A number of approaches have been developed to cluster data derived from single-cell RNA sequencing technologies (Yu et al. 2022) or CyTOF (Weber and Robinson 2016). For demonstration purposes, we will highlight common clustering approaches that are available in R and have been used for clustering cells obtained from IMC. Two approaches rely on graph-based clustering and one approach uses self organizing maps (SOM). 9.2.1 Rphenograph The PhenoGraph clustering approach was first described to group cells of a CyTOF dataset (Levine et al. 2015). The algorithm first constructs a graph by detecting the k nearest neighbours based on euclidean distance in expression space. In the next step, edges between nodes (cells) are weighted by their overlap in nearest neighbor sets. To quantify the overlap in shared nearest neighbor sets, the jaccard index is used. The Louvain modularity optimization approach is used to detect connected communities and partition the graph into clusters of cells. This clustering strategy was used by Jackson, Fischer et al. and Schulz et al. to cluster IMC data (Jackson et al. 2020; Schulz et al. 2018). There are several different PhenoGraph implementations available in R. Here, we use the one available at https://github.com/i-cyto/Rphenograph. For large datasets, https://github.com/stuchly/Rphenoannoy offers a more performant implementation of the algorithm. In the following code chunk, we select the asinh-transformed mean pixel intensities per cell and channel and subset the channels to the ones containing biological variation. This matrix is transposed to store cells in rows. Within the Rphenograph function, we select the 45 nearest neighbors for graph building and louvain community detection (default). The function returns a list of length 2, the first entry being the graph and the second entry containing the community object. Calling membership on the community object will return cluster IDs for each cell. These cluster IDs are then stored within the colData of the SpatialExperiment object. Cluster IDs are mapped on top of the UMAP embedding and single-cell marker expression within each cluster are visualized in form of a heatmap. It is recommended to test different inputs to k as shown in the next section. Selecting larger values for k results in larger clusters. library(Rphenograph) library(igraph) library(dittoSeq) library(viridis) mat &lt;- t(assay(spe, &quot;exprs&quot;)[rowData(spe)$use_channel,]) set.seed(230619) out &lt;- Rphenograph(mat, k = 45) clusters &lt;- factor(membership(out[[2]])) spe$pg_clusters &lt;- clusters dittoDimPlot(spe, var = &quot;pg_clusters&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;Phenograph clusters on UMAP&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;pg_clusters&quot;, &quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters))], metadata(spe)$color_vectors$patient_id)) The Rphenograph function call took 1.41 minutes. We can observe that some of the clusters only contain cells of a single patient. This can often be observed in the tumor compartment. In the next step, we use the integrated cells (see Section 8) in low dimensional embedding for clustering. Here, the low dimensional embedding can be directly accessed from the reducedDim slot. mat &lt;- reducedDim(spe, &quot;fastMNN&quot;) set.seed(230619) out &lt;- Rphenograph(mat, k = 45) clusters &lt;- factor(membership(out[[2]])) spe$pg_clusters_corrected &lt;- clusters dittoDimPlot(spe, var = &quot;pg_clusters_corrected&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;Phenograph clusters on UMAP, integrated cells&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;pg_clusters_corrected&quot;,&quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))], metadata(spe)$color_vectors$patient_id)) Clustering using the integrated embedding leads to clusters that contain cells of different patients. Cluster annotation can now be performed by manually labeling cells based on their marker expression (see Notes in Section 9.2.5). 9.2.2 Shared nearest neighbour graph The bluster package provides a simple interface to cluster cells using a number of different clustering approaches and different metrics to access cluster stability. For simplicity, we will focus on graph based clustering as this is the most popular and a fast method for single-cell clustering. The bluster package provides functionalities to build k-nearest neighbor (KNN) graphs and its weighted version, shared nearest neighbor (SNN) graphs where nodes represent cells. The user can chose the number of neighbors to consider (parameter k), the edge weighting method (parameter type) and the community detection function to use (parameter cluster.fun). As all parameters affect the clustering results, the bluster package provides the clusterSweep function to test a number of parameter settings in parallel. In the following code chunk, we select the asinh-transformed mean pixel intensities and subset the markers of interest. The resulting matrix is transposed to fit to the requirements of the bluster package (cells in rows). We test two different settings for k, two for type and fix the cluster.fun to louvain as this is one of the most common approaches for community detection. This function call is parallelized by setting the BPPARAM parameter. library(bluster) library(BiocParallel) library(ggplot2) mat &lt;- t(assay(spe, &quot;exprs&quot;)[rowData(spe)$use_channel,]) combinations &lt;- clusterSweep(mat, BLUSPARAM=SNNGraphParam(), k=c(10L, 20L), type = c(&quot;rank&quot;, &quot;jaccard&quot;), cluster.fun = &quot;louvain&quot;, BPPARAM = MulticoreParam(RNGseed = 220427)) We next calculate two metrics to estimate cluster stability: the average silhouette width and the neighborhood purity. We use the approxSilhouette function to compute the silhouette width for each cell and compute the average across all cells per parameter setting. Please see ?silhouette for more information on how the silhouette width is computed for each cell. A large average silhouette width indicates a cluster parameter setting for which cells that are well clustered. The neighborPurity function computes the fraction of cells around each cell with the same cluster ID. Per parameter setting, we compute the average neighborhood purity across all cells. A large average neighborhood purity indicates a cluster parameter setting for which cells that are well clustered. sil &lt;- vapply(as.list(combinations$clusters), function(x) mean(approxSilhouette(mat, x)$width), 0) ggplot(data.frame(method = names(sil), sil = sil)) + geom_point(aes(method, sil)) + theme_classic(base_size = 15) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab(&quot;Cluster parameter combination&quot;) + ylab(&quot;Average silhouette width&quot;) pur &lt;- vapply(as.list(combinations$clusters), function(x) mean(neighborPurity(mat, x)$purity), 0) ggplot(data.frame(method = names(pur), pur = pur)) + geom_point(aes(method, pur)) + theme_classic(base_size = 15) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + xlab(&quot;Cluster parameter combination&quot;) + ylab(&quot;Average neighborhood purity&quot;) The cluster parameter sweep took 4.13 minutes. Performing a cluster sweep takes some time as multiple function calls are run in parallel. We do however recommend testing a number of different parameter settings to assess clustering performance. Once parameter settings are known, we can either use the clusterRows function of the bluster package to cluster cells or its convenient wrapper function exported by the scran package. The scran::clusterCells function accepts a SpatialExperiment (or SingleCellExperiment) object which stores cells in columns. By default, the function detects the 10 nearest neighbours for each cell, performs rank-based weighting of edges (see ?makeSNNGraph for more information) and uses the cluster_walktrap function to detect communities in the graph. As we can see above, the clustering approach in this dataset with k being 20 and rank-based edge weighting leads to the highest silhouette width and highest neighborhood purity. library(scran) set.seed(220620) clusters &lt;- clusterCells(spe[rowData(spe)$use_channel,], assay.type = &quot;exprs&quot;, BLUSPARAM = SNNGraphParam(k=20, cluster.fun = &quot;louvain&quot;, type = &quot;rank&quot;)) spe$nn_clusters &lt;- clusters dittoDimPlot(spe, var = &quot;nn_clusters&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;SNN clusters on UMAP&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;nn_clusters&quot;, &quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters))], metadata(spe)$color_vectors$patient_id)) The shared nearest neighbor graph clustering approach took 0.99 minutes. This function was used by (Tietscher et al. 2022) to cluster cells obtained by IMC. Setting type = \"jaccard\" performs clustering similar to Rphenograph above and Seurat. Similar to the results obtained by Rphenograph, some of the clusters are patient-specific. We can now perform clustering of the integrated cells by directly specifying which low-dimensional embedding to use: set.seed(220621) clusters &lt;- clusterCells(spe, use.dimred = &quot;fastMNN&quot;, BLUSPARAM = SNNGraphParam(k = 20, cluster.fun = &quot;louvain&quot;, type = &quot;rank&quot;)) spe$nn_clusters_corrected &lt;- clusters dittoDimPlot(spe, var = &quot;nn_clusters_corrected&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;SNN clusters on UMAP, integrated cells&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;nn_clusters_corrected&quot;,&quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters_corrected))], metadata(spe)$color_vectors$patient_id)) 9.2.3 Self organizing maps An alternative to graph-based clustering is offered by the CATALYST package. The cluster function internally uses the FlowSOM package to group cells into 100 (default) clusters based on self organizing maps (SOM). In the next step, the ConsensusClusterPlus package is used to perform hierarchical consensus clustering of the previously detected 100 SOM nodes into 2 to maxK clusters. Cluster stability for each k can be assessed by plotting the delta_area(spe). The optimal number of clusters can be found by selecting the k at which a plateau is reached. In the example below, an optimal k lies somewhere around 13. library(CATALYST) # Run FlowSOM and ConsensusClusterPlus clustering set.seed(220410) spe &lt;- cluster(spe, features = rownames(spe)[rowData(spe)$use_channel], maxK = 30) # Assess cluster stability delta_area(spe) spe$som_clusters &lt;- cluster_ids(spe, &quot;meta13&quot;) dittoDimPlot(spe, var = &quot;som_clusters&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;SOM clusters on UMAP&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;som_clusters&quot;, &quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters))], metadata(spe)$color_vectors$patient_id)) Running FlowSOM clustering took 0.16 minutes. The CATALYST package does not provide functionality to perform FlowSOM and ConsensusClusterPlus clustering directly on the batch-corrected, integrated cells. As an alternative to the CATALYST package, the bluster package provides SOM clustering when specifying the SomParam() parameter. Similar to the CATALYST approach, we will first cluster the dataset into 100 clusters (also called “codes”). These codes are then further clustered into a maximum of 30 clusters using ConsensusClusterPlus (using hierarchical clustering and euclidean distance). The delta area plot can be accessed using the (not exported) .plot_delta_area function from CATALYST. Here, it seems that the plateau is reached at a k of 16 and we will store the final cluster IDs within the SpatialExperiment object. library(kohonen) library(ConsensusClusterPlus) # Select integrated cells mat &lt;- reducedDim(spe, &quot;fastMNN&quot;) # Perform SOM clustering set.seed(220410) som.out &lt;- clusterRows(mat, SomParam(100), full = TRUE) # Cluster the 100 SOM codes into larger clusters ccp &lt;- ConsensusClusterPlus(t(som.out$objects$som$codes[[1]]), maxK = 30, reps = 100, distance = &quot;euclidean&quot;, seed = 220410, plot = NULL) # Visualize delta area plot CATALYST:::.plot_delta_area(ccp) # Link ConsensusClusterPlus clusters with SOM codes and save in object som.cluster &lt;- ccp[[16]][[&quot;consensusClass&quot;]][som.out$clusters] spe$som_clusters_corrected &lt;- as.factor(som.cluster) dittoDimPlot(spe, var = &quot;som_clusters_corrected&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, do.label = TRUE) + ggtitle(&quot;SOM clusters on UMAP, integrated cells&quot;) dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$use_channel], assay = &quot;exprs&quot;, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;som_clusters_corrected&quot;,&quot;patient_id&quot;), annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters_corrected))], metadata(spe)$color_vectors$patient_id)) The FlowSOM clustering approach has been used by (Hoch et al. 2022) to sub-cluster tumor cells as measured by IMC. 9.2.4 Compare between clustering approaches Finally, we can compare the results of different clustering approaches. For this, we visualize the number of cells that are shared between different clustering results in a pairwise fashion. In the following heatmaps a high match between clustering results can be seen for those clusters that are uniquely detected in both approaches. First, we will visualize the match between the three different approaches applied to the asinh-transformed counts. library(patchwork) library(pheatmap) library(gridExtra) tab1 &lt;- table(paste(&quot;Rphenograph&quot;, spe$pg_clusters), paste(&quot;SNN&quot;, spe$nn_clusters)) tab2 &lt;- table(paste(&quot;Rphenograph&quot;, spe$pg_clusters), paste(&quot;SOM&quot;, spe$som_clusters)) tab3 &lt;- table(paste(&quot;SNN&quot;, spe$nn_clusters), paste(&quot;SOM&quot;, spe$som_clusters)) pheatmap(log10(tab1 + 10), color = viridis(100)) pheatmap(log10(tab2 + 10), color = viridis(100)) pheatmap(log10(tab3 + 10), color = viridis(100)) We observe that Rphenograph and the shared nearest neighbor (SNN) approach by scran show similar results (first heatmap above). For example, Rphenograph cluster 20 (a tumor cluster) is perfectly captured by SNN cluster 12. On the other hand, the Neutrophil cluster (SNN cluster 6) is split into Rphenograph cluster 2 and Rphenograph cluster 6. A common approach is to now merge clusters that contain similar cell types and annotate them by hand (see below). Below, a comparison between the clustering results of the integrated cells is shown. tab1 &lt;- table(paste(&quot;Rphenograph&quot;, spe$pg_clusters_corrected), paste(&quot;SNN&quot;, spe$nn_clusters_corrected)) tab2 &lt;- table(paste(&quot;Rphenograph&quot;, spe$pg_clusters_corrected), paste(&quot;SOM&quot;, spe$som_clusters_corrected)) tab3 &lt;- table(paste(&quot;SNN&quot;, spe$nn_clusters_corrected), paste(&quot;SOM&quot;, spe$som_clusters_corrected)) pheatmap(log10(tab1 + 10), color = viridis(100)) pheatmap(log10(tab2 + 10), color = viridis(100)) pheatmap(log10(tab3 + 10), color = viridis(100)) In comparison to clustering on the non-integrated cells, the clustering results of the integrated cells show higher overlap. The SNN approach resulted in fewer clusters and therefore matches better with the SOM clustering approach. 9.2.5 Further clustering notes The bluster package provides a number of metrics to assess cluster stability here. For brevity we only highlighted the use of the silhouette width and the neighborhood purity but different metrics should be tested to assess cluster stability. To assign cell types to clusters, we manually annotate clusters based on their marker expression. For example, SNN cluster 12 (clustering of the integrated cells) shows high, homogeneous expression of CD20 and we might therefore label this cluster as B cells. The next chapter 10 will highlight single-cell visualization methods that can be helpful for manual cluster annotations. An example how to label clusters can be seen below: library(dplyr) cluster_celltype &lt;- recode(spe$nn_clusters_corrected, &quot;1&quot; = &quot;Tumor_proliferating&quot;, &quot;2&quot; = &quot;Myeloid&quot;, &quot;3&quot; = &quot;Tumor&quot;, &quot;4&quot; = &quot;Tumor&quot;, &quot;5&quot; = &quot;Stroma&quot;, &quot;6&quot; = &quot;Proliferating&quot;, &quot;7&quot; = &quot;Myeloid&quot;, &quot;8&quot; = &quot;Plasma_cell&quot;, &quot;9&quot; = &quot;CD8&quot;, &quot;10&quot; = &quot;CD4&quot;, &quot;11&quot; = &quot;Neutrophil&quot;, &quot;12&quot; = &quot;Bcell&quot;, &quot;13&quot; = &quot;Stroma&quot;) spe$cluster_celltype &lt;- cluster_celltype 9.3 Classification approach In this section, we will highlight a cell type classification approach based on ground truth labeling and random forest classification. The rational for this supervised cell phenotyping approach is to use the information contained in the pre-defined markers to detect cells of interest. This approach was used by Hoch et al. to classify cell types in a metastatic melanoma IMC dataset (Hoch et al. 2022). The antibody panel used in the example data set mainly focuses on immune cell types and little on tumor cell phenotypes. Therefore we will label the following cell types: Tumor (E-cadherin positive) Stroma (SMA, PDGFRb positive) Plasma cells (CD38 positive) Neutrophil (MPO, CD15 positive) Myeloid cells (HLADR positive) B cells (CD20 positive) B next to T cells (CD20, CD3 positive) Regulatory T cells (FOXP3 positive) CD8+ T cells (CD3, CD8 positive) CD4+ T cells (CD3, CD4 positive) The “B next to T cell” phenotype (BnTcell) is commonly observed in immune infiltrated regions measured by IMC. We include this phenotype to account for B cell/T cell interactions where precise classification into B cells or T cells is not possible. The exact gating scheme can be seen at img/Gating_scheme.pdf. As related approaches, Astir and Garnett use pre-defined panel information to classify cell phenotypes based on their marker expression. 9.3.1 Manual labeling of cells The cytomapper package provides the cytomapperShiny function that allows gating of cells based on their marker expression and visualization of selected cells directly on the images. library(cytomapper) if (interactive()) { images &lt;- readRDS(&quot;data/images.rds&quot;) masks &lt;- readRDS(&quot;data/masks.rds&quot;) cytomapperShiny(object = spe, mask = masks, image = images, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;) } The labeled cells for this data set can be accessed at 10.5281/zenodo.6554544 and were downloaded in Section 4. Gating is performed per image and the cytomapperShiny function allows the export of gated cells in form of a SingleCellExperiment or SpatialExperiment object. The cell label is stored in colData(object)$cytomapper_CellLabel and the gates are stored in metadata(object). In the next section, we will read in and consolidate the labeled data. 9.3.2 Define color vectors For consistent visualization of cell types, we will now pre-define their colors: celltype &lt;- setNames(c(&quot;#3F1B03&quot;, &quot;#F4AD31&quot;, &quot;#894F36&quot;, &quot;#1C750C&quot;, &quot;#EF8ECC&quot;, &quot;#6471E2&quot;, &quot;#4DB23B&quot;, &quot;grey&quot;, &quot;#F4800C&quot;, &quot;#BF0A3D&quot;, &quot;#066970&quot;), c(&quot;Tumor&quot;, &quot;Stroma&quot;, &quot;Myeloid&quot;, &quot;CD8&quot;, &quot;Plasma_cell&quot;, &quot;Treg&quot;, &quot;CD4&quot;, &quot;undefined&quot;, &quot;BnTcell&quot;, &quot;Bcell&quot;, &quot;Neutrophil&quot;)) metadata(spe)$color_vectors$celltype &lt;- celltype 9.3.3 Read in and consolidate labeled data Here, we will read in the individual SpatialExperiment objects containing the labeled cells and concatenate them. In the process of concatenating the SpatialExperiment objects along their columns, the sample_id entry is appended by .1, .2, .3, ... due to replicated entries. library(SingleCellExperiment) label_files &lt;- list.files(&quot;data/gated_cells&quot;, full.names = TRUE, pattern = &quot;.rds$&quot;) # Read in SPE objects spes &lt;- lapply(label_files, readRDS) # Merge SPE objects concat_spe &lt;- do.call(&quot;cbind&quot;, spes) In the following code chunk we will identify cells that were labeled multiple times. This occurs when different cell phenotypes are gated per image and can affect immune cells that are located inside the tumor compartment. We will first identify those cells that were uniquely labeled. In the next step, we will identify those cells that were labeled twice AND were labeled as Tumor cells. These cells will be assigned their immune cell label. Finally, we will save the unique labels within the original SpatialExperiment object. Of note: this concatenation strategy is specific for cell phenotypes contained in this example dataset. The gated cell labels might need to be processed in a slightly different way when working with other samples. For these tasks, we will define a filter function: filter_labels &lt;- function(object, label = &quot;cytomapper_CellLabel&quot;) { cur_tab &lt;- unclass(table(colnames(object), object[[label]])) cur_labels &lt;- colnames(cur_tab)[apply(cur_tab, 1, which.max)] names(cur_labels) &lt;- rownames(cur_tab) cur_labels &lt;- cur_labels[rowSums(cur_tab) == 1] return(cur_labels) } This function is now applied to all cells and then only non-tumor cells. labels &lt;- filter_labels(concat_spe) cur_spe &lt;- concat_spe[,concat_spe$cytomapper_CellLabel != &quot;Tumor&quot;] non_tumor_labels &lt;- filter_labels(cur_spe) additional_cells &lt;- setdiff(names(non_tumor_labels), names(labels)) final_labels &lt;- c(labels, non_tumor_labels[additional_cells]) # Transfer labels to SPE object spe_labels &lt;- rep(&quot;unlabeled&quot;, ncol(spe)) names(spe_labels) &lt;- colnames(spe) spe_labels[names(final_labels)] &lt;- final_labels spe$cell_labels &lt;- spe_labels # Number of cells labeled per patient table(spe$cell_labels, spe$patient_id) ## ## Patient1 Patient2 Patient3 Patient4 ## Bcell 152 131 234 263 ## BnTcell 396 37 240 1029 ## CD4 45 342 167 134 ## CD8 60 497 137 128 ## Myeloid 183 378 672 517 ## Neutrophil 97 4 17 16 ## Plasma_cell 34 536 87 59 ## Stroma 84 37 85 236 ## Treg 139 149 49 24 ## Tumor 2342 906 1618 1133 ## unlabeled 7214 9780 7826 9580 Based on these labels, we can now train a random forest classifier to classify all remaining, unlabeled cells. 9.3.4 Train classifier In this section, we will use the caret framework for machine learning in R. This package provides an interface to train a number of regression and classification models in a coherent fashion. We use a random forest classifier due to low number of parameters, high speed and an observed high performance for cell type classification (Hoch et al. 2022). In the following section, we will first split the SpatialExperiment object into labeled and unlabeled cells. Based on the labeled cells, we split the data into a train (75% of the data) and test (25% of the data) dataset. We currently do not provide an independently labeled validation dataset. The caret package provides the trainControl function, which specifies model training parameters and the train function, which performs the actual model training. While training the model, we also want to estimate the best model parameters. In the case of the chosen random forest model (method = \"rf\"), we only need to estimate a single parameters (mtry) which corresponds to the number of variables randomly sampled as candidates at each split. To estimate the best parameter, we will perform a 5-fold cross validation (set within trainControl) over a tune length of 5 entries to mtry. In the following code chunk, the createDataPartition and the train function are not deterministic, meaning they return different results across different runs. We therefore set a seed here for both functions. library(caret) # Split between labeled and unlabeled cells lab_spe &lt;- spe[,spe$cell_labels != &quot;unlabeled&quot;] unlab_spe &lt;- spe[,spe$cell_labels == &quot;unlabeled&quot;] # Randomly split into train and test data set.seed(221029) trainIndex &lt;- createDataPartition(factor(lab_spe$cell_labels), p = 0.75) train_spe &lt;- lab_spe[,trainIndex$Resample1] test_spe &lt;- lab_spe[,-trainIndex$Resample1] # Define fit parameters for 5-fold cross validation fitControl &lt;- trainControl(method = &quot;cv&quot;, number = 5) # Select the arsinh-transformed counts for training cur_mat &lt;- t(assay(train_spe, &quot;exprs&quot;)[rowData(train_spe)$use_channel,]) # Train a random forest classifier rffit &lt;- train(x = cur_mat, y = factor(train_spe$cell_labels), method = &quot;rf&quot;, ntree = 1000, tuneLength = 5, trControl = fitControl) rffit ## Random Forest ## ## 10049 samples ## 37 predictor ## 10 classes: &#39;Bcell&#39;, &#39;BnTcell&#39;, &#39;CD4&#39;, &#39;CD8&#39;, &#39;Myeloid&#39;, &#39;Neutrophil&#39;, &#39;Plasma_cell&#39;, &#39;Stroma&#39;, &#39;Treg&#39;, &#39;Tumor&#39; ## ## No pre-processing ## Resampling: Cross-Validated (5 fold) ## Summary of sample sizes: 8040, 8039, 8038, 8038, 8041 ## Resampling results across tuning parameters: ## ## mtry Accuracy Kappa ## 2 0.9643726 0.9524051 ## 10 0.9780071 0.9707483 ## 19 0.9801973 0.9736577 ## 28 0.9787052 0.9716635 ## 37 0.9779095 0.9705890 ## ## Accuracy was used to select the optimal model using the largest value. ## The final value used for the model was mtry = 19. Training the classifier took 8.46 minutes. 9.3.5 Classifier performance We next observe the accuracy of the classifer when predicting cell phenotypes across the cross-validation and when applying the classifier to the test dataset. First, we can visualize the classification accuracy during parameter tuning: ggplot(rffit) + geom_errorbar(data = rffit$results, aes(ymin = Accuracy - AccuracySD, ymax = Accuracy + AccuracySD), width = 0.4) + theme_classic(base_size = 15) The best value for mtry is 19 and is used when predicting new data. It is often recommended to visualize the variable importance of the classifier. The following plot specifies which variables (markers) are most important for classifying the data. plot(varImp(rffit)) As expected, the markers that were used for gating (Ecad, CD3, CD20, HLADR, CD8a, CD38, FOXP3) were important for classification. To assess the accuracy, sensitivity, specificity, among other quality measures of the classifier, we will now predict cell phenotypes in the test data. # Select the arsinh-transformed counts of the test data cur_mat &lt;- t(assay(test_spe, &quot;exprs&quot;)[rowData(test_spe)$use_channel,]) # Predict the cell phenotype labels of the test data set.seed(231019) cur_pred &lt;- predict(rffit, newdata = cur_mat) While the overall classification accuracy can appear high, we also want to check if each cell phenotype class is correctly predicted. For this, we will calculate the confusion matrix between predicted and actual cell labels. This measure may highlight individual cell phenotype classes that were not correctly predicted by the classifier. When setting mode = \"everything\", the confusionMatrix function returns all available prediction measures including sensitivity, specificity, precision, recall and the F1 score per cell phenotype class. cm &lt;- confusionMatrix(data = cur_pred, reference = factor(test_spe$cell_labels), mode = &quot;everything&quot;) cm ## Confusion Matrix and Statistics ## ## Reference ## Prediction Bcell BnTcell CD4 CD8 Myeloid Neutrophil Plasma_cell Stroma ## Bcell 186 2 0 0 0 0 6 0 ## BnTcell 4 423 1 0 0 0 0 0 ## CD4 0 0 163 0 0 2 3 2 ## CD8 0 0 0 199 0 0 8 0 ## Myeloid 0 0 2 1 437 0 0 0 ## Neutrophil 0 0 0 0 0 30 0 0 ## Plasma_cell 1 0 3 2 0 0 158 0 ## Stroma 0 0 2 0 0 0 0 108 ## Treg 0 0 0 0 0 0 3 0 ## Tumor 4 0 1 3 0 1 1 0 ## Reference ## Prediction Treg Tumor ## Bcell 0 1 ## BnTcell 0 1 ## CD4 0 5 ## CD8 0 3 ## Myeloid 0 0 ## Neutrophil 0 0 ## Plasma_cell 1 0 ## Stroma 0 0 ## Treg 89 2 ## Tumor 0 1487 ## ## Overall Statistics ## ## Accuracy : 0.9806 ## 95% CI : (0.9753, 0.985) ## No Information Rate : 0.4481 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.9741 ## ## Mcnemar&#39;s Test P-Value : NA ## ## Statistics by Class: ## ## Class: Bcell Class: BnTcell Class: CD4 Class: CD8 ## Sensitivity 0.95385 0.9953 0.94767 0.97073 ## Specificity 0.99714 0.9979 0.99622 0.99650 ## Pos Pred Value 0.95385 0.9860 0.93143 0.94762 ## Neg Pred Value 0.99714 0.9993 0.99716 0.99809 ## Precision 0.95385 0.9860 0.93143 0.94762 ## Recall 0.95385 0.9953 0.94767 0.97073 ## F1 0.95385 0.9906 0.93948 0.95904 ## Prevalence 0.05830 0.1271 0.05142 0.06129 ## Detection Rate 0.05561 0.1265 0.04873 0.05949 ## Detection Prevalence 0.05830 0.1283 0.05232 0.06278 ## Balanced Accuracy 0.97549 0.9966 0.97195 0.98361 ## Class: Myeloid Class: Neutrophil Class: Plasma_cell ## Sensitivity 1.0000 0.909091 0.88268 ## Specificity 0.9990 1.000000 0.99779 ## Pos Pred Value 0.9932 1.000000 0.95758 ## Neg Pred Value 1.0000 0.999095 0.99340 ## Precision 0.9932 1.000000 0.95758 ## Recall 1.0000 0.909091 0.88268 ## F1 0.9966 0.952381 0.91860 ## Prevalence 0.1306 0.009865 0.05351 ## Detection Rate 0.1306 0.008969 0.04723 ## Detection Prevalence 0.1315 0.008969 0.04933 ## Balanced Accuracy 0.9995 0.954545 0.94024 ## Class: Stroma Class: Treg Class: Tumor ## Sensitivity 0.98182 0.98889 0.9920 ## Specificity 0.99938 0.99846 0.9946 ## Pos Pred Value 0.98182 0.94681 0.9933 ## Neg Pred Value 0.99938 0.99969 0.9935 ## Precision 0.98182 0.94681 0.9933 ## Recall 0.98182 0.98889 0.9920 ## F1 0.98182 0.96739 0.9927 ## Prevalence 0.03288 0.02691 0.4481 ## Detection Rate 0.03229 0.02661 0.4445 ## Detection Prevalence 0.03288 0.02810 0.4475 ## Balanced Accuracy 0.99060 0.99368 0.9933 To easily visualize these results, we can now plot the true positive rate (sensitivity) versus the false positive rate (1 - specificity). The size of the point is determined by the number of true positives divided by the total number of cells. library(tidyverse) data.frame(cm$byClass) %&gt;% mutate(class = sub(&quot;Class: &quot;, &quot;&quot;, rownames(cm$byClass))) %&gt;% ggplot() + geom_point(aes(1 - Specificity, Sensitivity, size = Detection.Rate, fill = class), shape = 21) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) + theme_classic(base_size = 15) + ylab(&quot;Sensitivity (TPR)&quot;) + xlab(&quot;1 - Specificity (FPR)&quot;) We observe high sensitivity and specificity for most cell types. Plasma cells show the lowest true positive rate with 88% being sufficiently high. Finally, to observe which cell phenotypes were wrongly classified, we can visualize the distribution of classification probabilities per cell phenotype class: set.seed(231019) cur_pred &lt;- predict(rffit, newdata = cur_mat, type = &quot;prob&quot;) cur_pred$truth &lt;- factor(test_spe$cell_labels) cur_pred %&gt;% pivot_longer(cols = Bcell:Tumor) %&gt;% ggplot() + geom_boxplot(aes(x = name, y = value, fill = name), outlier.size = 0.5) + facet_wrap(. ~ truth, ncol = 1) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) + theme(panel.background = element_blank(), axis.text.x = element_text(angle = 45, hjust = 1)) The boxplots indicate the classification probabilities per class. The classifier is well trained if classification probabilities are only high for the one specific class. 9.3.6 Classification of new data In the final section, we will now use the tuned and tested random forest classifier to predict the cell phenotypes of the unlabeled data. First, we predict the cell phenotypes and extract their classification probabilities. # Select the arsinh-transformed counts of the unlabeled data for prediction cur_mat &lt;- t(assay(unlab_spe, &quot;exprs&quot;)[rowData(unlab_spe)$use_channel,]) # Predict the cell phenotype labels of the unlabeled data set.seed(231014) cell_class &lt;- as.character(predict(rffit, newdata = cur_mat, type = &quot;raw&quot;)) names(cell_class) &lt;- rownames(cur_mat) table(cell_class) ## cell_class ## Bcell BnTcell CD4 CD8 Myeloid Neutrophil ## 817 979 3620 2716 6302 559 ## Plasma_cell Stroma Treg Tumor ## 2692 4904 1170 10641 # Extract prediction probabilities for each cell set.seed(231014) cell_prob &lt;- predict(rffit, newdata = cur_mat, type = &quot;prob&quot;) Each cell is assigned to the class with highest probability. There are however cases, where the highest probability is low meaning the cell can not be uniquely assigned to a class. We next want to identify these cells and label them as “undefined”. Here, we select a maximum classification probability threshold of 40% but this threshold needs to be adjusted for other datasets. The adjusted cell labels are then stored in the SpatialExperiment object. library(ggridges) # Distribution of maximum probabilities tibble(max_prob = rowMax(as.matrix(cell_prob)), type = cell_class) %&gt;% ggplot() + geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) + theme_classic(base_size = 15) + xlab(&quot;Maximum probability&quot;) + ylab(&quot;Cell type&quot;) + xlim(c(0,1.2)) ## Picking joint bandwidth of 0.0238 # Label undefined cells cell_class[rowMax(as.matrix(cell_prob)) &lt; 0.4] &lt;- &quot;undefined&quot; # Store labels in SpatialExperiment onject cell_labels &lt;- spe$cell_labels cell_labels[colnames(unlab_spe)] &lt;- cell_class spe$celltype &lt;- cell_labels table(spe$celltype, spe$patient_id) ## ## Patient1 Patient2 Patient3 Patient4 ## Bcell 179 527 431 458 ## BnTcell 416 586 594 1078 ## CD4 391 1370 699 1385 ## CD8 518 1365 479 1142 ## Myeloid 1369 2197 1723 2731 ## Neutrophil 348 9 148 176 ## Plasma_cell 650 2122 351 274 ## Stroma 633 676 736 3261 ## Treg 553 409 243 310 ## Tumor 5560 3334 5648 2083 ## undefined 129 202 80 221 We can now compare the cell labels derived by classification to the different clustering strategies. The first comparison is against the clustering results using the asinh-transformed counts. tab1 &lt;- table(spe$celltype, paste(&quot;Rphenograph&quot;, spe$pg_clusters)) tab2 &lt;- table(spe$celltype, paste(&quot;SNN&quot;, spe$nn_clusters)) tab3 &lt;- table(spe$celltype, paste(&quot;SOM&quot;, spe$som_clusters)) pheatmap(log10(tab1 + 10), color = viridis(100)) pheatmap(log10(tab2 + 10), color = viridis(100)) pheatmap(log10(tab3 + 10), color = viridis(100)) We can see that Tumor and Myeloid cells span multiple clusters while Neutrophiles are detected as an individual cluster by all clustering approaches. We next compare the cell classification against clustering results using the integrated cells. tab1 &lt;- table(spe$celltype, paste(&quot;Rphenograph&quot;, spe$pg_clusters_corrected)) tab2 &lt;- table(spe$celltype, paste(&quot;SNN&quot;, spe$nn_clusters_corrected)) tab3 &lt;- table(spe$celltype, paste(&quot;SOM&quot;, spe$som_clusters_corrected)) pheatmap(log10(tab1 + 10), color = viridis(100)) pheatmap(log10(tab2 + 10), color = viridis(100)) pheatmap(log10(tab3 + 10), color = viridis(100)) We observe a high agreement between the shared nearest neighbor clustering approach using the integrated cells and the cell phenotypes derived by classification. In the next sections, we will highlight visualization strategies to verify the correctness of the phenotyping approach. Specifically, Section 11.2.3 shows how to outline identified cell phenotypes on composite images. Finally, we save the updated SpatialExperiment object. saveRDS(spe, &quot;data/spe.rds&quot;) 9.4 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 ggridges_0.5.5 ## [3] lubridate_1.9.3 forcats_1.0.0 ## [5] stringr_1.5.1 purrr_1.0.2 ## [7] readr_2.1.4 tidyr_1.3.0 ## [9] tibble_3.2.1 tidyverse_2.0.0 ## [11] caret_6.0-94 lattice_0.21-9 ## [13] cytomapper_1.14.0 EBImage_4.44.0 ## [15] dplyr_1.1.4 gridExtra_2.3 ## [17] pheatmap_1.0.12 patchwork_1.1.3 ## [19] ConsensusClusterPlus_1.66.0 kohonen_3.0.12 ## [21] CATALYST_1.26.0 scran_1.30.0 ## [23] scuttle_1.12.0 BiocParallel_1.36.0 ## [25] bluster_1.12.0 viridis_0.6.4 ## [27] viridisLite_0.4.2 dittoSeq_1.14.0 ## [29] ggplot2_3.4.4 igraph_1.6.0 ## [31] Rphenograph_0.99.1.9003 SpatialExperiment_1.12.0 ## [33] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0 ## [35] Biobase_2.62.0 GenomicRanges_1.54.1 ## [37] GenomeInfoDb_1.38.5 IRanges_2.36.0 ## [39] S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [41] MatrixGenerics_1.14.0 matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] bitops_1.0-7 RColorBrewer_1.1-3 ## [3] doParallel_1.0.17 tools_4.3.2 ## [5] backports_1.4.1 utf8_1.2.4 ## [7] R6_2.5.1 HDF5Array_1.30.0 ## [9] rhdf5filters_1.14.1 GetoptLong_1.0.5 ## [11] withr_2.5.2 sp_2.1-2 ## [13] cli_3.6.2 sandwich_3.1-0 ## [15] labeling_0.4.3 sass_0.4.8 ## [17] nnls_1.5 mvtnorm_1.2-4 ## [19] randomForest_4.7-1.1 proxy_0.4-27 ## [21] systemfonts_1.0.5 colorRamps_2.3.1 ## [23] svglite_2.1.3 scater_1.30.1 ## [25] parallelly_1.36.0 plotrix_3.8-4 ## [27] limma_3.58.1 flowCore_2.14.0 ## [29] generics_0.1.3 shape_1.4.6 ## [31] gtools_3.9.5 car_3.1-2 ## [33] Matrix_1.6-4 RProtoBufLib_2.14.0 ## [35] waldo_0.5.2 ggbeeswarm_0.7.2 ## [37] fansi_1.0.6 abind_1.4-5 ## [39] terra_1.7-65 lifecycle_1.0.4 ## [41] multcomp_1.4-25 yaml_2.3.8 ## [43] edgeR_4.0.3 carData_3.0-5 ## [45] rhdf5_2.46.1 recipes_1.0.9 ## [47] SparseArray_1.2.3 Rtsne_0.17 ## [49] grid_4.3.2 promises_1.2.1 ## [51] dqrng_0.3.2 crayon_1.5.2 ## [53] shinydashboard_0.7.2 beachmat_2.18.0 ## [55] cowplot_1.1.2 magick_2.8.2 ## [57] pillar_1.9.0 knitr_1.45 ## [59] ComplexHeatmap_2.18.0 metapod_1.10.1 ## [61] rjson_0.2.21 future.apply_1.11.1 ## [63] codetools_0.2-19 glue_1.6.2 ## [65] data.table_1.14.10 vctrs_0.6.5 ## [67] png_0.1-8 gtable_0.3.4 ## [69] cachem_1.0.8 gower_1.0.1 ## [71] xfun_0.41 S4Arrays_1.2.0 ## [73] mime_0.12 prodlim_2023.08.28 ## [75] survival_3.5-7 timeDate_4032.109 ## [77] iterators_1.0.14 cytolib_2.14.0 ## [79] hardhat_1.3.0 lava_1.7.3 ## [81] statmod_1.5.0 ellipsis_0.3.2 ## [83] TH.data_1.1-2 ipred_0.9-14 ## [85] nlme_3.1-163 rprojroot_2.0.4 ## [87] bslib_0.6.1 irlba_2.3.5.1 ## [89] svgPanZoom_0.3.4 vipor_0.4.7 ## [91] rpart_4.1.21 colorspace_2.1-0 ## [93] raster_3.6-26 nnet_7.3-19 ## [95] tidyselect_1.2.0 compiler_4.3.2 ## [97] BiocNeighbors_1.20.1 desc_1.4.3 ## [99] DelayedArray_0.28.0 bookdown_0.37 ## [101] scales_1.3.0 tiff_0.1-12 ## [103] digest_0.6.33 fftwtools_0.9-11 ## [105] rmarkdown_2.25 XVector_0.42.0 ## [107] htmltools_0.5.7 pkgconfig_2.0.3 ## [109] jpeg_0.1-10 sparseMatrixStats_1.14.0 ## [111] highr_0.10 fastmap_1.1.1 ## [113] rlang_1.1.2 GlobalOptions_0.1.2 ## [115] htmlwidgets_1.6.4 shiny_1.8.0 ## [117] DelayedMatrixStats_1.24.0 farver_2.1.1 ## [119] jquerylib_0.1.4 zoo_1.8-12 ## [121] jsonlite_1.8.8 ModelMetrics_1.2.2.2 ## [123] BiocSingular_1.18.0 RCurl_1.98-1.13 ## [125] magrittr_2.0.3 GenomeInfoDbData_1.2.11 ## [127] Rhdf5lib_1.24.1 munsell_0.5.0 ## [129] Rcpp_1.0.11 ggnewscale_0.4.9 ## [131] pROC_1.18.5 stringi_1.8.3 ## [133] brio_1.1.4 zlibbioc_1.48.0 ## [135] MASS_7.3-60 plyr_1.8.9 ## [137] listenv_0.9.0 parallel_4.3.2 ## [139] ggrepel_0.9.4 splines_4.3.2 ## [141] hms_1.1.3 circlize_0.4.15 ## [143] locfit_1.5-9.8 ggpubr_0.6.0 ## [145] ggsignif_0.6.4 pkgload_1.3.3 ## [147] reshape2_1.4.4 ScaledMatrix_1.10.0 ## [149] XML_3.99-0.16 drc_3.0-1 ## [151] evaluate_0.23 tzdb_0.4.0 ## [153] foreach_1.5.2 tweenr_2.0.2 ## [155] httpuv_1.6.13 RANN_2.6.1 ## [157] polyclip_1.10-6 future_1.33.1 ## [159] clue_0.3-65 ggforce_0.4.1 ## [161] rsvd_1.0.5 broom_1.0.5 ## [163] xtable_1.8-4 e1071_1.7-14 ## [165] rstatix_0.7.2 later_1.3.2 ## [167] class_7.3-22 FlowSOM_2.10.0 ## [169] beeswarm_0.4.0 cluster_2.1.4 ## [171] timechange_0.2.0 globals_0.16.2 References "],["single-cell-visualization.html", "10 Single cell visualization 10.1 Load data 10.2 Cell-type level 10.3 Sample-level 10.4 Further examples 10.5 Session Info", " 10 Single cell visualization The following section describes typical approaches for visualizing single-cell data. This chapter is divided into three parts. Section 10.2 will highlight visualization approaches downstream of cell type classification from Section 9.3. We will then focus on visualization methods that relate single-cell data to the sample level in Section 10.3. Lastly, Section 10.4 will provide a more customized example on how to integrate various single-cell and sample metadata into one heatmap using the ComplexHeatmap package (Gu, Eils, and Schlesner 2016). Visualization functions from popular R packages in single-cell research such as scater, DittoSeq and CATALYST will be utilized. We will recycle methods and functions that we have used in previous sections, while also introducing new ones. Please note that this chapter aims to provide an overview on common visualization options and should be seen as a stepping-stone. However, many more options exist and the user should customize the visualization according to the biological question at hand. 10.1 Load data First, we will read in the previously generated SpatialExperiment object. spe &lt;- readRDS(&quot;data/spe.rds&quot;) For visualization purposes, we will define markers that were used for cell type classification and markers that can indicate a specific cell state (e.g., Ki67 for proliferating cells). # Define cell phenotype markers type_markers &lt;- c(&quot;Ecad&quot;, &quot;CD45RO&quot;, &quot;CD20&quot;, &quot;CD3&quot;, &quot;FOXP3&quot;, &quot;CD206&quot;, &quot;MPO&quot;, &quot;SMA&quot;, &quot;CD8a&quot;, &quot;CD4&quot;, &quot;HLADR&quot;, &quot;CD15&quot;, &quot;CD38&quot;, &quot;PDGFRb&quot;) # Define cell state markers state_markers &lt;- c(&quot;CarbonicAnhydrase&quot;, &quot;Ki67&quot;, &quot;PD1&quot;, &quot;GrzB&quot;, &quot;PDL1&quot;, &quot;ICOS&quot;, &quot;TCF7&quot;, &quot;VISTA&quot;) # Add to spe rowData(spe)$marker_class &lt;- ifelse(rownames(spe) %in% type_markers, &quot;type&quot;, ifelse(rownames(spe) %in% state_markers, &quot;state&quot;, &quot;other&quot;)) 10.2 Cell-type level In the first section of this chapter, the grouping-level for the visualization approaches will be the cell type classification from Section 9.3. Other grouping levels (e.g., cluster assignments from Section 9.2) are possible and the user should adjust depending on the chosen analysis workflow. 10.2.1 Dimensionality reduction visualization As seen before, we can visualize single-cells in low-dimensional space. Often, non-linear methods for dimensionality reduction such as tSNE and UMAP are used. They aim to preserve the distances between each cell and its neighbors in the high-dimensional space. Interpreting these plots is not trivial, but local neighborhoods in the plot can suggest similarity in expression for given cells. See Orchestrating Single-Cell Analysis with Bioconductor for more details. Here, we will use dittoDimPlot from the DittoSeq package and plotReducedDim from the scater package to visualize the fastMNN-corrected UMAP colored by cell type and expression (using the asinh-transformed intensities), respectively. Both functions are highly flexible and return ggplot objects which can be further modified. library(dittoSeq) library(scater) library(patchwork) library(cowplot) library(viridis) ## UMAP colored by cell type and expression - dittoDimPlot p1 &lt;- dittoDimPlot(spe, var = &quot;celltype&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, do.label = TRUE) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + theme(legend.title = element_blank()) + ggtitle(&quot;Cell types on UMAP, integrated cells&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;Ecad&quot;, assay = &quot;exprs&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, colors = viridis(100), do.label = TRUE) + scale_color_viridis() p1 + p2 The plotReducedDim function of the scater package provides an alternative way for visualizing cells in low dimensions. Here, we loop over all type markers, generate one plot per marker and plot the indivudual plots side-by-side. # UMAP colored by expression for all markers - plotReducedDim plot_list &lt;- lapply(rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;], function(x){ p &lt;- plotReducedDim(spe, dimred = &quot;UMAP_mnnCorrected&quot;, colour_by = x, by_exprs_values = &quot;exprs&quot;, point_size = 0.2) return(p) }) plot_grid(plotlist = plot_list) 10.2.2 Heatmap visualization Next, it is often useful to visualize single-cell expression per cell type in form of a heatmap. For this, we will use the dittoHeatmap function from the DittoSeq package. We sub-sample the dataset to 4000 cells for ease of visualization and overlay the cancer type and patient ID from which the cells were extracted. set.seed(220818) cur_cells &lt;- sample(seq_len(ncol(spe)), 4000) # Heatmap visualization - DittoHeatmap dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;], assay = &quot;exprs&quot;, cluster_cols = FALSE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;celltype&quot;, &quot;indication&quot;, &quot;patient_id&quot;), annotation_colors = list(indication = metadata(spe)$color_vectors$indication, patient_id = metadata(spe)$color_vectors$patient_id, celltype = metadata(spe)$color_vectors$celltype)) Similarly, we can visualize the mean marker expression per cell type for all cells bu first calculating the mean marker expression per cell type using the aggregateAcrossCells function from the scuttle package and then use dittoHeatmap. We will annotate the heatmap with the number of cells per cell type and we will used different ways for feature scaling. library(scuttle) ## aggregate by cell type celltype_mean &lt;- aggregateAcrossCells(as(spe, &quot;SingleCellExperiment&quot;), ids = spe$celltype, statistics = &quot;mean&quot;, use.assay.type = &quot;exprs&quot;, subset.row = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;]) # No scaling dittoHeatmap(celltype_mean, assay = &quot;exprs&quot;, cluster_cols = TRUE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;celltype&quot;, &quot;ncells&quot;), annotation_colors = list(celltype = metadata(spe)$color_vectors$celltype, ncells = plasma(100))) # Scaled to max dittoHeatmap(celltype_mean, assay = &quot;exprs&quot;, cluster_cols = TRUE, scaled.to.max = TRUE, heatmap.colors.max.scaled = inferno(100), annot.by = c(&quot;celltype&quot;, &quot;ncells&quot;), annotation_colors = list(celltype = metadata(spe)$color_vectors$celltype, ncells = plasma(100))) # Z score scaled dittoHeatmap(celltype_mean, assay = &quot;exprs&quot;, cluster_cols = TRUE, annot.by = c(&quot;celltype&quot;, &quot;ncells&quot;), annotation_colors = list(celltype = metadata(spe)$color_vectors$celltype, ncells = plasma(100))) As illustrated above for not-, max-, and Z score-scaled expression values, different ways of scaling can have strong effects on visualization output and we encourage the user to test multiple options. Overall, we can observe cell-type specific marker expression (e.g., Tumor = Ecad high and B cells = CD20 high) in agreement with the gating scheme of Section 9.3. 10.2.3 Violin plot visualization The plotExpression function from the scater package allows to plot the distribution of expression values across cell types for a chosen set of proteins. The output is a ggplot object which can be modified further. # Violin Plot - plotExpression plotExpression(spe[,cur_cells], features = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;], x = &quot;celltype&quot;, exprs_values = &quot;exprs&quot;, colour_by = &quot;celltype&quot;) + theme(axis.text.x = element_text(angle = 90))+ scale_color_manual(values = metadata(spe)$color_vectors$celltype) 10.2.4 Scatter plot visualization Moreover, a protein expression based scatter plot can be generated with dittoScatterPlot (returns a ggplot object). We overlay the plot with the cell type information. # Scatter plot dittoScatterPlot(spe, x.var = &quot;CD3&quot;, y.var=&quot;CD20&quot;, assay.x = &quot;exprs&quot;, assay.y = &quot;exprs&quot;, color.var = &quot;celltype&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + ggtitle(&quot;Scatterplot for CD3/CD20 labelled by celltype&quot;) We can nicely observe how the “B next to T cell” phenotype (BnTcell) has high expression values for both CD20 and CD3. Of note, in a setting where the user aims to assign labels to clusters based on marker genes/proteins, all of the above plots can be particularly helpful. 10.2.5 Barplot visualization In order to display frequencies of cell types per sample/patient, the dittoBarPlot function will be used. Data can be represented as percentages or counts and again ggplot objects are outputted. # by sample_id - percentage dittoBarPlot(spe, var = &quot;celltype&quot;, group.by = &quot;sample_id&quot;) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) # by patient_id - percentage dittoBarPlot(spe, var = &quot;celltype&quot;, group.by = &quot;patient_id&quot;) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) # by patient_id - count dittoBarPlot(spe, scale = &quot;count&quot;, var = &quot;celltype&quot;, group.by = &quot;patient_id&quot;) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) We can see that cell type frequencies change between samples/patients and that the highest proportion/counts of plasma cells and stromal cells can be observed for Patient 2 and Patient 4, respectively. 10.2.6 CATALYST-based visualization In the following, we highlight some useful visualization functions from the CATALYST package. To this end, we will first convert the SpatialExperiment object into a CATALYST-compatible format. library(CATALYST) # Save SPE in CATALYST-compatible object with renamed colData entries and # new metadata information spe_cat &lt;- spe spe_cat$sample_id &lt;- factor(spe$sample_id) spe_cat$condition &lt;- factor(spe$indication) spe_cat$cluster_id &lt;- factor(spe$celltype) # Add celltype information to metadata metadata(spe_cat)$cluster_codes &lt;- data.frame(celltype = factor(spe_cat$celltype)) All of the CATALYST functions presented below return ggplot objects, which allow flexible downstream adjustment. 10.2.6.1 Pseudobulk-level MDS plot Pseudobulk-level multi-dimensional scaling (MDS) plots can be rendered with the exported pbMDS function. Here, we will use pbMDS to highlight expression similarities between cell types and subsequently for each celltype-sample-combination. # MDS pseudobulk by cell type pbMDS(spe_cat, by = &quot;cluster_id&quot;, features = rownames(spe_cat)[rowData(spe_cat)$marker_class == &quot;type&quot;], label_by = &quot;cluster_id&quot;, k = &quot;celltype&quot;) + scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype) # MDS pseudobulk by cell type and sample_id pbMDS(spe_cat, by = &quot;both&quot;, features = rownames(spe_cat)[rowData(spe_cat)$marker_class == &quot;type&quot;], k = &quot;celltype&quot;, shape_by = &quot;condition&quot;, size_by = TRUE) + scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype) We can see that the pseudobulk-expression profile of neutrophils seems markedly distinct from the other cell types, while comparable cell types such as the T cell subtypes group together. Furthermore, pseudobulk cell-type profiles from SCCHN appear different from the other indications. 10.2.6.2 Reduced dimension plot on CLR of proportions The clrDR function produces dimensionality reduction plots on centered log-ratios (CLR) of sample/cell type proportions across cell type/samples. As with pbMDS, the output plots aim to illustrate the degree of similarity between cell types based on sample proportions. # CLR on cluster proportions across samples clrDR(spe_cat, dr = &quot;PCA&quot;, by = &quot;cluster_id&quot;, k = &quot;celltype&quot;, label_by = &quot;cluster_id&quot;, arrow_col = &quot;sample_id&quot;, point_pal = metadata(spe_cat)$color_vectors$celltype) We can again observe that neutrophils have a divergent profile also in terms of their sample proportions. 10.2.6.3 Pseudobulk expression boxplot The plotPbExprs generates combined box- and jitter-plots of aggregated marker expression per cell type and sample (image). Here, we further split the data by cancer type. plotPbExprs(spe_cat, k = &quot;celltype&quot;, facet_by = &quot;cluster_id&quot;, ncol = 2, features = rownames(spe_cat)[rowData(spe_cat)$marker_class == &quot;type&quot;]) + scale_color_manual(values = metadata(spe_cat)$color_vectors$indication) Notably, CD15 levels are elevated in SCCHN in comparison to all other indications for most cell types. 10.3 Sample-level In the next section, we will shift the grouping-level focus from the cell type to the sample-level. Sample-levels will be further divided into the sample-(image) and patient-level. Although we will mostly repeat the functions from the previous section 10.2, sample- and patient-level centered visualization can provide additional quality control and biological interpretation. 10.3.1 Dimensionality reduction visualization Visualization of low-dimensional embeddings, here comparing non-corrected and fastMNN-corrected UMAPs, and coloring it by sample-levels is often used for “batch effect” assessment as mentioned in Section 7.4. We will again use dittoDimPlot. ## UMAP colored by cell type and expression - dittoDimPlot p1 &lt;- dittoDimPlot(spe, var = &quot;sample_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2, colors = viridis(100), do.label = FALSE) + scale_color_manual(values = metadata(spe)$color_vectors$sample_id) + theme(legend.title = element_blank()) + ggtitle(&quot;Sample ID&quot;) p2 &lt;- dittoDimPlot(spe, var = &quot;sample_id&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, colors = viridis(100), do.label = FALSE) + scale_color_manual(values = metadata(spe)$color_vectors$sample_id) + theme(legend.title = element_blank()) + ggtitle(&quot;Sample ID&quot;) p3 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP&quot;, size = 0.2, do.label = FALSE) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + theme(legend.title = element_blank()) + ggtitle(&quot;Patient ID&quot;) p4 &lt;- dittoDimPlot(spe, var = &quot;patient_id&quot;, reduction.use = &quot;UMAP_mnnCorrected&quot;, size = 0.2, do.label = FALSE) + scale_color_manual(values = metadata(spe)$color_vectors$patient_id) + theme(legend.title = element_blank()) + ggtitle(&quot;Patient ID&quot;) (p1 + p2) / (p3 + p4) As illustrated in Section 8, we see that the fastMNN approach (right side of the plot) leads to mixing of cells across samples/patients and thus batch effect correction. 10.3.2 Heatmap visualization It can be beneficial to use a heatmap to visualize single-cell expression per sample and patient. Such a plot, which we will create using dittoHeatmap, can highlight biological differences across samples/patients. # Heatmap visualization - DittoHeatmap dittoHeatmap(spe[,cur_cells], genes = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;], assay = &quot;exprs&quot;, order.by = c(&quot;patient_id&quot;,&quot;sample_id&quot;), cluster_cols = FALSE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;celltype&quot;, &quot;indication&quot;, &quot;patient_id&quot;, &quot;sample_id&quot;), annotation_colors = list(celltype = metadata(spe)$color_vectors$celltype, indication = metadata(spe)$color_vectors$indication, patient_id = metadata(spe)$color_vectors$patient_id, sample_id = metadata(spe)$color_vectors$sample_id)) As in Section 7.3, aggregated mean marker expression per sample/patient allow identification of samples/patients with outlying expression patterns. Here, we will focus on the patient level and use aggregateAcrossCells and dittoHeatmap. The heatmap will be annotated with the number of cells per patient and cancer type and displayed using two scaling options. # mean expression by patient_id patient_mean &lt;- aggregateAcrossCells(as(spe, &quot;SingleCellExperiment&quot;), ids = spe$patient_id, statistics = &quot;mean&quot;, use.assay.type = &quot;exprs&quot;, subset.row = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;]) # No scaling dittoHeatmap(patient_mean, assay = &quot;exprs&quot;, cluster_cols = TRUE, scale = &quot;none&quot;, heatmap.colors = viridis(100), annot.by = c(&quot;patient_id&quot;,&quot;indication&quot;,&quot;ncells&quot;), annotation_colors = list(patient_id = metadata(spe)$color_vectors$patient_id, indication = metadata(spe)$color_vectors$indication, ncells = plasma(100))) # Max expression scaling dittoHeatmap(patient_mean, assay = &quot;exprs&quot;, cluster_cols = TRUE, scaled.to.max = TRUE, heatmap.colors.max.scaled = inferno(100), annot.by = c(&quot;patient_id&quot;,&quot;indication&quot;,&quot;ncells&quot;), annotation_colors = list(patient_id = metadata(spe)$color_vectors$patient_id, indication = metadata(spe)$color_vectors$indication, ncells = plasma(100))) As seen before, CD15 levels are elevated in Patient 4 (SCCHN), while SMA levels are highest for Patient 4 (CRC). 10.3.3 Barplot visualization Complementary to displaying cell type frequencies per sample/patient, we can use dittoBarPlot to display sample/patient frequencies per cell type. dittoBarPlot(spe, var = &quot;patient_id&quot;, group.by = &quot;celltype&quot;) + scale_fill_manual(values = metadata(spe)$color_vectors$patient_id) dittoBarPlot(spe, var = &quot;sample_id&quot;, group.by = &quot;celltype&quot;) + scale_fill_manual(values = metadata(spe)$color_vectors$sample_id) Patient2 has the highest and lowest proportion of plasma cells and neutrophils, respectively. 10.3.4 CATALYST-based visualization 10.3.4.1 Pseudobulk-level MDS plot Expression-based pseudobulks for each sample can be compared with the pbMDS function. # MDS pseudobulk by sample_id pbMDS(spe_cat, by = &quot;sample_id&quot;, color_by = &quot;sample_id&quot;, features = rownames(spe_cat)[rowData(spe_cat)$marker_class == &quot;type&quot;]) + scale_color_manual(values = metadata(spe_cat)$color_vectors$sample_id) There are marked differences in pseudobulk-expression patterns between samples and across patients, which can be driven by biological differences and also technical aspects such as divergent region selection. 10.3.4.2 Reduced dimension plot on CLR of proportions The clrDR function can also be used to analyze similarity of samples based on cell type proportions. # CLR on sample proportions across clusters clrDR(spe_cat, dr = &quot;PCA&quot;, by = &quot;sample_id&quot;, point_col = &quot;sample_id&quot;, k = &quot;celltype&quot;, point_pal = metadata(spe_cat)$color_vectors$sample_id) + scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype) ## Scale for colour is already present. ## Adding another scale for colour, which will replace the existing scale. There are notable differences between samples based on their cell type proportions. Interestingly, Patient3_001, Patient1_003, Patient4_007 and Patient4_006 group together and the PC loadings indicate a strong contribution of BnT and B cells, which could propose formation of tertiary lymphoid structures (TLS). In section 12.2, we will be able to confirm this hypothesis visually on the images. 10.4 Further examples In the last section of this chapter, we will use the popular ComplexHeatmap package to create a visualization example that combines various cell-type- and sample-level information. ComplexHeatmap is highly versatile and is originally inspired from the pheatmap package. Therefore, many arguments have the same/similar names. For more details, we would recommend to read the reference book. 10.4.1 Publication-ready ComplexHeatmap For this example, we will concatenate heatmaps and annotations horizontally into one rich heatmap list. The grouping-level for the visualization will again be the cell type information from Section 9.3 Initially, we will create two separate Heatmap objects for cell type and state markers. Then, metadata information, including the cancer type proportion and number of cells/patients per cell type, will be extracted into HeatmapAnnotation objects. Notably, we will add spatial features per cell type, here the number of neighbors extracted from colPair(spe) and cell area, in another HeatmapAnnotation object. Ultimately, all objects are combined in a HeatmapList and visualized. library(ComplexHeatmap) library(circlize) library(tidyverse) set.seed(22) ### 1. Heatmap bodies ### # Heatmap body color col_exprs &lt;- colorRamp2(c(0,1,2,3,4), c(&quot;#440154FF&quot;,&quot;#3B518BFF&quot;,&quot;#20938CFF&quot;, &quot;#6ACD5AFF&quot;,&quot;#FDE725FF&quot;)) # Create Heatmap objects # By cell type markers celltype_mean &lt;- aggregateAcrossCells(as(spe, &quot;SingleCellExperiment&quot;), ids = spe$celltype, statistics = &quot;mean&quot;, use.assay.type = &quot;exprs&quot;, subset.row = rownames(spe)[rowData(spe)$marker_class == &quot;type&quot;]) h_type &lt;- Heatmap(t(assay(celltype_mean, &quot;exprs&quot;)), column_title = &quot;type_markers&quot;, col = col_exprs, name= &quot;mean exprs&quot;, show_row_names = TRUE, show_column_names = TRUE) # By cell state markers cellstate_mean &lt;- aggregateAcrossCells(as(spe, &quot;SingleCellExperiment&quot;), ids = spe$celltype, statistics = &quot;mean&quot;, use.assay.type = &quot;exprs&quot;, subset.row = rownames(spe)[rowData(spe)$marker_class == &quot;state&quot;]) h_state &lt;- Heatmap(t(assay(cellstate_mean, &quot;exprs&quot;)), column_title = &quot;state_markers&quot;, col = col_exprs, name= &quot;mean exprs&quot;, show_row_names = TRUE, show_column_names = TRUE) ### 2. Heatmap annotation ### ### 2.1 Metadata features anno &lt;- colData(celltype_mean) %&gt;% as.data.frame %&gt;% select(celltype, ncells) # Proportion of indication per celltype indication &lt;- unclass(prop.table(table(spe$celltype, spe$indication), margin = 1)) # Number of contributing patients per celltype cluster_PID &lt;- colData(spe) %&gt;% as.data.frame() %&gt;% select(celltype, patient_id) %&gt;% group_by(celltype) %&gt;% table() %&gt;% as.data.frame() n_PID &lt;- cluster_PID %&gt;% filter(Freq&gt;0) %&gt;% group_by(celltype) %&gt;% count(name = &quot;n_PID&quot;) %&gt;% column_to_rownames(&quot;celltype&quot;) # Create HeatmapAnnotation objects ha_anno &lt;- HeatmapAnnotation(celltype = anno$celltype, border = TRUE, gap = unit(1,&quot;mm&quot;), col = list(celltype = metadata(spe)$color_vectors$celltype), which = &quot;row&quot;) ha_meta &lt;- HeatmapAnnotation(n_cells = anno_barplot(anno$ncells, width = unit(10, &quot;mm&quot;)), n_PID = anno_barplot(n_PID, width = unit(10, &quot;mm&quot;)), indication = anno_barplot(indication,width = unit(10, &quot;mm&quot;), gp = gpar(fill = metadata(spe)$color_vectors$indication)), border = TRUE, annotation_name_rot = 90, gap = unit(1,&quot;mm&quot;), which = &quot;row&quot;) ### 2.2 Spatial features # Add number of neighbors to spe object (saved in colPair) spe$n_neighbors &lt;- countLnodeHits(colPair(spe, &quot;neighborhood&quot;)) # Select spatial features and average over celltypes spatial &lt;- colData(spe) %&gt;% as.data.frame() %&gt;% select(area, celltype, n_neighbors) spatial &lt;- spatial %&gt;% select(-celltype) %&gt;% aggregate(by = list(celltype = spatial$celltype), FUN = mean) %&gt;% column_to_rownames(&quot;celltype&quot;) # Create HeatmapAnnotation object ha_spatial &lt;- HeatmapAnnotation( area = spatial$area, n_neighbors = spatial$n_neighbors, border = TRUE, gap = unit(1,&quot;mm&quot;), which = &quot;row&quot;) ### 3. Plot rich heatmap ### # Create HeatmapList object h_list &lt;- h_type + h_state + ha_anno + ha_spatial + ha_meta # Add customized legend for anno_barplot() lgd &lt;- Legend(title = &quot;indication&quot;, at = colnames(indication), legend_gp = gpar(fill = metadata(spe)$color_vectors$indication)) # Plot draw(h_list,annotation_legend_list = list(lgd)) This plot summarizes most of the information we have seen in this chapter previously. In addition, we can observe that tumor cells have the largest mean cell area, high number of neighbors and elevated Ki67 expression. BnT cells have the highest number of neighbors on average, which is biological sound given their predominant location in highly immune infiltrated regions (such as TLS). 10.4.2 Interactive visualization For interactive visualization of the single-cell data the iSEE shiny application can be used. For a comprehensive tutorial, please refer to the iSEE vignette. if (interactive()) { library(iSEE) iSEE(spe) } 10.5 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] lubridate_1.9.3 forcats_1.0.0 ## [3] stringr_1.5.1 dplyr_1.1.4 ## [5] purrr_1.0.2 readr_2.1.4 ## [7] tidyr_1.3.0 tibble_3.2.1 ## [9] tidyverse_2.0.0 circlize_0.4.15 ## [11] ComplexHeatmap_2.18.0 CATALYST_1.26.0 ## [13] viridis_0.6.4 viridisLite_0.4.2 ## [15] cowplot_1.1.2 patchwork_1.1.3 ## [17] scater_1.30.1 scuttle_1.12.0 ## [19] dittoSeq_1.14.0 ggplot2_3.4.4 ## [21] SpatialExperiment_1.12.0 SingleCellExperiment_1.24.0 ## [23] SummarizedExperiment_1.32.0 Biobase_2.62.0 ## [25] GenomicRanges_1.54.1 GenomeInfoDb_1.38.5 ## [27] IRanges_2.36.0 S4Vectors_0.40.2 ## [29] BiocGenerics_0.48.1 MatrixGenerics_1.14.0 ## [31] matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] RColorBrewer_1.1-3 jsonlite_1.8.8 ## [3] shape_1.4.6 magrittr_2.0.3 ## [5] magick_2.8.2 ggbeeswarm_0.7.2 ## [7] TH.data_1.1-2 farver_2.1.1 ## [9] rmarkdown_2.25 GlobalOptions_0.1.2 ## [11] zlibbioc_1.48.0 vctrs_0.6.5 ## [13] Cairo_1.6-2 DelayedMatrixStats_1.24.0 ## [15] RCurl_1.98-1.13 rstatix_0.7.2 ## [17] htmltools_0.5.7 S4Arrays_1.2.0 ## [19] plotrix_3.8-4 BiocNeighbors_1.20.1 ## [21] broom_1.0.5 SparseArray_1.2.3 ## [23] sass_0.4.8 bslib_0.6.1 ## [25] plyr_1.8.9 sandwich_3.1-0 ## [27] zoo_1.8-12 cachem_1.0.8 ## [29] igraph_1.6.0 lifecycle_1.0.4 ## [31] iterators_1.0.14 pkgconfig_2.0.3 ## [33] rsvd_1.0.5 Matrix_1.6-4 ## [35] R6_2.5.1 fastmap_1.1.1 ## [37] GenomeInfoDbData_1.2.11 clue_0.3-65 ## [39] digest_0.6.33 colorspace_2.1-0 ## [41] ggnewscale_0.4.9 irlba_2.3.5.1 ## [43] ggpubr_0.6.0 beachmat_2.18.0 ## [45] labeling_0.4.3 cytolib_2.14.0 ## [47] timechange_0.2.0 fansi_1.0.6 ## [49] colorRamps_2.3.1 nnls_1.5 ## [51] polyclip_1.10-6 abind_1.4-5 ## [53] compiler_4.3.2 withr_2.5.2 ## [55] doParallel_1.0.17 ConsensusClusterPlus_1.66.0 ## [57] backports_1.4.1 BiocParallel_1.36.0 ## [59] carData_3.0-5 highr_0.10 ## [61] ggforce_0.4.1 ggsignif_0.6.4 ## [63] MASS_7.3-60 drc_3.0-1 ## [65] DelayedArray_0.28.0 rjson_0.2.21 ## [67] FlowSOM_2.10.0 gtools_3.9.5 ## [69] tools_4.3.2 vipor_0.4.7 ## [71] beeswarm_0.4.0 glue_1.6.2 ## [73] Rtsne_0.17 cluster_2.1.4 ## [75] reshape2_1.4.4 generics_0.1.3 ## [77] gtable_0.3.4 tzdb_0.4.0 ## [79] hms_1.1.3 data.table_1.14.10 ## [81] BiocSingular_1.18.0 ScaledMatrix_1.10.0 ## [83] car_3.1-2 utf8_1.2.4 ## [85] XVector_0.42.0 ggrepel_0.9.4 ## [87] foreach_1.5.2 pillar_1.9.0 ## [89] splines_4.3.2 flowCore_2.14.0 ## [91] tweenr_2.0.2 lattice_0.21-9 ## [93] survival_3.5-7 RProtoBufLib_2.14.0 ## [95] tidyselect_1.2.0 knitr_1.45 ## [97] gridExtra_2.3 bookdown_0.37 ## [99] xfun_0.41 pheatmap_1.0.12 ## [101] stringi_1.8.3 yaml_2.3.8 ## [103] evaluate_0.23 codetools_0.2-19 ## [105] cli_3.6.2 munsell_0.5.0 ## [107] jquerylib_0.1.4 Rcpp_1.0.11 ## [109] png_0.1-8 XML_3.99-0.16 ## [111] parallel_4.3.2 sparseMatrixStats_1.14.0 ## [113] bitops_1.0-7 mvtnorm_1.2-4 ## [115] scales_1.3.0 ggridges_0.5.5 ## [117] crayon_1.5.2 GetoptLong_1.0.5 ## [119] rlang_1.1.2 multcomp_1.4-25 References "],["image-visualization.html", "11 Image visualization 11.1 Pixel visualization 11.2 Cell visualization 11.3 Adjusting plot annotations 11.4 Displaying individual images 11.5 Saving and returning images 11.6 Interactive image visualization 11.7 Session Info", " 11 Image visualization The following section describes how to visualize the abundance of biomolecules (e.g., protein or RNA) as well as cell-specific metadata on images. Section 11.1 focuses on visualizing pixel-level information including the generation of pseudo-color composite images. Section 11.2 highlights the visualization of cell metadata (e.g., cell phenotype) as well as summarized pixel intensities on cell segmentation masks. Section 11.6 showcases interactive pixel- and cell-level visualization with the cytoviewer R/Bioconductor package (Meyer, Eling, and Bodenmiller 2024). The cytomapper R/Bioconductor package was developed to support the handling and visualization of multiple multi-channel images and segmentation masks (Eling et al. 2020). The main data object for image handling is the CytoImageList container which we used in Section 5 to store multi-channel images and segmentation masks. We will first read in the previously processed data and randomly select 3 images for visualization purposes. library(SpatialExperiment) library(cytomapper) spe &lt;- readRDS(&quot;data/spe.rds&quot;) images &lt;- readRDS(&quot;data/images.rds&quot;) masks &lt;- readRDS(&quot;data/masks.rds&quot;) # Sample images set.seed(220517) cur_id &lt;- sample(unique(spe$sample_id), 3) cur_images &lt;- images[names(images) %in% cur_id] cur_masks &lt;- masks[names(masks) %in% cur_id] 11.1 Pixel visualization The following section gives examples for visualizing individual channels or multiple channels as pseudo-color composite images. For this the cytomapper package exports the plotPixels function which expects a CytoImageList object storing one or multiple multi-channel images. In the simplest use case, a single channel can be visualized as follows: plotPixels(cur_images, colour_by = &quot;Ecad&quot;, bcg = list(Ecad = c(0, 5, 1))) The plot above shows the tissue expression of the epithelial tumor marker E-cadherin on the 3 selected images. The bcg parameter (default c(0, 1, 1)) stands for “background”, “contrast”, “gamma” and controls these attributes of the image. This parameter takes a named list where each entry specifies these attributes per channel. The first value of the numeric vector will be added to the pixel intensities (background); pixel intensities will be multiplied by the second entry of the vector (contrast); pixel intensities will be exponentiated by the third entry of the vector (gamma). In most cases, it is sufficient to adjust the second (contrast) entry of the vector. The following example highlights the visualization of 6 markers (maximum allowed number of markers) at once per image. The markers indicate the spatial distribution of tumor cells (E-cadherin), T cells (CD3), B cells (CD20), CD8+ T cells (CD8a), plasma cells (CD38) and proliferating cells (Ki67). plotPixels(cur_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;), bcg = list(Ecad = c(0, 5, 1), CD3 = c(0, 5, 1), CD20 = c(0, 5, 1), CD8a = c(0, 5, 1), CD38 = c(0, 8, 1), Ki67 = c(0, 5, 1))) 11.1.1 Adjusting colors The default colors for visualization are chosen by the additive RGB (red, green, blue) color model. For six markers the default colors are: red, green, blue, cyan (green + blue), magenta (red + blue), yellow (green + red). These colors are the easiest to distinguish by eye. However, you can select other colors for each channel by setting the colour parameter: plotPixels(cur_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;), bcg = list(Ecad = c(0, 5, 1), CD3 = c(0, 5, 1), CD20 = c(0, 5, 1)), colour = list(Ecad = c(&quot;black&quot;, &quot;burlywood1&quot;), CD3 = c(&quot;black&quot;, &quot;cyan2&quot;), CD20 = c(&quot;black&quot;, &quot;firebrick1&quot;))) The colour parameter takes a named list in which each entry specifies the colors from which a color gradient is constructed via colorRampPalette. These are usually vectors of length 2 in which the first entry is \"black\" and the second entry specifies the color of choice. Although not recommended, you can also specify more than two colors to generate a more complex color gradient. 11.1.2 Image normalization As an alternative to setting the bcg parameter, images can first be normalized. Normalization here means to scale the pixel intensities per channel between 0 and 1 (or a range specified by the ft parameter in the normalize function). By default, the normalize function scales pixel intensities across all images contained in the CytoImageList object (separateImages = FALSE). Each individual channel is scaled independently (separateChannels = TRUE). After 0-1 normalization, maximum pixel intensities can be clipped to enhance the contrast of the image (setting the inputRange parameter). In the following example, the clipping to 0 and 0.2 is the same as multiplying the pixel intensities by a factor of 5. # 0 - 1 channel scaling across all images norm_images &lt;- cytomapper::normalize(cur_images) # Clip channel at 0.2 norm_images &lt;- cytomapper::normalize(norm_images, inputRange = c(0, 0.2)) plotPixels(norm_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;)) The default setting of scaling pixel intensities across all images ensures comparable intensity levels across images. Pixel intensities can also be scaled per image therefore correcting for staining/expression differences between images: # 0 - 1 channel scaling per image norm_images &lt;- cytomapper::normalize(cur_images, separateImages = TRUE) # Clip channel at 0.2 norm_images &lt;- cytomapper::normalize(norm_images, inputRange = c(0, 0.2)) plotPixels(norm_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;)) As we can see, the marker Ki67 appears brighter on image 2 and 3 in comparison to scaling the channel across all images. Finally, the normalize function also accepts a named list input for the inputRange argument. In this list, the clipping range per channel can be set individually: # 0 - 1 channel scaling per image norm_images &lt;- cytomapper::normalize(cur_images, separateImages = TRUE, inputRange = list(Ecad = c(0, 50), CD3 = c(0, 30), CD20 = c(0, 40), CD8a = c(0, 50), CD38 = c(0, 10), Ki67 = c(0, 70))) plotPixels(norm_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;)) 11.2 Cell visualization In the following section, we will show examples on how to visualize single cells either as segmentation masks or outlined on composite images. This type of visualization allows to observe the spatial distribution of cell phenotypes, the visual assessment of morphological features and quality control in terms of cell segmentation and phenotyping. 11.2.1 Visualzing metadata The cytomapper package provides the plotCells function that accepts a CytoImageList object containing segmentation masks. These are defined as single channel images where sets of pixels with the same integer ID identify individual cells. This integer ID can be found as an entry in the colData(spe) slot and as pixel information in the segmentation masks. The entry in colData(spe) needs to be specified via the cell_id argument to the plotCells function. In that way, data contained in the SpatialExperiment object can be mapped to segmentation masks. For the current dataset, the cell IDs are stored in colData(spe)$ObjectNumber. As cell IDs are only unique within a single image, plotCells also requires the img_id argument. This argument specifies the colData(spe) as well as the mcols(masks) entry that stores the unique image name from which each cell was extracted. In the current dataset the unique image names are stored in colData(spe)$sample_id and mcols(masks)$sample_id. Providing these two entries that allow mapping between the SpatialExperiment object and segmentation masks, we can now color individual cells based on their cell type: plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;) For consistent visualization, the plotCells function takes a named list as color argument. The entry name must match the colour_by argument. plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;, colour = list(celltype = metadata(spe)$color_vectors$celltype)) If only individual cell types should be visualized, the SpatialExperiment object can be subsetted (e.g., to only contain CD8+ T cells). In the following example CD8+ T cells are colored in red and all other cells that are not contained in the dataset are colored in white (as set by the missing_color argument). CD8 &lt;- spe[,spe$celltype == &quot;CD8&quot;] plotCells(cur_masks, object = CD8, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;, colour = list(celltype = c(CD8 = &quot;red&quot;)), missing_colour = &quot;white&quot;) In terms of visualizing metadata, any entry in the colData(spe) slot can be visualized. The plotCells function automatically detects if the entry is continuous or discrete. In this fashion, we can now visualize the area of each cell: plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;area&quot;) 11.2.2 Visualizating expression Similar to visualizing single-cell metadata on segmentation masks, we can use the plotCells function to visualize the aggregated pixel intensities per cell. In the current dataset pixel intensities were aggregated by computing the mean pixel intensity per cell and per channel. The plotCells function accepts the exprs_values argument (default counts) that allows selecting the assay which stores the expression values that should be visualized. In the following example, we visualize the asinh-transformed mean pixel intensities of the epithelial marker E-cadherin on segmentation masks. plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;Ecad&quot;, exprs_values = &quot;exprs&quot;) We will now visualize the maximum number of allowed markers as composites on the segmentation masks. As above the markers indicate the spatial distribution of tumor cells (E-cadherin), T cells (CD3), B cells (CD20), CD8+ T cells (CD8a), plasma cells (CD38) and proliferating cells (Ki67). plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;), exprs_values = &quot;exprs&quot;) While visualizing 6 markers on the pixel-level may still allow the distinction of different tissue structures, observing single-cell expression levels is difficult when visualizing many markers simultaneously due to often overlapping expression. Similarly to adjusting marker colors when visualizing pixel intensities, we can change the color gradients per marker by setting the color argument: plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;), exprs_values = &quot;exprs&quot;, colour = list(Ecad = c(&quot;black&quot;, &quot;burlywood1&quot;), CD3 = c(&quot;black&quot;, &quot;cyan2&quot;), CD20 = c(&quot;black&quot;, &quot;firebrick1&quot;))) 11.2.3 Outlining cells on images The following section highlights the combined visualization of pixel- and cell-level information at once. For this, besides the SpatialExperiment object, the plotPixels function accepts two CytoImageList objects. One for the multi-channel images and one for the segmentation masks. By specifying the outline_by parameter, the outlines of cells can now be colored based on their metadata. The following example first generates a 3-channel composite images displaying the expression of E-cadherin, CD3 and CD20 before coloring the cells’ outlines by their cell phenotype. plotPixels(image = cur_images, mask = cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;), outline_by = &quot;celltype&quot;, bcg = list(Ecad = c(0, 5, 1), CD3 = c(0, 5, 1), CD20 = c(0, 5, 1)), colour = list(celltype = metadata(spe)$color_vectors$celltype), thick = TRUE) Distinguishing individual cell phenotypes is nearly impossible in the images above. However, the SpatialExperiment object can be subsetted to only contain cells of a single or few phenotypes. This allows the selective visualization of cell outlines on composite images. Here, we select all CD8+ T cells from the dataset and outline them on a 2-channel composite image displaying the expression of CD3 and CD8a. CD8 &lt;- spe[,spe$celltype == &quot;CD8&quot;] plotPixels(image = cur_images, mask = cur_masks, object = CD8, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = c(&quot;CD3&quot;, &quot;CD8a&quot;), outline_by = &quot;celltype&quot;, bcg = list(CD3 = c(0, 5, 1), CD8a = c(0, 5, 1)), colour = list(celltype = c(&quot;CD8&quot; = &quot;white&quot;)), thick = TRUE) This type of visualization allows the quality control of two things: 1. segmentation quality of individual cell types can be checked and 2. cell phenotyping accuracy can be visually assessed against expected marker expression. 11.3 Adjusting plot annotations The cytomapper package provides a number of function arguments to adjust the visual appearance of figures that are shared between the plotPixels and plotCells function. For a full overview of the arguments please refer to ?plotting-param. We use the following example to highlight how to adjust the scale bar, the image title, the legend appearance and the margin between images. plotPixels(cur_images, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;, &quot;CD8a&quot;, &quot;CD38&quot;, &quot;Ki67&quot;), bcg = list(Ecad = c(0, 5, 1), CD3 = c(0, 5, 1), CD20 = c(0, 5, 1), CD8a = c(0, 5, 1), CD38 = c(0, 8, 1), Ki67 = c(0, 5, 1)), scale_bar = list(length = 100, label = expression(&quot;100 &quot; ~ mu * &quot;m&quot;), cex = 0.7, lwidth = 10, colour = &quot;grey&quot;, position = &quot;bottomleft&quot;, margin = c(5,5), frame = 3), image_title = list(text = mcols(cur_images)$indication, position = &quot;topright&quot;, colour = &quot;grey&quot;, margin = c(5,5), font = 2, cex = 2), legend = list(colour_by.title.cex = 0.7, margin = 10), margin = 40) 11.4 Displaying individual images By default, all images are displayed on the same graphics device. This can be useful when saving all images at once (see next section) to zoom into the individual images instead of opening each image individually. However, when displaying images in a markdown document these are more accessible when visualized individually. For this, the plotPixels and plotCells function accepts the display parameter that when set to \"single\" displays each resulting image in its own graphics device: plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;, colour = list(celltype = metadata(spe)$color_vectors$celltype), display = &quot;single&quot;, legend = NULL) 11.5 Saving and returning images The final section addresses how to save composite images and how to return them for integration with other plots. The plotPixels and plotCells functions accept the save_plot argument which takes a named list of the following entries: filename indicates the location and file type of the image saved to disk; scale adjusts the resolution of the saved image (this only needs to be adjusted for small images). plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;, colour = list(celltype = metadata(spe)$color_vectors$celltype), save_plot = list(filename = &quot;data/celltype_image.png&quot;)) The composite images (together with their annotation) can also be returned. In the following code chunk we save two example plots to variables (out1 and out2). out1 &lt;- plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = &quot;celltype&quot;, colour = list(celltype = metadata(spe)$color_vectors$celltype), return_plot = TRUE) out2 &lt;- plotCells(cur_masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;, colour_by = c(&quot;Ecad&quot;, &quot;CD3&quot;, &quot;CD20&quot;), exprs_values = &quot;exprs&quot;, return_plot = TRUE) The composite images are stored in out1$plot and out2$plot and can be converted into a graph object recognized by the cowplot package. The final function call of the following chunk plots both object next to each other. library(cowplot) library(gridGraphics) p1 &lt;- ggdraw(out1$plot, clip = &quot;on&quot;) p2 &lt;- ggdraw(out2$plot, clip = &quot;on&quot;) plot_grid(p1, p2) 11.6 Interactive image visualization The cytoviewer R/Bioconductor package (Meyer, Eling, and Bodenmiller 2024) extends the static visualization abilities from cytomapper via an interactive and user-friendly shiny application. It supports flexible generation of image composites, allows side-by-side visualization of single channels, and facilitates the spatial visualization of single-cell data in the form of segmentation masks. Rapid and publication-quality image downloads are also supported. For a full introduction to the package, please refer to the vignette. library(cytoviewer) app &lt;- cytoviewer(image = images, mask = masks, object = spe, cell_id = &quot;ObjectNumber&quot;, img_id = &quot;sample_id&quot;) if (interactive()) { shiny::runApp(app) } 11.7 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] cytoviewer_1.2.0 gridGraphics_0.5-1 ## [3] cowplot_1.1.2 cytomapper_1.14.0 ## [5] EBImage_4.44.0 SpatialExperiment_1.12.0 ## [7] SingleCellExperiment_1.24.0 SummarizedExperiment_1.32.0 ## [9] Biobase_2.62.0 GenomicRanges_1.54.1 ## [11] GenomeInfoDb_1.38.5 IRanges_2.36.0 ## [13] S4Vectors_0.40.2 BiocGenerics_0.48.1 ## [15] MatrixGenerics_1.14.0 matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] splines_4.3.2 later_1.3.2 ## [3] bitops_1.0-7 tibble_3.2.1 ## [5] svgPanZoom_0.3.4 polyclip_1.10-6 ## [7] XML_3.99-0.16 lifecycle_1.0.4 ## [9] rstatix_0.7.2 doParallel_1.0.17 ## [11] lattice_0.21-9 MASS_7.3-60 ## [13] backports_1.4.1 magrittr_2.0.3 ## [15] sass_0.4.8 rmarkdown_2.25 ## [17] jquerylib_0.1.4 yaml_2.3.8 ## [19] plotrix_3.8-4 httpuv_1.6.13 ## [21] sp_2.1-2 RColorBrewer_1.1-3 ## [23] ConsensusClusterPlus_1.66.0 multcomp_1.4-25 ## [25] abind_1.4-5 zlibbioc_1.48.0 ## [27] Rtsne_0.17 purrr_1.0.2 ## [29] RCurl_1.98-1.13 TH.data_1.1-2 ## [31] tweenr_2.0.2 sandwich_3.1-0 ## [33] circlize_0.4.15 GenomeInfoDbData_1.2.11 ## [35] ggrepel_0.9.4 irlba_2.3.5.1 ## [37] CATALYST_1.26.0 terra_1.7-65 ## [39] svglite_2.1.3 DelayedMatrixStats_1.24.0 ## [41] codetools_0.2-19 DelayedArray_0.28.0 ## [43] scuttle_1.12.0 ggforce_0.4.1 ## [45] tidyselect_1.2.0 shape_1.4.6 ## [47] raster_3.6-26 farver_2.1.1 ## [49] ScaledMatrix_1.10.0 viridis_0.6.4 ## [51] jsonlite_1.8.8 BiocNeighbors_1.20.1 ## [53] GetoptLong_1.0.5 ellipsis_0.3.2 ## [55] ggridges_0.5.5 survival_3.5-7 ## [57] scater_1.30.1 iterators_1.0.14 ## [59] systemfonts_1.0.5 foreach_1.5.2 ## [61] tools_4.3.2 ggnewscale_0.4.9 ## [63] Rcpp_1.0.11 glue_1.6.2 ## [65] gridExtra_2.3 SparseArray_1.2.3 ## [67] xfun_0.41 dplyr_1.1.4 ## [69] HDF5Array_1.30.0 shinydashboard_0.7.2 ## [71] withr_2.5.2 fastmap_1.1.1 ## [73] rhdf5filters_1.14.1 fansi_1.0.6 ## [75] rsvd_1.0.5 digest_0.6.33 ## [77] R6_2.5.1 mime_0.12 ## [79] colorspace_2.1-0 gtools_3.9.5 ## [81] jpeg_0.1-10 utf8_1.2.4 ## [83] tidyr_1.3.0 generics_0.1.3 ## [85] data.table_1.14.10 htmlwidgets_1.6.4 ## [87] S4Arrays_1.2.0 pkgconfig_2.0.3 ## [89] gtable_0.3.4 ComplexHeatmap_2.18.0 ## [91] RProtoBufLib_2.14.0 XVector_0.42.0 ## [93] htmltools_0.5.7 carData_3.0-5 ## [95] bookdown_0.37 fftwtools_0.9-11 ## [97] clue_0.3-65 scales_1.3.0 ## [99] png_0.1-8 colorRamps_2.3.1 ## [101] knitr_1.45 reshape2_1.4.4 ## [103] rjson_0.2.21 cachem_1.0.8 ## [105] zoo_1.8-12 rhdf5_2.46.1 ## [107] GlobalOptions_0.1.2 stringr_1.5.1 ## [109] shinycssloaders_1.0.0 miniUI_0.1.1.1 ## [111] parallel_4.3.2 vipor_0.4.7 ## [113] pillar_1.9.0 vctrs_0.6.5 ## [115] promises_1.2.1 ggpubr_0.6.0 ## [117] BiocSingular_1.18.0 car_3.1-2 ## [119] cytolib_2.14.0 beachmat_2.18.0 ## [121] xtable_1.8-4 cluster_2.1.4 ## [123] archive_1.1.7 beeswarm_0.4.0 ## [125] evaluate_0.23 magick_2.8.2 ## [127] mvtnorm_1.2-4 cli_3.6.2 ## [129] locfit_1.5-9.8 compiler_4.3.2 ## [131] rlang_1.1.2 crayon_1.5.2 ## [133] ggsignif_0.6.4 FlowSOM_2.10.0 ## [135] flowCore_2.14.0 plyr_1.8.9 ## [137] ggbeeswarm_0.7.2 stringi_1.8.3 ## [139] viridisLite_0.4.2 BiocParallel_1.36.0 ## [141] nnls_1.5 munsell_0.5.0 ## [143] tiff_0.1-12 colourpicker_1.3.0 ## [145] Matrix_1.6-4 sparseMatrixStats_1.14.0 ## [147] ggplot2_3.4.4 Rhdf5lib_1.24.1 ## [149] shiny_1.8.0 highr_0.10 ## [151] fontawesome_0.5.2 drc_3.0-1 ## [153] memoise_2.0.1 igraph_1.6.0 ## [155] broom_1.0.5 bslib_0.6.1 References "],["performing-spatial-analysis.html", "12 Performing spatial analysis 12.1 Spatial interaction graphs 12.2 Spatial visualization 12.3 Spatial community analysis 12.4 Cellular neighborhood analysis 12.5 Spatial context analysis 12.6 Patch detection 12.7 Interaction analysis 12.8 Session Info", " 12 Performing spatial analysis Highly multiplexed imaging technologies measure the spatial distributions of molecule abundances across tissue sections. As such, having the option to analyze single cells in their spatial tissue context is a key strength of these technologies. A number of software packages such as squidpy, giotto and Seurat have been developed to analyse and visualize cells in their spatial context. The following chapter will highlight the use of imcRtools and other Bioconductor packages to visualize and analyse single-cell data obtained from highly multiplexed imaging technologies. We will first read in the spatially-annotated single-cell data processed in the previous sections. library(SpatialExperiment) spe &lt;- readRDS(&quot;data/spe.rds&quot;) 12.1 Spatial interaction graphs Many spatial analysis approaches either compare the observed versus expected number of cells around a given cell type (point process) or utilize interaction graphs (spatial object graphs) to estimate clustering or interaction frequencies between cell types. The steinbock framework allows the construction of these spatial graphs. During image processing (see Section 4.3), we have constructed a spatial graph by expanding the individual cell masks by 4 pixels. The imcRtools package further allows the ad hoc consctruction of spatial graphs directly using a SpatialExperiment or SingleCellExperiment object while considering the spatial location (centroids) of individual cells. The buildSpatialGraph function allows constructing spatial graphs by detecting the k-nearest neighbors in 2D (knn), by detecting all cells within a given distance to the center cell (expansion) and by Delaunay triangulation (delaunay). When constructing a knn graph, the number of neighbors (k) needs to be set and (optionally) the maximum distance to consider (max_dist) can be specified. When constructing a graph via expansion, the distance to expand (threshold) needs to be provided. For graphs constructed via Delaunay triangulation, the max_dist parameter can be set to avoid unusually large connections at the edge of the image. library(imcRtools) spe &lt;- buildSpatialGraph(spe, img_id = &quot;sample_id&quot;, type = &quot;knn&quot;, k = 20) ## The returned object is ordered by the &#39;sample_id&#39; entry. spe &lt;- buildSpatialGraph(spe, img_id = &quot;sample_id&quot;, type = &quot;expansion&quot;, threshold = 20) ## The returned object is ordered by the &#39;sample_id&#39; entry. spe &lt;- buildSpatialGraph(spe, img_id = &quot;sample_id&quot;, type = &quot;delaunay&quot;, max_dist = 20) ## The returned object is ordered by the &#39;sample_id&#39; entry. The spatial graphs are stored in colPair(spe, name) slots. These slots store SelfHits objects representing edge lists in which the first column indicates the index of the “from” cell and the second column the index of the “to” cell. Each edge list is newly constructed when subsetting the object. colPairNames(spe) ## [1] &quot;neighborhood&quot; &quot;knn_interaction_graph&quot; ## [3] &quot;expansion_interaction_graph&quot; &quot;delaunay_interaction_graph&quot; Here, colPair(spe, \"neighborhood\") stores the spatial graph constructed by steinbock, colPair(spe, \"knn_interaction_graph\") stores the knn spatial graph, colPair(spe, \"expansion_interaction_graph\") stores the expansion graph and colPair(spe, \"delaunay_interaction_graph\") stores the graph constructed by Delaunay triangulation. 12.2 Spatial visualization Section 11 highlights the use of the cytomapper package to visualize multichannel images and segmentation masks. Here, we introduce the plotSpatial function of the imcRtools package to visualize the cells’ centroids and cell-cell interactions as spatial graphs. In the following example, we select one image for visualization purposes. Here, each dot (node) represents a cell and edges are drawn between cells in close physical proximity as detected by steinbock or the buildSpatialGraph function. Nodes are variably colored based on the cell type and edges are colored in grey. library(ggplot2) library(viridis) # steinbock interaction graph plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;celltype&quot;, img_id = &quot;sample_id&quot;, draw_edges = TRUE, colPairName = &quot;neighborhood&quot;, nodes_first = FALSE, edge_color_fix = &quot;grey&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + ggtitle(&quot;steinbock interaction graph&quot;) # knn interaction graph plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;celltype&quot;, img_id = &quot;sample_id&quot;, draw_edges = TRUE, colPairName = &quot;knn_interaction_graph&quot;, nodes_first = FALSE, edge_color_fix = &quot;grey&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + ggtitle(&quot;knn interaction graph&quot;) # expansion interaction graph plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;celltype&quot;, img_id = &quot;sample_id&quot;, draw_edges = TRUE, colPairName = &quot;expansion_interaction_graph&quot;, nodes_first = FALSE, edge_color_fix = &quot;grey&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + ggtitle(&quot;expansion interaction graph&quot;) # delaunay interaction graph plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;celltype&quot;, img_id = &quot;sample_id&quot;, draw_edges = TRUE, colPairName = &quot;delaunay_interaction_graph&quot;, nodes_first = FALSE, edge_color_fix = &quot;grey&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) + ggtitle(&quot;delaunay interaction graph&quot;) Nodes can also be colored based on the cells’ expression levels (e.g., E-cadherin expression) and their size can be adjusted (e.g., based on measured cell area). plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;Ecad&quot;, assay_type = &quot;exprs&quot;, img_id = &quot;sample_id&quot;, draw_edges = TRUE, colPairName = &quot;expansion_interaction_graph&quot;, nodes_first = FALSE, node_size_by = &quot;area&quot;, directed = FALSE, edge_color_fix = &quot;grey&quot;) + scale_size_continuous(range = c(0.1, 2)) + ggtitle(&quot;E-cadherin expression&quot;) Finally, the plotSpatial function allows displaying all images at once. This visualization can be useful to quickly detect larger structures of interest. plotSpatial(spe, node_color_by = &quot;celltype&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) For a full documentation on the plotSpatial function, please refer to ?plotSpatial. 12.3 Spatial community analysis The detection of spatial communities was proposed by (Jackson et al. 2020). Here, cells are clustered solely based on their interactions as defined by the spatial object graph. We can perform spatial community detection across all cells as displayed in the next code chunk. Communities with less than 10 cells are excluded. Of note: we set the seed outside of the function call for reproducibility porposes as internally the louvain modularity optimization function is used which gives different results over different runs. set.seed(230621) spe &lt;- detectCommunity(spe, colPairName = &quot;neighborhood&quot;, size_threshold = 10) plotSpatial(spe, node_color_by = &quot;spatial_community&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Spatial tumor communities&quot;) + scale_color_manual(values = rev(colors())) The example shown above might not be of interest if different tissue structures exist within which spatial communities should be computed. In the following example, we perform spatial community detection separately for tumor and stromal cells. The general procedure is as follows: create a colData(spe) entry that specifies if a cell is part of the tumor or stroma compartment. use the detectCommunity function of the imcRtools package to cluster cells within the tumor or stroma compartment solely based on their spatial interaction graph as constructed by the steinbock package. Both tumor and stromal spatial communities are stored in the colData of the SpatialExperiment object under the spatial_community identifier. Of note: Here, and in contrast to the function call above, we set the seed argument within the SerialParam function for reproducibility purposes. We need this here due to the way the detectCommunity function is implemented when setting the group_by parameter. spe$tumor_stroma &lt;- ifelse(spe$celltype == &quot;Tumor&quot;, &quot;Tumor&quot;, &quot;Stroma&quot;) library(BiocParallel) spe &lt;- detectCommunity(spe, colPairName = &quot;neighborhood&quot;, size_threshold = 10, group_by = &quot;tumor_stroma&quot;, BPPARAM = SerialParam(RNGseed = 220819)) We can now separately visualize the tumor and stromal communities. plotSpatial(spe[,spe$celltype == &quot;Tumor&quot;], node_color_by = &quot;spatial_community&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Spatial tumor communities&quot;) + scale_color_manual(values = rev(colors())) plotSpatial(spe[,spe$celltype != &quot;Tumor&quot;], node_color_by = &quot;spatial_community&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Spatial non-tumor communities&quot;) + scale_color_manual(values = rev(colors())) The example data was acquired using a panel that mainly focuses on immune cells. We are therefore unable to detect many tumor sub-phenotypes and will focus on the stromal communities. In the next step, the fraction of cell types within each spatial stromal community is displayed. library(pheatmap) library(viridis) cur_spe &lt;- spe[,spe$celltype != &quot;Tumor&quot;] for_plot &lt;- prop.table(table(cur_spe$spatial_community, cur_spe$celltype), margin = 1) pheatmap(for_plot, color = colorRampPalette(c(&quot;dark blue&quot;, &quot;white&quot;, &quot;dark red&quot;))(100), show_rownames = FALSE, scale = &quot;column&quot;) We observe that many spatial stromal communities are made up of myeloid cells or “stromal” (non-immune) cells. Other communities are mainly made up of B cells and BnT cells indicating tertiary lymphoid structures (TLS). While plasma cells, CD4\\(^+\\) or CD8\\(^+\\) T cells tend to aggregate, only in few spatial stromal communities consists of mainly neutrophils. 12.4 Cellular neighborhood analysis The following section highlights the use of the imcRtools package to detect cellular neighborhoods. This approach has been proposed by (Goltsev et al. 2018) and (Schürch et al. 2020) to group cells based on information contained in their direct neighborhood. (Goltsev et al. 2018) perfomed Delaunay triangulation-based graph construction, neighborhood aggregation and then clustered cells. (Schürch et al. 2020) on the other hand constructed a 10-nearest neighbor graph before aggregating information across neighboring cells. In the following code chunk we will use the 20-nearest neighbor graph as constructed above to define the direct cellular neighborhood. The aggregateNeighbors function allows neighborhood aggregation in 2 different ways: For each cell the function computes the fraction of cells of a certain type (e.g., cell type) among its neighbors. For each cell it aggregates (e.g., mean) the expression counts across all neighboring cells. Based on these measures, cells can now be clustered into cellular neighborhoods. We will first compute the fraction of the different cell types among the 20-nearest neighbors and use kmeans clustering to group cells into 6 cellular neighborhoods. Of note: constructing a 20-nearest neighbor graph and clustering using kmeans with k=6 is only an example. Similar to the analysis done in Section 9.2.2, it is recommended to perform a parameter sweep across different graph construction algorithms and different parmaters k for kmeans clustering. Finding the best CN detection settings is also subject to the question at hand. Constructing graphs with more neighbors usually results in larger CNs. # By celltypes spe &lt;- aggregateNeighbors(spe, colPairName = &quot;knn_interaction_graph&quot;, aggregate_by = &quot;metadata&quot;, count_by = &quot;celltype&quot;) set.seed(220705) cn_1 &lt;- kmeans(spe$aggregatedNeighbors, centers = 6) spe$cn_celltypes &lt;- as.factor(cn_1$cluster) plotSpatial(spe, node_color_by = &quot;cn_celltypes&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_brewer(palette = &quot;Set3&quot;) There are now different visualizations to examine the cell type composition of the detected cellular neighborhoods (CN). First we can look at the total number of cells per cell type and CN. for_plot &lt;- table(as.character(spe$cn_celltypes), spe$celltype) pheatmap(for_plot, color = viridis(100), display_numbers = TRUE, number_color = &quot;white&quot;, number_format = &quot;%.0f&quot;) Next, we can observe per cell type the fraction of CN that they are distributed across. for_plot &lt;- prop.table(table(as.character(spe$cn_celltypes), spe$celltype), margin = 2) pheatmap(for_plot, color = viridis(100), display_numbers = TRUE, number_color = &quot;white&quot;, number_format = &quot;%.2f&quot;) Similarly, we can visualize the fraction of each CN made up of each cell type. for_plot &lt;- prop.table(table(as.character(spe$cn_celltypes), spe$celltype), margin = 1) pheatmap(for_plot, color = viridis(100), display_numbers = TRUE, number_color = &quot;white&quot;, number_format = &quot;%.2f&quot;) This visualization can also be scaled by column to account for the relative cell type abundance. pheatmap(for_plot, color = colorRampPalette(c(&quot;dark blue&quot;, &quot;white&quot;, &quot;dark red&quot;))(100), scale = &quot;column&quot;) Lastly, we can visualize the enrichment of cell types within cellular neighborhoods using the regionMap function of the lisaClust package. library(lisaClust) regionMap(spe, cellType = &quot;celltype&quot;, region = &quot;cn_celltypes&quot;) It is also recommended to visualize some images to confirm the interpretation of cellular neighborhoods. For this we can either use the lisClust::hatchingPlot or the imcRtools::plotSpatial functions: # hatchingPlot cur_spe &lt;- spe[,spe$sample_id == &quot;Patient1_003&quot;] cur_sce &lt;- as(cur_spe, &quot;SingleCellExperiment&quot;) cur_sce$x &lt;- spatialCoords(cur_spe)[,1] cur_sce$y &lt;- spatialCoords(cur_spe)[,2] cur_sce$region &lt;- as.character(cur_sce$cn_celltypes) hatchingPlot(cur_sce, region = &quot;region&quot;, cellType = &quot;celltype&quot;) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) ## There is no cellID. I&#39;ll create these ## There is no image specific imageCellID. I&#39;ll create these ## There is no imageID. I&#39;ll assume this is only one image and create an arbitrary imageID ## Creating variable region ## Concave windows are temperamental. Try choosing values of window.length &gt; and &lt; 1 if you have problems. # plotSpatial plotSpatial(spe[,spe$sample_id == &quot;Patient1_003&quot;], img_id = &quot;cn_celltypes&quot;, node_color_by = &quot;celltype&quot;, node_size_fix = 0.7) + scale_color_manual(values = metadata(spe)$color_vectors$celltype) CN 1 and CN 6 are mainly enriched for tumor cells with CN 6 forming the tumor/stroma border. CN 3 is mainly enriched for B and BnT cells indicating TLS. CN 5 is composed of aggregated plasma cells and most T cells. We will now detect cellular neighborhoods by computing the mean expression across the 20-nearest neighbor prior to kmeans clustering (k=6). # By expression spe &lt;- aggregateNeighbors(spe, colPairName = &quot;knn_interaction_graph&quot;, aggregate_by = &quot;expression&quot;, assay_type = &quot;exprs&quot;, subset_row = rowData(spe)$use_channel) set.seed(220705) cn_2 &lt;- kmeans(spe$mean_aggregatedExpression, centers = 6) spe$cn_expression &lt;- as.factor(cn_2$cluster) plotSpatial(spe, node_color_by = &quot;cn_expression&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_brewer(palette = &quot;Set3&quot;) Also here, we can visualize the cell type composition of each cellular neighborhood. for_plot &lt;- prop.table(table(spe$cn_expression, spe$celltype), margin = 1) pheatmap(for_plot, color = colorRampPalette(c(&quot;dark blue&quot;, &quot;white&quot;, &quot;dark red&quot;))(100), scale = &quot;column&quot;) When clustering cells based on the mean expression within the direct neighborhood, tumor cells are split across CN 6, CN 1 and CN 4 without forming a clear tumor/stroma interface. This result reflects patient-to-patient differences in the expression of tumor markers. CN 3 again contains B cells and BnT cells but also CD8 and undefined cells, therefore it is less representative of TLS compared to CN 3 in previous CN approach. CN detection based on mean marker expression is therefore sensitive to staining/expression differences between samples as well as lateral spillover due to imperfect segmentation. An alternative to the aggregateNeighbors function is provided by the lisaClust Bioconductor package (Patrick et al. 2023). In contrast to imcRtools, the lisaClust package computes local indicators of spatial associations (LISA) functions and clusters cells based on those. More precise, the package summarizes L-functions from a Poisson point process model to derive numeric vectors for each cell which can then again be clustered using kmeans. All steps are supported by the lisaClust function which can be applied to a SingleCellExperiment and SpatialExperiment object. In the following example, we calculate the LISA curves within a 10µm, 20µm and 50µm neighborhood around each cell. Increasing these radii will lead to broader and smoother spatial clusters. However, a number of parameter settings should be tested to estimate the robustness of the results. set.seed(220705) spe &lt;- lisaClust(spe, k = 6, Rs = c(10, 20, 50), spatialCoords = c(&quot;Pos_X&quot;, &quot;Pos_Y&quot;), cellType = &quot;celltype&quot;, imageID = &quot;sample_id&quot;) plotSpatial(spe, node_color_by = &quot;region&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_brewer(palette = &quot;Set3&quot;) Similar to the example above, we can now observe the cell type composition per spatial cluster. for_plot &lt;- prop.table(table(spe$region, spe$celltype), margin = 1) pheatmap(for_plot, color = colorRampPalette(c(&quot;dark blue&quot;, &quot;white&quot;, &quot;dark red&quot;))(100), scale = &quot;column&quot;) In this case, CN 1 and 4 contain tumor cells but no CN is forming the tumor/stroma interface. CN 3 represents TLS. CN 2 indicates T cell subtypes and plasma cells are aggregated to CN 5. 12.5 Spatial context analysis Downstream of CN assignments, we will analyze the spatial context (SC) of each cell using three functions from the imcRtools package. While CNs can represent sites of unique local processes, the term SC was coined by Bhate and colleagues (Bhate et al. 2022) and describes tissue regions in which distinct CNs may be interacting. Hence, SCs may be interesting regions of specialized biological events. Here, we will first detect SCs using the detectSpatialContext function. This function relies on CN fractions for each cell in a spatial interaction graph (originally a KNN graph), which we will calculate using buildSpatialGraph and aggregateNeighbors. We will focus on the CNs derived from cell type fractions but other CN assignments are possible. Of note, the window size (k for KNN) for buildSpatialGraph should reflect a length scale on which biological signals can be exchanged and depends, among others, on cell density and tissue area. In view of their divergent functionality, we recommend to use a larger window size for SC (interaction between local processes) than for CN (local processes) detection. Since we used a 20-nearest neighbor graph for CN assignment, we will use a 40-nearest neighbor graph for SC detection. As before, different parameters should be tested. Subsequently, the CN fractions are sorted from high-to-low and the SC of each cell is assigned as the minimal combination of SCs that additively surpass a user-defined threshold. The default threshold of 0.9 aims to represent the dominant CNs, hence the most prevalent signals, in a given window. For more details and biological validation, please refer to (Bhate et al. 2022). library(circlize) library(RColorBrewer) # Construct a 40-nearest neighbor graph spe &lt;- buildSpatialGraph(spe, img_id = &quot;sample_id&quot;, type = &quot;knn&quot;, name = &quot;knn_spatialcontext_graph&quot;, k = 40) # Compute the fraction of cellular neighborhoods around each cell spe &lt;- aggregateNeighbors(spe, colPairName = &quot;knn_spatialcontext_graph&quot;, aggregate_by = &quot;metadata&quot;, count_by = &quot;cn_celltypes&quot;, name = &quot;aggregatedNeighborhood&quot;) # Detect spatial contexts spe &lt;- detectSpatialContext(spe, entry = &quot;aggregatedNeighborhood&quot;, threshold = 0.90, name = &quot;spatial_context&quot;) # Define SC color scheme n_SCs &lt;- length(unique(spe$spatial_context)) col_SC &lt;- setNames(colorRampPalette(brewer.pal(9, &quot;Paired&quot;))(n_SCs), sort(unique(spe$spatial_context))) # Visualize spatial contexts on images plotSpatial(spe, node_color_by = &quot;spatial_context&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_manual(values = col_SC) We detect a total of 52 distinct SCs across this dataset. For ease of interpretation, we will directly compare the CN and SC assignments for Patient3_001. library(patchwork) # Compare CN and SC for one patient p1 &lt;- plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;cn_celltypes&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_brewer(palette = &quot;Set3&quot;) p2 &lt;- plotSpatial(spe[,spe$sample_id == &quot;Patient3_001&quot;], node_color_by = &quot;spatial_context&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_manual(values = col_SC, limits = force) p1 + p2 As expected, we can observe that interfaces between different CNs make up distinct SCs. For instance, interface between CN 3 (TLS region consisting of B and BnT cells) and CN 5 (Plasma- and T-cell dominated) turns to SC 3_5. On the other hand, the core of CN 3 becomes SC 3, since the most abundant CN of the neighborhood for these cells is just the CN itself. Next, we filter the SCs based on user-defined thresholds for number of group entries (here at least 3 patients) and/or total number of cells (here minimum of 100 cells) per SC using the filterSpatialContext function. ## Filter spatial contexts # By number of group entries spe &lt;- filterSpatialContext(spe, entry = &quot;spatial_context&quot;, group_by = &quot;patient_id&quot;, group_threshold = 3, name = &quot;spatial_context_filtered&quot;) plotSpatial(spe, node_color_by = &quot;spatial_context_filtered&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_manual(values = col_SC, limits = force) # Filter out small and infrequent spatial contexts spe &lt;- filterSpatialContext(spe, entry = &quot;spatial_context&quot;, group_by = &quot;patient_id&quot;, group_threshold = 3, cells_threshold = 100, name = &quot;spatial_context_filtered&quot;) plotSpatial(spe, node_color_by = &quot;spatial_context_filtered&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_manual(values = col_SC, limits = force) Lastly, we can use the plotSpatialContext function to generate SC graphs, analogous to CN combination maps in (Bhate et al. 2022). Returned objects are ggplots, which can be easily modified further. We will create a SC graph for the filtered SCs here. ## Plot spatial context graph # Colored by name, size by n_cells plotSpatialContext(spe, entry = &quot;spatial_context_filtered&quot;, group_by = &quot;sample_id&quot;, node_color_by = &quot;name&quot;, node_size_by = &quot;n_cells&quot;, node_label_color_by = &quot;name&quot;) # Colored by n_cells, size by n_group plotSpatialContext(spe, entry = &quot;spatial_context_filtered&quot;, group_by = &quot;sample_id&quot;, node_color_by = &quot;n_cells&quot;, node_size_by = &quot;n_group&quot;, node_label_color_by = &quot;n_cells&quot;) + scale_color_viridis() SC 1 (Tumor-dominated), SC 1_6 (Tumor and Tumor-Stroma interface) and SC 4_5 (Plasma/T cell and Myeloid/Neutrophil interface) are the most frequent SCs in this dataset. Moreover, we may compare the degree of the different nodes in the SC graph. For example, we can observe that SC 1 has only one degree (directed to SC 1_6), while SC 5 (T cells and plasma cells) has a much higher degree (n = 4) and potentially more CN interactions. 12.6 Patch detection The previous section focused on detecting cellular neighborhoods in a rather unsupervised fashion. However, the imcRtools package also provides methods for detecting spatial compartments in a supervised fashion. The patchDetection function allows the detection of connected sets of similar cells as proposed by (Hoch et al. 2022). In the following example, we will use the patchDetection function to detect tumor patches in three steps: Find connected sets of tumor cells (using the steinbock graph). Components which contain less than 10 cells are excluded. Expand the components by 1µm to construct a concave hull around the patch and include cells within the patch. spe &lt;- patchDetection(spe, patch_cells = spe$celltype == &quot;Tumor&quot;, img_id = &quot;sample_id&quot;, expand_by = 1, min_patch_size = 10, colPairName = &quot;neighborhood&quot;, BPPARAM = MulticoreParam()) ## The returned object is ordered by the &#39;sample_id&#39; entry. plotSpatial(spe, node_color_by = &quot;patch_id&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + theme(legend.position = &quot;none&quot;) + scale_color_manual(values = rev(colors())) We can now calculate the fraction of T cells within each tumor patch to roughly estimate T cell infiltration. library(tidyverse) colData(spe) %&gt;% as_tibble() %&gt;% group_by(patch_id, sample_id) %&gt;% summarize(Tcell_count = sum(celltype == &quot;CD8&quot; | celltype == &quot;CD4&quot;), patch_size = n(), Tcell_freq = Tcell_count / patch_size) %&gt;% filter(!is.na(patch_id)) %&gt;% ggplot() + geom_point(aes(log10(patch_size), Tcell_freq, color = sample_id)) + theme_classic() We can now measure the size of each patch using the patchSize function and visualize tumor patch distribution per patient. patch_size &lt;- patchSize(spe, &quot;patch_id&quot;) patch_size &lt;- merge(patch_size, colData(spe)[match(patch_size$patch_id, spe$patch_id),], by = &quot;patch_id&quot;) ggplot(as.data.frame(patch_size)) + geom_boxplot(aes(patient_id, log10(size))) + geom_point(aes(patient_id, log10(size))) The minDistToCells function can be used to calculate the minimum distance between each cell and a cell set of interest. Here, we highlight its use to calculate the minimum distance of all cells to the detected tumor patches. Negative values indicate the minimum distance of each tumor patch cell to a non-tumor patch cell. spe &lt;- minDistToCells(spe, x_cells = !is.na(spe$patch_id), img_id = &quot;sample_id&quot;) ## The returned object is ordered by the &#39;sample_id&#39; entry. plotSpatial(spe, node_color_by = &quot;distToCells&quot;, img_id = &quot;sample_id&quot;, node_size_fix = 0.5) + scale_color_gradient2(low = &quot;dark blue&quot;, mid = &quot;white&quot;, high = &quot;dark red&quot;) Finally, we can observe the minimum distances to tumor patches in a cell type specific manner. library(ggridges) ggplot(as.data.frame(colData(spe))) + geom_density_ridges(aes(distToCells, celltype, fill = celltype)) + geom_vline(xintercept = 0, color = &quot;dark red&quot;, linewidth = 2) + scale_fill_manual(values = metadata(spe)$color_vectors$celltype) 12.7 Interaction analysis Bug notice: we discovered and fixed a bug in the testInteractions function in version below 1.5.5 which affected SingleCellExperiment or SpatialExperiment objects in which cells were not grouped by image. Please make sure you have the newest version (&gt;= 1.6.0) installed. The next section focuses on statistically testing the pairwise interaction between all cell types of the dataset. For this, the imcRtools package provides the testInteractions function which implements the interaction testing strategy proposed by (Schapiro et al. 2017). Per grouping level (e.g., image), the testInteractions function computes the averaged cell type/cell type interaction count and compares this count against an empirical null distribution which is generated by permuting all cell labels (while maintaining the tissue structure). In the following example, we use the steinbock generated spatial interaction graph and estimate the interaction or avoidance between cell types in the dataset. library(scales) out &lt;- testInteractions(spe, group_by = &quot;sample_id&quot;, label = &quot;celltype&quot;, colPairName = &quot;neighborhood&quot;, BPPARAM = SerialParam(RNGseed = 221029)) head(out) ## DataFrame with 6 rows and 10 columns ## group_by from_label to_label ct p_gt p_lt ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## 1 Patient1_001 Bcell Bcell 0 1.000000 1.000000 ## 2 Patient1_001 Bcell BnTcell 0 1.000000 0.998002 ## 3 Patient1_001 Bcell CD4 3 0.001998 1.000000 ## 4 Patient1_001 Bcell CD8 0 1.000000 0.898102 ## 5 Patient1_001 Bcell Myeloid 0 1.000000 0.804196 ## 6 Patient1_001 Bcell Neutrophil NA NA NA ## interaction p sig sigval ## &lt;logical&gt; &lt;numeric&gt; &lt;logical&gt; &lt;numeric&gt; ## 1 FALSE 1.000000 FALSE 0 ## 2 FALSE 0.998002 FALSE 0 ## 3 TRUE 0.001998 TRUE 1 ## 4 FALSE 0.898102 FALSE 0 ## 5 FALSE 0.804196 FALSE 0 ## 6 NA NA NA NA The returned DataFrame contains the test results per grouping level (in this case the image ID, group_by), “from” cell type (from_label) and “to” cell type (to_label). The sigval entry indicates if a pair of cell types is significantly interacting (sigval = 1), if a pair of cell types is significantly avoiding (sigval = -1) or if no significant interaction or avoidance was detected (sigval = 0). These results can be visualized by computing the sum of the sigval entries across all images: out %&gt;% as_tibble() %&gt;% group_by(from_label, to_label) %&gt;% summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %&gt;% ggplot() + geom_tile(aes(from_label, to_label, fill = sum_sigval)) + scale_fill_gradient2(low = muted(&quot;blue&quot;), mid = &quot;white&quot;, high = muted(&quot;red&quot;)) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) In the plot above the red tiles indicate cell type pairs that were detected to significantly interact on a large number of images. On the other hand, blue tiles show cell type pairs which tend to avoid each other on a large number of images. Here we can observe that tumor cells are mostly compartmentalized and are in avoidance with other cell types. As expected, B cells interact with BnT cells; regulatory T cells interact with CD4+ T cells and CD8+ T cells. Most cell types show self interactions indicating spatial clustering. The imcRtools package further implements an interaction testing strategy proposed by (Schulz et al. 2018) where the hypothesis is tested if at least n cells of a certain type are located around a target cell type (from_cell). This type of testing can be performed by selecting method = \"patch\" and specifying the number of patch cells via the patch_size parameter. out &lt;- testInteractions(spe, group_by = &quot;sample_id&quot;, label = &quot;celltype&quot;, colPairName = &quot;neighborhood&quot;, method = &quot;patch&quot;, patch_size = 3, BPPARAM = SerialParam(RNGseed = 221029)) out %&gt;% as_tibble() %&gt;% group_by(from_label, to_label) %&gt;% summarize(sum_sigval = sum(sigval, na.rm = TRUE)) %&gt;% ggplot() + geom_tile(aes(from_label, to_label, fill = sum_sigval)) + scale_fill_gradient2(low = muted(&quot;blue&quot;), mid = &quot;white&quot;, high = muted(&quot;red&quot;)) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) These results are comparable to the interaction testing presented above. The main difference comes from the lack of symmetry. We can now for example see that 3 or more myeloid cells sit around CD4\\(^+\\) T cells while this interaction is not as strong when considering CD4\\(^+\\) T cells sitting around myeloid cells. Finally, we save the updated SpatialExperiment object. saveRDS(spe, &quot;data/spe.rds&quot;) 12.8 Session Info SessionInfo ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so; LAPACK version 3.10.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Etc/UTC ## tzcode source: system (glibc) ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] testthat_3.2.1 scales_1.3.0 ## [3] ggridges_0.5.5 lubridate_1.9.3 ## [5] forcats_1.0.0 stringr_1.5.1 ## [7] dplyr_1.1.4 purrr_1.0.2 ## [9] readr_2.1.4 tidyr_1.3.0 ## [11] tibble_3.2.1 tidyverse_2.0.0 ## [13] patchwork_1.1.3 RColorBrewer_1.1-3 ## [15] circlize_0.4.15 lisaClust_1.10.1 ## [17] pheatmap_1.0.12 BiocParallel_1.36.0 ## [19] viridis_0.6.4 viridisLite_0.4.2 ## [21] ggplot2_3.4.4 imcRtools_1.8.0 ## [23] SpatialExperiment_1.12.0 SingleCellExperiment_1.24.0 ## [25] SummarizedExperiment_1.32.0 Biobase_2.62.0 ## [27] GenomicRanges_1.54.1 GenomeInfoDb_1.38.5 ## [29] IRanges_2.36.0 S4Vectors_0.40.2 ## [31] BiocGenerics_0.48.1 MatrixGenerics_1.14.0 ## [33] matrixStats_1.2.0 ## ## loaded via a namespace (and not attached): ## [1] spatstat.sparse_3.0-3 bitops_1.0-7 ## [3] sf_1.0-15 EBImage_4.44.0 ## [5] doParallel_1.0.17 numDeriv_2016.8-1.1 ## [7] tools_4.3.2 backports_1.4.1 ## [9] utf8_1.2.4 R6_2.5.1 ## [11] DT_0.31 HDF5Array_1.30.0 ## [13] mgcv_1.9-0 rhdf5filters_1.14.1 ## [15] GetoptLong_1.0.5 withr_2.5.2 ## [17] sp_2.1-2 gridExtra_2.3 ## [19] ClassifyR_3.6.2 cli_3.6.2 ## [21] spatstat.explore_3.2-5 sandwich_3.1-0 ## [23] labeling_0.4.3 sass_0.4.8 ## [25] nnls_1.5 mvtnorm_1.2-4 ## [27] spatstat.data_3.0-3 proxy_0.4-27 ## [29] systemfonts_1.0.5 colorRamps_2.3.1 ## [31] svglite_2.1.3 scater_1.30.1 ## [33] plotrix_3.8-4 flowCore_2.14.0 ## [35] generics_0.1.3 shape_1.4.6 ## [37] spatstat.random_3.2-2 gtools_3.9.5 ## [39] vroom_1.6.5 car_3.1-2 ## [41] scam_1.2-14 Matrix_1.6-4 ## [43] RProtoBufLib_2.14.0 ggbeeswarm_0.7.2 ## [45] fansi_1.0.6 abind_1.4-5 ## [47] terra_1.7-65 lifecycle_1.0.4 ## [49] multcomp_1.4-25 yaml_2.3.8 ## [51] carData_3.0-5 rhdf5_2.46.1 ## [53] SparseArray_1.2.3 Rtsne_0.17 ## [55] grid_4.3.2 promises_1.2.1 ## [57] crayon_1.5.2 shinydashboard_0.7.2 ## [59] lattice_0.21-9 beachmat_2.18.0 ## [61] cowplot_1.1.2 magick_2.8.2 ## [63] cytomapper_1.14.0 pillar_1.9.0 ## [65] knitr_1.45 ComplexHeatmap_2.18.0 ## [67] RTriangle_1.6-0.12 boot_1.3-28.1 ## [69] rjson_0.2.21 codetools_0.2-19 ## [71] glue_1.6.2 V8_4.4.1 ## [73] data.table_1.14.10 MultiAssayExperiment_1.28.0 ## [75] vctrs_0.6.5 png_0.1-8 ## [77] gtable_0.3.4 cachem_1.0.8 ## [79] xfun_0.41 S4Arrays_1.2.0 ## [81] mime_0.12 tidygraph_1.3.0 ## [83] ConsensusClusterPlus_1.66.0 survival_3.5-7 ## [85] iterators_1.0.14 cytolib_2.14.0 ## [87] units_0.8-5 ellipsis_0.3.2 ## [89] TH.data_1.1-2 nlme_3.1-163 ## [91] bit64_4.0.5 rprojroot_2.0.4 ## [93] bslib_0.6.1 irlba_2.3.5.1 ## [95] svgPanZoom_0.3.4 vipor_0.4.7 ## [97] KernSmooth_2.23-22 colorspace_2.1-0 ## [99] DBI_1.2.0 raster_3.6-26 ## [101] tidyselect_1.2.0 curl_5.2.0 ## [103] bit_4.0.5 compiler_4.3.2 ## [105] BiocNeighbors_1.20.1 desc_1.4.3 ## [107] DelayedArray_0.28.0 bookdown_0.37 ## [109] classInt_0.4-10 distances_0.1.10 ## [111] goftest_1.2-3 tiff_0.1-12 ## [113] digest_0.6.33 minqa_1.2.6 ## [115] fftwtools_0.9-11 spatstat.utils_3.0-4 ## [117] rmarkdown_2.25 XVector_0.42.0 ## [119] CATALYST_1.26.0 htmltools_0.5.7 ## [121] pkgconfig_2.0.3 jpeg_0.1-10 ## [123] lme4_1.1-35.1 sparseMatrixStats_1.14.0 ## [125] highr_0.10 fastmap_1.1.1 ## [127] rlang_1.1.2 GlobalOptions_0.1.2 ## [129] htmlwidgets_1.6.4 shiny_1.8.0 ## [131] DelayedMatrixStats_1.24.0 farver_2.1.1 ## [133] jquerylib_0.1.4 zoo_1.8-12 ## [135] jsonlite_1.8.8 spicyR_1.14.2 ## [137] BiocSingular_1.18.0 RCurl_1.98-1.13 ## [139] magrittr_2.0.3 scuttle_1.12.0 ## [141] GenomeInfoDbData_1.2.11 Rhdf5lib_1.24.1 ## [143] munsell_0.5.0 Rcpp_1.0.11 ## [145] ggnewscale_0.4.9 stringi_1.8.3 ## [147] ggraph_2.1.0 brio_1.1.4 ## [149] zlibbioc_1.48.0 MASS_7.3-60 ## [151] plyr_1.8.9 parallel_4.3.2 ## [153] ggrepel_0.9.4 deldir_2.0-2 ## [155] graphlayouts_1.0.2 splines_4.3.2 ## [157] tensor_1.5 hms_1.1.3 ## [159] locfit_1.5-9.8 igraph_1.6.0 ## [161] ggpubr_0.6.0 spatstat.geom_3.2-7 ## [163] ggsignif_0.6.4 pkgload_1.3.3 ## [165] reshape2_1.4.4 ScaledMatrix_1.10.0 ## [167] XML_3.99-0.16 drc_3.0-1 ## [169] evaluate_0.23 nloptr_2.0.3 ## [171] tzdb_0.4.0 foreach_1.5.2 ## [173] tweenr_2.0.2 httpuv_1.6.13 ## [175] polyclip_1.10-6 clue_0.3-65 ## [177] ggforce_0.4.1 rsvd_1.0.5 ## [179] broom_1.0.5 xtable_1.8-4 ## [181] e1071_1.7-14 rstatix_0.7.2 ## [183] later_1.3.2 class_7.3-22 ## [185] lmerTest_3.1-3 FlowSOM_2.10.0 ## [187] beeswarm_0.4.0 cluster_2.1.4 ## [189] timechange_0.2.0 concaveman_1.1.0 References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
